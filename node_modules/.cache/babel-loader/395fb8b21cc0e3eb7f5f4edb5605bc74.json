{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar m4FromQuat = require('gl-mat4/fromQuat');\n\nvar Registry = require('../registry');\n\nvar Lib = require('../lib');\n\nvar Plots = require('../plots/plots');\n\nvar AxisIds = require('../plots/cartesian/axis_ids');\n\nvar Color = require('../components/color');\n\nvar cleanId = AxisIds.cleanId;\nvar getFromTrace = AxisIds.getFromTrace;\nvar traceIs = Registry.traceIs; // clear the promise queue if one of them got rejected\n\nexports.clearPromiseQueue = function (gd) {\n  if (Array.isArray(gd._promises) && gd._promises.length > 0) {\n    Lib.log('Clearing previous rejected promises from queue.');\n  }\n\n  gd._promises = [];\n}; // make a few changes to the layout right away\n// before it gets used for anything\n// backward compatibility and cleanup of nonstandard options\n\n\nexports.cleanLayout = function (layout) {\n  var i, j;\n  if (!layout) layout = {}; // cannot have (x|y)axis1, numbering goes axis, axis2, axis3...\n\n  if (layout.xaxis1) {\n    if (!layout.xaxis) layout.xaxis = layout.xaxis1;\n    delete layout.xaxis1;\n  }\n\n  if (layout.yaxis1) {\n    if (!layout.yaxis) layout.yaxis = layout.yaxis1;\n    delete layout.yaxis1;\n  }\n\n  if (layout.scene1) {\n    if (!layout.scene) layout.scene = layout.scene1;\n    delete layout.scene1;\n  }\n\n  var axisAttrRegex = (Plots.subplotsRegistry.cartesian || {}).attrRegex;\n  var polarAttrRegex = (Plots.subplotsRegistry.polar || {}).attrRegex;\n  var ternaryAttrRegex = (Plots.subplotsRegistry.ternary || {}).attrRegex;\n  var sceneAttrRegex = (Plots.subplotsRegistry.gl3d || {}).attrRegex;\n  var keys = Object.keys(layout);\n\n  for (i = 0; i < keys.length; i++) {\n    var key = keys[i];\n\n    if (axisAttrRegex && axisAttrRegex.test(key)) {\n      // modifications to cartesian axes\n      var ax = layout[key];\n\n      if (ax.anchor && ax.anchor !== 'free') {\n        ax.anchor = cleanId(ax.anchor);\n      }\n\n      if (ax.overlaying) ax.overlaying = cleanId(ax.overlaying); // old method of axis type - isdate and islog (before category existed)\n\n      if (!ax.type) {\n        if (ax.isdate) ax.type = 'date';else if (ax.islog) ax.type = 'log';else if (ax.isdate === false && ax.islog === false) ax.type = 'linear';\n      }\n\n      if (ax.autorange === 'withzero' || ax.autorange === 'tozero') {\n        ax.autorange = true;\n        ax.rangemode = 'tozero';\n      }\n\n      delete ax.islog;\n      delete ax.isdate;\n      delete ax.categories; // replaced by _categories\n      // prune empty domain arrays made before the new nestedProperty\n\n      if (emptyContainer(ax, 'domain')) delete ax.domain; // autotick -> tickmode\n\n      if (ax.autotick !== undefined) {\n        if (ax.tickmode === undefined) {\n          ax.tickmode = ax.autotick ? 'auto' : 'linear';\n        }\n\n        delete ax.autotick;\n      }\n\n      cleanTitle(ax);\n    } else if (polarAttrRegex && polarAttrRegex.test(key)) {\n      // modifications for polar\n      var polar = layout[key];\n      cleanTitle(polar.radialaxis);\n    } else if (ternaryAttrRegex && ternaryAttrRegex.test(key)) {\n      // modifications for ternary\n      var ternary = layout[key];\n      cleanTitle(ternary.aaxis);\n      cleanTitle(ternary.baxis);\n      cleanTitle(ternary.caxis);\n    } else if (sceneAttrRegex && sceneAttrRegex.test(key)) {\n      // modifications for 3D scenes\n      var scene = layout[key]; // clean old Camera coords\n\n      var cameraposition = scene.cameraposition;\n\n      if (Array.isArray(cameraposition) && cameraposition[0].length === 4) {\n        var rotation = cameraposition[0];\n        var center = cameraposition[1];\n        var radius = cameraposition[2];\n        var mat = m4FromQuat([], rotation);\n        var eye = [];\n\n        for (j = 0; j < 3; ++j) {\n          eye[j] = center[j] + radius * mat[2 + 4 * j];\n        }\n\n        scene.camera = {\n          eye: {\n            x: eye[0],\n            y: eye[1],\n            z: eye[2]\n          },\n          center: {\n            x: center[0],\n            y: center[1],\n            z: center[2]\n          },\n          up: {\n            x: 0,\n            y: 0,\n            z: 1\n          } // we just ignore calculating camera z up in this case\n\n        };\n        delete scene.cameraposition;\n      } // clean axis titles\n\n\n      cleanTitle(scene.xaxis);\n      cleanTitle(scene.yaxis);\n      cleanTitle(scene.zaxis);\n    }\n  }\n\n  var annotationsLen = Array.isArray(layout.annotations) ? layout.annotations.length : 0;\n\n  for (i = 0; i < annotationsLen; i++) {\n    var ann = layout.annotations[i];\n    if (!Lib.isPlainObject(ann)) continue;\n\n    if (ann.ref) {\n      if (ann.ref === 'paper') {\n        ann.xref = 'paper';\n        ann.yref = 'paper';\n      } else if (ann.ref === 'data') {\n        ann.xref = 'x';\n        ann.yref = 'y';\n      }\n\n      delete ann.ref;\n    }\n\n    cleanAxRef(ann, 'xref');\n    cleanAxRef(ann, 'yref');\n  }\n\n  var shapesLen = Array.isArray(layout.shapes) ? layout.shapes.length : 0;\n\n  for (i = 0; i < shapesLen; i++) {\n    var shape = layout.shapes[i];\n    if (!Lib.isPlainObject(shape)) continue;\n    cleanAxRef(shape, 'xref');\n    cleanAxRef(shape, 'yref');\n  }\n\n  var imagesLen = Array.isArray(layout.images) ? layout.images.length : 0;\n\n  for (i = 0; i < imagesLen; i++) {\n    var image = layout.images[i];\n    if (!Lib.isPlainObject(image)) continue;\n    cleanAxRef(image, 'xref');\n    cleanAxRef(image, 'yref');\n  }\n\n  var legend = layout.legend;\n\n  if (legend) {\n    // check for old-style legend positioning (x or y is +/- 100)\n    if (legend.x > 3) {\n      legend.x = 1.02;\n      legend.xanchor = 'left';\n    } else if (legend.x < -2) {\n      legend.x = -0.02;\n      legend.xanchor = 'right';\n    }\n\n    if (legend.y > 3) {\n      legend.y = 1.02;\n      legend.yanchor = 'bottom';\n    } else if (legend.y < -2) {\n      legend.y = -0.02;\n      legend.yanchor = 'top';\n    }\n  } // clean plot title\n\n\n  cleanTitle(layout);\n  /*\r\n   * Moved from rotate -> orbit for dragmode\r\n   */\n\n  if (layout.dragmode === 'rotate') layout.dragmode = 'orbit'; // sanitize rgb(fractions) and rgba(fractions) that old tinycolor\n  // supported, but new tinycolor does not because they're not valid css\n\n  Color.clean(layout); // clean the layout container in layout.template\n\n  if (layout.template && layout.template.layout) {\n    exports.cleanLayout(layout.template.layout);\n  }\n\n  return layout;\n};\n\nfunction cleanAxRef(container, attr) {\n  var valIn = container[attr];\n  var axLetter = attr.charAt(0);\n\n  if (valIn && valIn !== 'paper') {\n    container[attr] = cleanId(valIn, axLetter, true);\n  }\n}\n/**\r\n * Cleans up old title attribute structure (flat) in favor of the new one (nested).\r\n *\r\n * @param {Object} titleContainer - an object potentially including deprecated title attributes\r\n */\n\n\nfunction cleanTitle(titleContainer) {\n  if (titleContainer) {\n    // title -> title.text\n    // (although title used to be a string attribute,\n    // numbers are accepted as well)\n    if (typeof titleContainer.title === 'string' || typeof titleContainer.title === 'number') {\n      titleContainer.title = {\n        text: titleContainer.title\n      };\n    }\n\n    rewireAttr('titlefont', 'font');\n    rewireAttr('titleposition', 'position');\n    rewireAttr('titleside', 'side');\n    rewireAttr('titleoffset', 'offset');\n  }\n\n  function rewireAttr(oldAttrName, newAttrName) {\n    var oldAttrSet = titleContainer[oldAttrName];\n    var newAttrSet = titleContainer.title && titleContainer.title[newAttrName];\n\n    if (oldAttrSet && !newAttrSet) {\n      // Ensure title object exists\n      if (!titleContainer.title) {\n        titleContainer.title = {};\n      }\n\n      titleContainer.title[newAttrName] = titleContainer[oldAttrName];\n      delete titleContainer[oldAttrName];\n    }\n  }\n}\n/*\r\n * cleanData: Make a few changes to the data for backward compatibility\r\n * before it gets used for anything. Modifies the data traces users provide.\r\n *\r\n * Important: if you're going to add something here that modifies a data array,\r\n * update it in place so the new array === the old one.\r\n */\n\n\nexports.cleanData = function (data) {\n  for (var tracei = 0; tracei < data.length; tracei++) {\n    var trace = data[tracei];\n    var i; // use xbins to bin data in x, and ybins to bin data in y\n\n    if (trace.type === 'histogramy' && 'xbins' in trace && !('ybins' in trace)) {\n      trace.ybins = trace.xbins;\n      delete trace.xbins;\n    } // error_y.opacity is obsolete - merge into color\n\n\n    if (trace.error_y && 'opacity' in trace.error_y) {\n      var dc = Color.defaults;\n      var yeColor = trace.error_y.color || (traceIs(trace, 'bar') ? Color.defaultLine : dc[tracei % dc.length]);\n      trace.error_y.color = Color.addOpacity(Color.rgb(yeColor), Color.opacity(yeColor) * trace.error_y.opacity);\n      delete trace.error_y.opacity;\n    } // convert bardir to orientation, and put the data into\n    // the axes it's eventually going to be used with\n\n\n    if ('bardir' in trace) {\n      if (trace.bardir === 'h' && (traceIs(trace, 'bar') || trace.type.substr(0, 9) === 'histogram')) {\n        trace.orientation = 'h';\n        exports.swapXYData(trace);\n      }\n\n      delete trace.bardir;\n    } // now we have only one 1D histogram type, and whether\n    // it uses x or y data depends on trace.orientation\n\n\n    if (trace.type === 'histogramy') exports.swapXYData(trace);\n\n    if (trace.type === 'histogramx' || trace.type === 'histogramy') {\n      trace.type = 'histogram';\n    } // scl->scale, reversescl->reversescale\n\n\n    if ('scl' in trace && !('colorscale' in trace)) {\n      trace.colorscale = trace.scl;\n      delete trace.scl;\n    }\n\n    if ('reversescl' in trace && !('reversescale' in trace)) {\n      trace.reversescale = trace.reversescl;\n      delete trace.reversescl;\n    } // axis ids x1 -> x, y1-> y\n\n\n    if (trace.xaxis) trace.xaxis = cleanId(trace.xaxis, 'x');\n    if (trace.yaxis) trace.yaxis = cleanId(trace.yaxis, 'y'); // scene ids scene1 -> scene\n\n    if (traceIs(trace, 'gl3d') && trace.scene) {\n      trace.scene = Plots.subplotsRegistry.gl3d.cleanId(trace.scene);\n    }\n\n    if (!traceIs(trace, 'pie-like') && !traceIs(trace, 'bar-like')) {\n      if (Array.isArray(trace.textposition)) {\n        for (i = 0; i < trace.textposition.length; i++) {\n          trace.textposition[i] = cleanTextPosition(trace.textposition[i]);\n        }\n      } else if (trace.textposition) {\n        trace.textposition = cleanTextPosition(trace.textposition);\n      }\n    } // fix typo in colorscale definition\n\n\n    var _module = Registry.getModule(trace);\n\n    if (_module && _module.colorbar) {\n      var containerName = _module.colorbar.container;\n      var container = containerName ? trace[containerName] : trace;\n\n      if (container && container.colorscale) {\n        if (container.colorscale === 'YIGnBu') container.colorscale = 'YlGnBu';\n        if (container.colorscale === 'YIOrRd') container.colorscale = 'YlOrRd';\n      }\n    } // fix typo in surface 'highlight*' definitions\n\n\n    if (trace.type === 'surface' && Lib.isPlainObject(trace.contours)) {\n      var dims = ['x', 'y', 'z'];\n\n      for (i = 0; i < dims.length; i++) {\n        var opts = trace.contours[dims[i]];\n        if (!Lib.isPlainObject(opts)) continue;\n\n        if (opts.highlightColor) {\n          opts.highlightcolor = opts.highlightColor;\n          delete opts.highlightColor;\n        }\n\n        if (opts.highlightWidth) {\n          opts.highlightwidth = opts.highlightWidth;\n          delete opts.highlightWidth;\n        }\n      }\n    } // fixes from converting finance from transforms to real trace types\n\n\n    if (trace.type === 'candlestick' || trace.type === 'ohlc') {\n      var increasingShowlegend = (trace.increasing || {}).showlegend !== false;\n      var decreasingShowlegend = (trace.decreasing || {}).showlegend !== false;\n      var increasingName = cleanFinanceDir(trace.increasing);\n      var decreasingName = cleanFinanceDir(trace.decreasing); // now figure out something smart to do with the separate direction\n      // names we removed\n\n      if (increasingName !== false && decreasingName !== false) {\n        // both sub-names existed: base name previously had no effect\n        // so ignore it and try to find a shared part of the sub-names\n        var newName = commonPrefix(increasingName, decreasingName, increasingShowlegend, decreasingShowlegend); // if no common part, leave whatever name was (or wasn't) there\n\n        if (newName) trace.name = newName;\n      } else if ((increasingName || decreasingName) && !trace.name) {\n        // one sub-name existed but not the base name - just use the sub-name\n        trace.name = increasingName || decreasingName;\n      }\n    } // transforms backward compatibility fixes\n\n\n    if (Array.isArray(trace.transforms)) {\n      var transforms = trace.transforms;\n\n      for (i = 0; i < transforms.length; i++) {\n        var transform = transforms[i];\n        if (!Lib.isPlainObject(transform)) continue;\n\n        switch (transform.type) {\n          case 'filter':\n            if (transform.filtersrc) {\n              transform.target = transform.filtersrc;\n              delete transform.filtersrc;\n            }\n\n            if (transform.calendar) {\n              if (!transform.valuecalendar) {\n                transform.valuecalendar = transform.calendar;\n              }\n\n              delete transform.calendar;\n            }\n\n            break;\n\n          case 'groupby':\n            // Name has changed from `style` to `styles`, so use `style` but prefer `styles`:\n            transform.styles = transform.styles || transform.style;\n\n            if (transform.styles && !Array.isArray(transform.styles)) {\n              var prevStyles = transform.styles;\n              var styleKeys = Object.keys(prevStyles);\n              transform.styles = [];\n\n              for (var j = 0; j < styleKeys.length; j++) {\n                transform.styles.push({\n                  target: styleKeys[j],\n                  value: prevStyles[styleKeys[j]]\n                });\n              }\n            }\n\n            break;\n        }\n      }\n    } // prune empty containers made before the new nestedProperty\n\n\n    if (emptyContainer(trace, 'line')) delete trace.line;\n\n    if ('marker' in trace) {\n      if (emptyContainer(trace.marker, 'line')) delete trace.marker.line;\n      if (emptyContainer(trace, 'marker')) delete trace.marker;\n    } // sanitize rgb(fractions) and rgba(fractions) that old tinycolor\n    // supported, but new tinycolor does not because they're not valid css\n\n\n    Color.clean(trace); // remove obsolete autobin(x|y) attributes, but only if true\n    // if false, this needs to happen in Histogram.calc because it\n    // can be a one-time autobin so we need to know the results before\n    // we can push them back into the trace.\n\n    if (trace.autobinx) {\n      delete trace.autobinx;\n      delete trace.xbins;\n    }\n\n    if (trace.autobiny) {\n      delete trace.autobiny;\n      delete trace.ybins;\n    }\n\n    cleanTitle(trace);\n    if (trace.colorbar) cleanTitle(trace.colorbar);\n    if (trace.marker && trace.marker.colorbar) cleanTitle(trace.marker.colorbar);\n    if (trace.line && trace.line.colorbar) cleanTitle(trace.line.colorbar);\n    if (trace.aaxis) cleanTitle(trace.aaxis);\n    if (trace.baxis) cleanTitle(trace.baxis);\n  }\n};\n\nfunction cleanFinanceDir(dirContainer) {\n  if (!Lib.isPlainObject(dirContainer)) return false;\n  var dirName = dirContainer.name;\n  delete dirContainer.name;\n  delete dirContainer.showlegend;\n  return (typeof dirName === 'string' || typeof dirName === 'number') && String(dirName);\n}\n\nfunction commonPrefix(name1, name2, show1, show2) {\n  // if only one is shown in the legend, use that\n  if (show1 && !show2) return name1;\n  if (show2 && !show1) return name2; // if both or neither are in the legend, check if one is blank (or whitespace)\n  // and use the other one\n  // note that hover labels can still use the name even if the legend doesn't\n\n  if (!name1.trim()) return name2;\n  if (!name2.trim()) return name1;\n  var minLen = Math.min(name1.length, name2.length);\n  var i;\n\n  for (i = 0; i < minLen; i++) {\n    if (name1.charAt(i) !== name2.charAt(i)) break;\n  }\n\n  var out = name1.substr(0, i);\n  return out.trim();\n} // textposition - support partial attributes (ie just 'top')\n// and incorrect use of middle / center etc.\n\n\nfunction cleanTextPosition(textposition) {\n  var posY = 'middle';\n  var posX = 'center';\n\n  if (typeof textposition === 'string') {\n    if (textposition.indexOf('top') !== -1) posY = 'top';else if (textposition.indexOf('bottom') !== -1) posY = 'bottom';\n    if (textposition.indexOf('left') !== -1) posX = 'left';else if (textposition.indexOf('right') !== -1) posX = 'right';\n  }\n\n  return posY + ' ' + posX;\n}\n\nfunction emptyContainer(outer, innerStr) {\n  return innerStr in outer && typeof outer[innerStr] === 'object' && Object.keys(outer[innerStr]).length === 0;\n} // swap all the data and data attributes associated with x and y\n\n\nexports.swapXYData = function (trace) {\n  var i;\n  Lib.swapAttrs(trace, ['?', '?0', 'd?', '?bins', 'nbins?', 'autobin?', '?src', 'error_?']);\n\n  if (Array.isArray(trace.z) && Array.isArray(trace.z[0])) {\n    if (trace.transpose) delete trace.transpose;else trace.transpose = true;\n  }\n\n  if (trace.error_x && trace.error_y) {\n    var errorY = trace.error_y;\n    var copyYstyle = 'copy_ystyle' in errorY ? errorY.copy_ystyle : !(errorY.color || errorY.thickness || errorY.width);\n    Lib.swapAttrs(trace, ['error_?.copy_ystyle']);\n\n    if (copyYstyle) {\n      Lib.swapAttrs(trace, ['error_?.color', 'error_?.thickness', 'error_?.width']);\n    }\n  }\n\n  if (typeof trace.hoverinfo === 'string') {\n    var hoverInfoParts = trace.hoverinfo.split('+');\n\n    for (i = 0; i < hoverInfoParts.length; i++) {\n      if (hoverInfoParts[i] === 'x') hoverInfoParts[i] = 'y';else if (hoverInfoParts[i] === 'y') hoverInfoParts[i] = 'x';\n    }\n\n    trace.hoverinfo = hoverInfoParts.join('+');\n  }\n}; // coerce traceIndices input to array of trace indices\n\n\nexports.coerceTraceIndices = function (gd, traceIndices) {\n  if (isNumeric(traceIndices)) {\n    return [traceIndices];\n  } else if (!Array.isArray(traceIndices) || !traceIndices.length) {\n    return gd.data.map(function (_, i) {\n      return i;\n    });\n  } else if (Array.isArray(traceIndices)) {\n    var traceIndicesOut = [];\n\n    for (var i = 0; i < traceIndices.length; i++) {\n      if (Lib.isIndex(traceIndices[i], gd.data.length)) {\n        traceIndicesOut.push(traceIndices[i]);\n      } else {\n        Lib.warn('trace index (', traceIndices[i], ') is not a number or is out of bounds');\n      }\n    }\n\n    return traceIndicesOut;\n  }\n\n  return traceIndices;\n};\n/**\r\n * Manages logic around array container item creation / deletion / update\r\n * that nested property alone can't handle.\r\n *\r\n * @param {Object} np\r\n *  nested property of update attribute string about trace or layout object\r\n * @param {*} newVal\r\n *  update value passed to restyle / relayout / update\r\n * @param {Object} undoit\r\n *  undo hash (N.B. undoit may be mutated here).\r\n *\r\n */\n\n\nexports.manageArrayContainers = function (np, newVal, undoit) {\n  var obj = np.obj;\n  var parts = np.parts;\n  var pLength = parts.length;\n  var pLast = parts[pLength - 1];\n  var pLastIsNumber = isNumeric(pLast);\n\n  if (pLastIsNumber && newVal === null) {\n    // delete item\n    // Clear item in array container when new value is null\n    var contPath = parts.slice(0, pLength - 1).join('.');\n    var cont = Lib.nestedProperty(obj, contPath).get();\n    cont.splice(pLast, 1); // Note that nested property clears null / undefined at end of\n    // array container, but not within them.\n  } else if (pLastIsNumber && np.get() === undefined) {\n    // create item\n    // When adding a new item, make sure undo command will remove it\n    if (np.get() === undefined) undoit[np.astr] = null;\n    np.set(newVal);\n  } else {\n    // update item\n    // If the last part of attribute string isn't a number,\n    // np.set is all we need.\n    np.set(newVal);\n  }\n};\n/*\r\n * Match the part to strip off to turn an attribute into its parent\r\n * really it should be either '.some_characters' or '[number]'\r\n * but we're a little more permissive here and match either\r\n * '.not_brackets_or_dot' or '[not_brackets_or_dot]'\r\n */\n\n\nvar ATTR_TAIL_RE = /(\\.[^\\[\\]\\.]+|\\[[^\\[\\]\\.]+\\])$/;\n\nfunction getParent(attr) {\n  var tail = attr.search(ATTR_TAIL_RE);\n  if (tail > 0) return attr.substr(0, tail);\n}\n/*\r\n * hasParent: does an attribute object contain a parent of the given attribute?\r\n * for example, given 'images[2].x' do we also have 'images' or 'images[2]'?\r\n *\r\n * @param {Object} aobj\r\n *  update object, whose keys are attribute strings and values are their new settings\r\n * @param {string} attr\r\n *  the attribute string to test against\r\n * @returns {Boolean}\r\n *  is a parent of attr present in aobj?\r\n */\n\n\nexports.hasParent = function (aobj, attr) {\n  var attrParent = getParent(attr);\n\n  while (attrParent) {\n    if (attrParent in aobj) return true;\n    attrParent = getParent(attrParent);\n  }\n\n  return false;\n};\n/**\r\n * Empty out types for all axes containing these traces so we auto-set them again\r\n *\r\n * @param {object} gd\r\n * @param {[integer]} traces: trace indices to search for axes to clear the types of\r\n * @param {object} layoutUpdate: any update being done concurrently to the layout,\r\n *   which may supercede clearing the axis types\r\n */\n\n\nvar axLetters = ['x', 'y', 'z'];\n\nexports.clearAxisTypes = function (gd, traces, layoutUpdate) {\n  for (var i = 0; i < traces.length; i++) {\n    var trace = gd._fullData[i];\n\n    for (var j = 0; j < 3; j++) {\n      var ax = getFromTrace(gd, trace, axLetters[j]); // do not clear log type - that's never an auto result so must have been intentional\n\n      if (ax && ax.type !== 'log') {\n        var axAttr = ax._name;\n\n        var sceneName = ax._id.substr(1);\n\n        if (sceneName.substr(0, 5) === 'scene') {\n          if (layoutUpdate[sceneName] !== undefined) continue;\n          axAttr = sceneName + '.' + axAttr;\n        }\n\n        var typeAttr = axAttr + '.type';\n\n        if (layoutUpdate[axAttr] === undefined && layoutUpdate[typeAttr] === undefined) {\n          Lib.nestedProperty(gd.layout, typeAttr).set(null);\n        }\n      }\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/plot_api/helpers.js"],"names":["isNumeric","require","m4FromQuat","Registry","Lib","Plots","AxisIds","Color","cleanId","getFromTrace","traceIs","exports","clearPromiseQueue","gd","Array","isArray","_promises","length","log","cleanLayout","layout","i","j","xaxis1","xaxis","yaxis1","yaxis","scene1","scene","axisAttrRegex","subplotsRegistry","cartesian","attrRegex","polarAttrRegex","polar","ternaryAttrRegex","ternary","sceneAttrRegex","gl3d","keys","Object","key","test","ax","anchor","overlaying","type","isdate","islog","autorange","rangemode","categories","emptyContainer","domain","autotick","undefined","tickmode","cleanTitle","radialaxis","aaxis","baxis","caxis","cameraposition","rotation","center","radius","mat","eye","camera","x","y","z","up","zaxis","annotationsLen","annotations","ann","isPlainObject","ref","xref","yref","cleanAxRef","shapesLen","shapes","shape","imagesLen","images","image","legend","xanchor","yanchor","dragmode","clean","template","container","attr","valIn","axLetter","charAt","titleContainer","title","text","rewireAttr","oldAttrName","newAttrName","oldAttrSet","newAttrSet","cleanData","data","tracei","trace","ybins","xbins","error_y","dc","defaults","yeColor","color","defaultLine","addOpacity","rgb","opacity","bardir","substr","orientation","swapXYData","colorscale","scl","reversescale","reversescl","textposition","cleanTextPosition","_module","getModule","colorbar","containerName","contours","dims","opts","highlightColor","highlightcolor","highlightWidth","highlightwidth","increasingShowlegend","increasing","showlegend","decreasingShowlegend","decreasing","increasingName","cleanFinanceDir","decreasingName","newName","commonPrefix","name","transforms","transform","filtersrc","target","calendar","valuecalendar","styles","style","prevStyles","styleKeys","push","value","line","marker","autobinx","autobiny","dirContainer","dirName","String","name1","name2","show1","show2","trim","minLen","Math","min","out","posY","posX","indexOf","outer","innerStr","swapAttrs","transpose","error_x","errorY","copyYstyle","copy_ystyle","thickness","width","hoverinfo","hoverInfoParts","split","join","coerceTraceIndices","traceIndices","map","_","traceIndicesOut","isIndex","warn","manageArrayContainers","np","newVal","undoit","obj","parts","pLength","pLast","pLastIsNumber","contPath","slice","cont","nestedProperty","get","splice","astr","set","ATTR_TAIL_RE","getParent","tail","search","hasParent","aobj","attrParent","axLetters","clearAxisTypes","traces","layoutUpdate","_fullData","axAttr","_name","sceneName","_id","typeAttr"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar isNumeric = require('fast-isnumeric');\r\nvar m4FromQuat = require('gl-mat4/fromQuat');\r\n\r\nvar Registry = require('../registry');\r\nvar Lib = require('../lib');\r\nvar Plots = require('../plots/plots');\r\nvar AxisIds = require('../plots/cartesian/axis_ids');\r\nvar Color = require('../components/color');\r\n\r\nvar cleanId = AxisIds.cleanId;\r\nvar getFromTrace = AxisIds.getFromTrace;\r\nvar traceIs = Registry.traceIs;\r\n\r\n// clear the promise queue if one of them got rejected\r\nexports.clearPromiseQueue = function(gd) {\r\n    if(Array.isArray(gd._promises) && gd._promises.length > 0) {\r\n        Lib.log('Clearing previous rejected promises from queue.');\r\n    }\r\n\r\n    gd._promises = [];\r\n};\r\n\r\n// make a few changes to the layout right away\r\n// before it gets used for anything\r\n// backward compatibility and cleanup of nonstandard options\r\nexports.cleanLayout = function(layout) {\r\n    var i, j;\r\n\r\n    if(!layout) layout = {};\r\n\r\n    // cannot have (x|y)axis1, numbering goes axis, axis2, axis3...\r\n    if(layout.xaxis1) {\r\n        if(!layout.xaxis) layout.xaxis = layout.xaxis1;\r\n        delete layout.xaxis1;\r\n    }\r\n    if(layout.yaxis1) {\r\n        if(!layout.yaxis) layout.yaxis = layout.yaxis1;\r\n        delete layout.yaxis1;\r\n    }\r\n    if(layout.scene1) {\r\n        if(!layout.scene) layout.scene = layout.scene1;\r\n        delete layout.scene1;\r\n    }\r\n\r\n    var axisAttrRegex = (Plots.subplotsRegistry.cartesian || {}).attrRegex;\r\n    var polarAttrRegex = (Plots.subplotsRegistry.polar || {}).attrRegex;\r\n    var ternaryAttrRegex = (Plots.subplotsRegistry.ternary || {}).attrRegex;\r\n    var sceneAttrRegex = (Plots.subplotsRegistry.gl3d || {}).attrRegex;\r\n\r\n    var keys = Object.keys(layout);\r\n    for(i = 0; i < keys.length; i++) {\r\n        var key = keys[i];\r\n\r\n        if(axisAttrRegex && axisAttrRegex.test(key)) {\r\n            // modifications to cartesian axes\r\n\r\n            var ax = layout[key];\r\n            if(ax.anchor && ax.anchor !== 'free') {\r\n                ax.anchor = cleanId(ax.anchor);\r\n            }\r\n            if(ax.overlaying) ax.overlaying = cleanId(ax.overlaying);\r\n\r\n            // old method of axis type - isdate and islog (before category existed)\r\n            if(!ax.type) {\r\n                if(ax.isdate) ax.type = 'date';\r\n                else if(ax.islog) ax.type = 'log';\r\n                else if(ax.isdate === false && ax.islog === false) ax.type = 'linear';\r\n            }\r\n            if(ax.autorange === 'withzero' || ax.autorange === 'tozero') {\r\n                ax.autorange = true;\r\n                ax.rangemode = 'tozero';\r\n            }\r\n            delete ax.islog;\r\n            delete ax.isdate;\r\n            delete ax.categories; // replaced by _categories\r\n\r\n            // prune empty domain arrays made before the new nestedProperty\r\n            if(emptyContainer(ax, 'domain')) delete ax.domain;\r\n\r\n            // autotick -> tickmode\r\n            if(ax.autotick !== undefined) {\r\n                if(ax.tickmode === undefined) {\r\n                    ax.tickmode = ax.autotick ? 'auto' : 'linear';\r\n                }\r\n                delete ax.autotick;\r\n            }\r\n\r\n            cleanTitle(ax);\r\n        } else if(polarAttrRegex && polarAttrRegex.test(key)) {\r\n            // modifications for polar\r\n\r\n            var polar = layout[key];\r\n            cleanTitle(polar.radialaxis);\r\n        } else if(ternaryAttrRegex && ternaryAttrRegex.test(key)) {\r\n            // modifications for ternary\r\n\r\n            var ternary = layout[key];\r\n            cleanTitle(ternary.aaxis);\r\n            cleanTitle(ternary.baxis);\r\n            cleanTitle(ternary.caxis);\r\n        } else if(sceneAttrRegex && sceneAttrRegex.test(key)) {\r\n            // modifications for 3D scenes\r\n\r\n            var scene = layout[key];\r\n\r\n            // clean old Camera coords\r\n            var cameraposition = scene.cameraposition;\r\n\r\n            if(Array.isArray(cameraposition) && cameraposition[0].length === 4) {\r\n                var rotation = cameraposition[0];\r\n                var center = cameraposition[1];\r\n                var radius = cameraposition[2];\r\n                var mat = m4FromQuat([], rotation);\r\n                var eye = [];\r\n\r\n                for(j = 0; j < 3; ++j) {\r\n                    eye[j] = center[j] + radius * mat[2 + 4 * j];\r\n                }\r\n\r\n                scene.camera = {\r\n                    eye: {x: eye[0], y: eye[1], z: eye[2]},\r\n                    center: {x: center[0], y: center[1], z: center[2]},\r\n                    up: {x: 0, y: 0, z: 1} // we just ignore calculating camera z up in this case\r\n                };\r\n\r\n                delete scene.cameraposition;\r\n            }\r\n\r\n            // clean axis titles\r\n            cleanTitle(scene.xaxis);\r\n            cleanTitle(scene.yaxis);\r\n            cleanTitle(scene.zaxis);\r\n        }\r\n    }\r\n\r\n    var annotationsLen = Array.isArray(layout.annotations) ? layout.annotations.length : 0;\r\n    for(i = 0; i < annotationsLen; i++) {\r\n        var ann = layout.annotations[i];\r\n\r\n        if(!Lib.isPlainObject(ann)) continue;\r\n\r\n        if(ann.ref) {\r\n            if(ann.ref === 'paper') {\r\n                ann.xref = 'paper';\r\n                ann.yref = 'paper';\r\n            } else if(ann.ref === 'data') {\r\n                ann.xref = 'x';\r\n                ann.yref = 'y';\r\n            }\r\n            delete ann.ref;\r\n        }\r\n\r\n        cleanAxRef(ann, 'xref');\r\n        cleanAxRef(ann, 'yref');\r\n    }\r\n\r\n    var shapesLen = Array.isArray(layout.shapes) ? layout.shapes.length : 0;\r\n    for(i = 0; i < shapesLen; i++) {\r\n        var shape = layout.shapes[i];\r\n\r\n        if(!Lib.isPlainObject(shape)) continue;\r\n\r\n        cleanAxRef(shape, 'xref');\r\n        cleanAxRef(shape, 'yref');\r\n    }\r\n\r\n    var imagesLen = Array.isArray(layout.images) ? layout.images.length : 0;\r\n    for(i = 0; i < imagesLen; i++) {\r\n        var image = layout.images[i];\r\n\r\n        if(!Lib.isPlainObject(image)) continue;\r\n\r\n        cleanAxRef(image, 'xref');\r\n        cleanAxRef(image, 'yref');\r\n    }\r\n\r\n    var legend = layout.legend;\r\n    if(legend) {\r\n        // check for old-style legend positioning (x or y is +/- 100)\r\n        if(legend.x > 3) {\r\n            legend.x = 1.02;\r\n            legend.xanchor = 'left';\r\n        } else if(legend.x < -2) {\r\n            legend.x = -0.02;\r\n            legend.xanchor = 'right';\r\n        }\r\n\r\n        if(legend.y > 3) {\r\n            legend.y = 1.02;\r\n            legend.yanchor = 'bottom';\r\n        } else if(legend.y < -2) {\r\n            legend.y = -0.02;\r\n            legend.yanchor = 'top';\r\n        }\r\n    }\r\n\r\n    // clean plot title\r\n    cleanTitle(layout);\r\n\r\n    /*\r\n     * Moved from rotate -> orbit for dragmode\r\n     */\r\n    if(layout.dragmode === 'rotate') layout.dragmode = 'orbit';\r\n\r\n    // sanitize rgb(fractions) and rgba(fractions) that old tinycolor\r\n    // supported, but new tinycolor does not because they're not valid css\r\n    Color.clean(layout);\r\n\r\n    // clean the layout container in layout.template\r\n    if(layout.template && layout.template.layout) {\r\n        exports.cleanLayout(layout.template.layout);\r\n    }\r\n\r\n    return layout;\r\n};\r\n\r\nfunction cleanAxRef(container, attr) {\r\n    var valIn = container[attr];\r\n    var axLetter = attr.charAt(0);\r\n    if(valIn && valIn !== 'paper') {\r\n        container[attr] = cleanId(valIn, axLetter, true);\r\n    }\r\n}\r\n\r\n/**\r\n * Cleans up old title attribute structure (flat) in favor of the new one (nested).\r\n *\r\n * @param {Object} titleContainer - an object potentially including deprecated title attributes\r\n */\r\nfunction cleanTitle(titleContainer) {\r\n    if(titleContainer) {\r\n        // title -> title.text\r\n        // (although title used to be a string attribute,\r\n        // numbers are accepted as well)\r\n        if(typeof titleContainer.title === 'string' || typeof titleContainer.title === 'number') {\r\n            titleContainer.title = {\r\n                text: titleContainer.title\r\n            };\r\n        }\r\n\r\n        rewireAttr('titlefont', 'font');\r\n        rewireAttr('titleposition', 'position');\r\n        rewireAttr('titleside', 'side');\r\n        rewireAttr('titleoffset', 'offset');\r\n    }\r\n\r\n    function rewireAttr(oldAttrName, newAttrName) {\r\n        var oldAttrSet = titleContainer[oldAttrName];\r\n        var newAttrSet = titleContainer.title && titleContainer.title[newAttrName];\r\n\r\n        if(oldAttrSet && !newAttrSet) {\r\n            // Ensure title object exists\r\n            if(!titleContainer.title) {\r\n                titleContainer.title = {};\r\n            }\r\n\r\n            titleContainer.title[newAttrName] = titleContainer[oldAttrName];\r\n            delete titleContainer[oldAttrName];\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\n * cleanData: Make a few changes to the data for backward compatibility\r\n * before it gets used for anything. Modifies the data traces users provide.\r\n *\r\n * Important: if you're going to add something here that modifies a data array,\r\n * update it in place so the new array === the old one.\r\n */\r\nexports.cleanData = function(data) {\r\n    for(var tracei = 0; tracei < data.length; tracei++) {\r\n        var trace = data[tracei];\r\n        var i;\r\n\r\n        // use xbins to bin data in x, and ybins to bin data in y\r\n        if(trace.type === 'histogramy' && 'xbins' in trace && !('ybins' in trace)) {\r\n            trace.ybins = trace.xbins;\r\n            delete trace.xbins;\r\n        }\r\n\r\n        // error_y.opacity is obsolete - merge into color\r\n        if(trace.error_y && 'opacity' in trace.error_y) {\r\n            var dc = Color.defaults;\r\n            var yeColor = trace.error_y.color || (traceIs(trace, 'bar') ?\r\n                Color.defaultLine :\r\n                dc[tracei % dc.length]);\r\n            trace.error_y.color = Color.addOpacity(\r\n                Color.rgb(yeColor),\r\n                Color.opacity(yeColor) * trace.error_y.opacity);\r\n            delete trace.error_y.opacity;\r\n        }\r\n\r\n        // convert bardir to orientation, and put the data into\r\n        // the axes it's eventually going to be used with\r\n        if('bardir' in trace) {\r\n            if(trace.bardir === 'h' && (traceIs(trace, 'bar') ||\r\n                trace.type.substr(0, 9) === 'histogram')) {\r\n                trace.orientation = 'h';\r\n                exports.swapXYData(trace);\r\n            }\r\n            delete trace.bardir;\r\n        }\r\n\r\n        // now we have only one 1D histogram type, and whether\r\n        // it uses x or y data depends on trace.orientation\r\n        if(trace.type === 'histogramy') exports.swapXYData(trace);\r\n        if(trace.type === 'histogramx' || trace.type === 'histogramy') {\r\n            trace.type = 'histogram';\r\n        }\r\n\r\n        // scl->scale, reversescl->reversescale\r\n        if('scl' in trace && !('colorscale' in trace)) {\r\n            trace.colorscale = trace.scl;\r\n            delete trace.scl;\r\n        }\r\n        if('reversescl' in trace && !('reversescale' in trace)) {\r\n            trace.reversescale = trace.reversescl;\r\n            delete trace.reversescl;\r\n        }\r\n\r\n        // axis ids x1 -> x, y1-> y\r\n        if(trace.xaxis) trace.xaxis = cleanId(trace.xaxis, 'x');\r\n        if(trace.yaxis) trace.yaxis = cleanId(trace.yaxis, 'y');\r\n\r\n        // scene ids scene1 -> scene\r\n        if(traceIs(trace, 'gl3d') && trace.scene) {\r\n            trace.scene = Plots.subplotsRegistry.gl3d.cleanId(trace.scene);\r\n        }\r\n\r\n        if(!traceIs(trace, 'pie-like') && !traceIs(trace, 'bar-like')) {\r\n            if(Array.isArray(trace.textposition)) {\r\n                for(i = 0; i < trace.textposition.length; i++) {\r\n                    trace.textposition[i] = cleanTextPosition(trace.textposition[i]);\r\n                }\r\n            } else if(trace.textposition) {\r\n                trace.textposition = cleanTextPosition(trace.textposition);\r\n            }\r\n        }\r\n\r\n        // fix typo in colorscale definition\r\n        var _module = Registry.getModule(trace);\r\n        if(_module && _module.colorbar) {\r\n            var containerName = _module.colorbar.container;\r\n            var container = containerName ? trace[containerName] : trace;\r\n            if(container && container.colorscale) {\r\n                if(container.colorscale === 'YIGnBu') container.colorscale = 'YlGnBu';\r\n                if(container.colorscale === 'YIOrRd') container.colorscale = 'YlOrRd';\r\n            }\r\n        }\r\n\r\n        // fix typo in surface 'highlight*' definitions\r\n        if(trace.type === 'surface' && Lib.isPlainObject(trace.contours)) {\r\n            var dims = ['x', 'y', 'z'];\r\n\r\n            for(i = 0; i < dims.length; i++) {\r\n                var opts = trace.contours[dims[i]];\r\n\r\n                if(!Lib.isPlainObject(opts)) continue;\r\n\r\n                if(opts.highlightColor) {\r\n                    opts.highlightcolor = opts.highlightColor;\r\n                    delete opts.highlightColor;\r\n                }\r\n\r\n                if(opts.highlightWidth) {\r\n                    opts.highlightwidth = opts.highlightWidth;\r\n                    delete opts.highlightWidth;\r\n                }\r\n            }\r\n        }\r\n\r\n        // fixes from converting finance from transforms to real trace types\r\n        if(trace.type === 'candlestick' || trace.type === 'ohlc') {\r\n            var increasingShowlegend = (trace.increasing || {}).showlegend !== false;\r\n            var decreasingShowlegend = (trace.decreasing || {}).showlegend !== false;\r\n            var increasingName = cleanFinanceDir(trace.increasing);\r\n            var decreasingName = cleanFinanceDir(trace.decreasing);\r\n\r\n            // now figure out something smart to do with the separate direction\r\n            // names we removed\r\n            if((increasingName !== false) && (decreasingName !== false)) {\r\n                // both sub-names existed: base name previously had no effect\r\n                // so ignore it and try to find a shared part of the sub-names\r\n\r\n                var newName = commonPrefix(\r\n                    increasingName, decreasingName,\r\n                    increasingShowlegend, decreasingShowlegend\r\n                );\r\n                // if no common part, leave whatever name was (or wasn't) there\r\n                if(newName) trace.name = newName;\r\n            } else if((increasingName || decreasingName) && !trace.name) {\r\n                // one sub-name existed but not the base name - just use the sub-name\r\n                trace.name = increasingName || decreasingName;\r\n            }\r\n        }\r\n\r\n        // transforms backward compatibility fixes\r\n        if(Array.isArray(trace.transforms)) {\r\n            var transforms = trace.transforms;\r\n\r\n            for(i = 0; i < transforms.length; i++) {\r\n                var transform = transforms[i];\r\n\r\n                if(!Lib.isPlainObject(transform)) continue;\r\n\r\n                switch(transform.type) {\r\n                    case 'filter':\r\n                        if(transform.filtersrc) {\r\n                            transform.target = transform.filtersrc;\r\n                            delete transform.filtersrc;\r\n                        }\r\n\r\n                        if(transform.calendar) {\r\n                            if(!transform.valuecalendar) {\r\n                                transform.valuecalendar = transform.calendar;\r\n                            }\r\n                            delete transform.calendar;\r\n                        }\r\n                        break;\r\n\r\n                    case 'groupby':\r\n                        // Name has changed from `style` to `styles`, so use `style` but prefer `styles`:\r\n                        transform.styles = transform.styles || transform.style;\r\n\r\n                        if(transform.styles && !Array.isArray(transform.styles)) {\r\n                            var prevStyles = transform.styles;\r\n                            var styleKeys = Object.keys(prevStyles);\r\n\r\n                            transform.styles = [];\r\n                            for(var j = 0; j < styleKeys.length; j++) {\r\n                                transform.styles.push({\r\n                                    target: styleKeys[j],\r\n                                    value: prevStyles[styleKeys[j]]\r\n                                });\r\n                            }\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // prune empty containers made before the new nestedProperty\r\n        if(emptyContainer(trace, 'line')) delete trace.line;\r\n        if('marker' in trace) {\r\n            if(emptyContainer(trace.marker, 'line')) delete trace.marker.line;\r\n            if(emptyContainer(trace, 'marker')) delete trace.marker;\r\n        }\r\n\r\n        // sanitize rgb(fractions) and rgba(fractions) that old tinycolor\r\n        // supported, but new tinycolor does not because they're not valid css\r\n        Color.clean(trace);\r\n\r\n        // remove obsolete autobin(x|y) attributes, but only if true\r\n        // if false, this needs to happen in Histogram.calc because it\r\n        // can be a one-time autobin so we need to know the results before\r\n        // we can push them back into the trace.\r\n        if(trace.autobinx) {\r\n            delete trace.autobinx;\r\n            delete trace.xbins;\r\n        }\r\n        if(trace.autobiny) {\r\n            delete trace.autobiny;\r\n            delete trace.ybins;\r\n        }\r\n\r\n        cleanTitle(trace);\r\n        if(trace.colorbar) cleanTitle(trace.colorbar);\r\n        if(trace.marker && trace.marker.colorbar) cleanTitle(trace.marker.colorbar);\r\n        if(trace.line && trace.line.colorbar) cleanTitle(trace.line.colorbar);\r\n        if(trace.aaxis) cleanTitle(trace.aaxis);\r\n        if(trace.baxis) cleanTitle(trace.baxis);\r\n    }\r\n};\r\n\r\nfunction cleanFinanceDir(dirContainer) {\r\n    if(!Lib.isPlainObject(dirContainer)) return false;\r\n\r\n    var dirName = dirContainer.name;\r\n\r\n    delete dirContainer.name;\r\n    delete dirContainer.showlegend;\r\n\r\n    return (typeof dirName === 'string' || typeof dirName === 'number') && String(dirName);\r\n}\r\n\r\nfunction commonPrefix(name1, name2, show1, show2) {\r\n    // if only one is shown in the legend, use that\r\n    if(show1 && !show2) return name1;\r\n    if(show2 && !show1) return name2;\r\n\r\n    // if both or neither are in the legend, check if one is blank (or whitespace)\r\n    // and use the other one\r\n    // note that hover labels can still use the name even if the legend doesn't\r\n    if(!name1.trim()) return name2;\r\n    if(!name2.trim()) return name1;\r\n\r\n    var minLen = Math.min(name1.length, name2.length);\r\n    var i;\r\n    for(i = 0; i < minLen; i++) {\r\n        if(name1.charAt(i) !== name2.charAt(i)) break;\r\n    }\r\n\r\n    var out = name1.substr(0, i);\r\n    return out.trim();\r\n}\r\n\r\n// textposition - support partial attributes (ie just 'top')\r\n// and incorrect use of middle / center etc.\r\nfunction cleanTextPosition(textposition) {\r\n    var posY = 'middle';\r\n    var posX = 'center';\r\n\r\n    if(typeof textposition === 'string') {\r\n        if(textposition.indexOf('top') !== -1) posY = 'top';\r\n        else if(textposition.indexOf('bottom') !== -1) posY = 'bottom';\r\n\r\n        if(textposition.indexOf('left') !== -1) posX = 'left';\r\n        else if(textposition.indexOf('right') !== -1) posX = 'right';\r\n    }\r\n\r\n    return posY + ' ' + posX;\r\n}\r\n\r\nfunction emptyContainer(outer, innerStr) {\r\n    return (innerStr in outer) &&\r\n        (typeof outer[innerStr] === 'object') &&\r\n        (Object.keys(outer[innerStr]).length === 0);\r\n}\r\n\r\n\r\n// swap all the data and data attributes associated with x and y\r\nexports.swapXYData = function(trace) {\r\n    var i;\r\n    Lib.swapAttrs(trace, ['?', '?0', 'd?', '?bins', 'nbins?', 'autobin?', '?src', 'error_?']);\r\n    if(Array.isArray(trace.z) && Array.isArray(trace.z[0])) {\r\n        if(trace.transpose) delete trace.transpose;\r\n        else trace.transpose = true;\r\n    }\r\n    if(trace.error_x && trace.error_y) {\r\n        var errorY = trace.error_y;\r\n        var copyYstyle = ('copy_ystyle' in errorY) ?\r\n            errorY.copy_ystyle :\r\n            !(errorY.color || errorY.thickness || errorY.width);\r\n        Lib.swapAttrs(trace, ['error_?.copy_ystyle']);\r\n        if(copyYstyle) {\r\n            Lib.swapAttrs(trace, ['error_?.color', 'error_?.thickness', 'error_?.width']);\r\n        }\r\n    }\r\n    if(typeof trace.hoverinfo === 'string') {\r\n        var hoverInfoParts = trace.hoverinfo.split('+');\r\n        for(i = 0; i < hoverInfoParts.length; i++) {\r\n            if(hoverInfoParts[i] === 'x') hoverInfoParts[i] = 'y';\r\n            else if(hoverInfoParts[i] === 'y') hoverInfoParts[i] = 'x';\r\n        }\r\n        trace.hoverinfo = hoverInfoParts.join('+');\r\n    }\r\n};\r\n\r\n// coerce traceIndices input to array of trace indices\r\nexports.coerceTraceIndices = function(gd, traceIndices) {\r\n    if(isNumeric(traceIndices)) {\r\n        return [traceIndices];\r\n    } else if(!Array.isArray(traceIndices) || !traceIndices.length) {\r\n        return gd.data.map(function(_, i) { return i; });\r\n    } else if(Array.isArray(traceIndices)) {\r\n        var traceIndicesOut = [];\r\n        for(var i = 0; i < traceIndices.length; i++) {\r\n            if(Lib.isIndex(traceIndices[i], gd.data.length)) {\r\n                traceIndicesOut.push(traceIndices[i]);\r\n            } else {\r\n                Lib.warn('trace index (', traceIndices[i], ') is not a number or is out of bounds');\r\n            }\r\n        }\r\n        return traceIndicesOut;\r\n    }\r\n\r\n    return traceIndices;\r\n};\r\n\r\n/**\r\n * Manages logic around array container item creation / deletion / update\r\n * that nested property alone can't handle.\r\n *\r\n * @param {Object} np\r\n *  nested property of update attribute string about trace or layout object\r\n * @param {*} newVal\r\n *  update value passed to restyle / relayout / update\r\n * @param {Object} undoit\r\n *  undo hash (N.B. undoit may be mutated here).\r\n *\r\n */\r\nexports.manageArrayContainers = function(np, newVal, undoit) {\r\n    var obj = np.obj;\r\n    var parts = np.parts;\r\n    var pLength = parts.length;\r\n    var pLast = parts[pLength - 1];\r\n\r\n    var pLastIsNumber = isNumeric(pLast);\r\n\r\n    if(pLastIsNumber && newVal === null) {\r\n        // delete item\r\n\r\n        // Clear item in array container when new value is null\r\n        var contPath = parts.slice(0, pLength - 1).join('.');\r\n        var cont = Lib.nestedProperty(obj, contPath).get();\r\n        cont.splice(pLast, 1);\r\n\r\n        // Note that nested property clears null / undefined at end of\r\n        // array container, but not within them.\r\n    } else if(pLastIsNumber && np.get() === undefined) {\r\n        // create item\r\n\r\n        // When adding a new item, make sure undo command will remove it\r\n        if(np.get() === undefined) undoit[np.astr] = null;\r\n\r\n        np.set(newVal);\r\n    } else {\r\n        // update item\r\n\r\n        // If the last part of attribute string isn't a number,\r\n        // np.set is all we need.\r\n        np.set(newVal);\r\n    }\r\n};\r\n\r\n/*\r\n * Match the part to strip off to turn an attribute into its parent\r\n * really it should be either '.some_characters' or '[number]'\r\n * but we're a little more permissive here and match either\r\n * '.not_brackets_or_dot' or '[not_brackets_or_dot]'\r\n */\r\nvar ATTR_TAIL_RE = /(\\.[^\\[\\]\\.]+|\\[[^\\[\\]\\.]+\\])$/;\r\n\r\nfunction getParent(attr) {\r\n    var tail = attr.search(ATTR_TAIL_RE);\r\n    if(tail > 0) return attr.substr(0, tail);\r\n}\r\n\r\n/*\r\n * hasParent: does an attribute object contain a parent of the given attribute?\r\n * for example, given 'images[2].x' do we also have 'images' or 'images[2]'?\r\n *\r\n * @param {Object} aobj\r\n *  update object, whose keys are attribute strings and values are their new settings\r\n * @param {string} attr\r\n *  the attribute string to test against\r\n * @returns {Boolean}\r\n *  is a parent of attr present in aobj?\r\n */\r\nexports.hasParent = function(aobj, attr) {\r\n    var attrParent = getParent(attr);\r\n    while(attrParent) {\r\n        if(attrParent in aobj) return true;\r\n        attrParent = getParent(attrParent);\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * Empty out types for all axes containing these traces so we auto-set them again\r\n *\r\n * @param {object} gd\r\n * @param {[integer]} traces: trace indices to search for axes to clear the types of\r\n * @param {object} layoutUpdate: any update being done concurrently to the layout,\r\n *   which may supercede clearing the axis types\r\n */\r\nvar axLetters = ['x', 'y', 'z'];\r\nexports.clearAxisTypes = function(gd, traces, layoutUpdate) {\r\n    for(var i = 0; i < traces.length; i++) {\r\n        var trace = gd._fullData[i];\r\n        for(var j = 0; j < 3; j++) {\r\n            var ax = getFromTrace(gd, trace, axLetters[j]);\r\n\r\n            // do not clear log type - that's never an auto result so must have been intentional\r\n            if(ax && ax.type !== 'log') {\r\n                var axAttr = ax._name;\r\n                var sceneName = ax._id.substr(1);\r\n                if(sceneName.substr(0, 5) === 'scene') {\r\n                    if(layoutUpdate[sceneName] !== undefined) continue;\r\n                    axAttr = sceneName + '.' + axAttr;\r\n                }\r\n                var typeAttr = axAttr + '.type';\r\n\r\n                if(layoutUpdate[axAttr] === undefined && layoutUpdate[typeAttr] === undefined) {\r\n                    Lib.nestedProperty(gd.layout, typeAttr).set(null);\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar Lib = require('../lib');\n\nvar isPlainObject = Lib.isPlainObject;\n\nvar PlotSchema = require('./plot_schema');\n\nvar Plots = require('../plots/plots');\n\nvar plotAttributes = require('../plots/attributes');\n\nvar Template = require('./plot_template');\n\nvar dfltConfig = require('./plot_config').dfltConfig;\n/**\r\n * Plotly.makeTemplate: create a template off an existing figure to reuse\r\n * style attributes on other figures.\r\n *\r\n * Note: separated from the rest of templates because otherwise we get circular\r\n * references due to PlotSchema.\r\n *\r\n * @param {object|DOM element|string} figure: The figure to base the template on\r\n *     should contain a trace array `figure.data`\r\n *     and a layout object `figure.layout`\r\n * @returns {object} template: the extracted template - can then be used as\r\n *     `layout.template` in another figure.\r\n */\n\n\nexports.makeTemplate = function (figure) {\n  figure = Lib.isPlainObject(figure) ? figure : Lib.getGraphDiv(figure);\n  figure = Lib.extendDeep({\n    _context: dfltConfig\n  }, {\n    data: figure.data,\n    layout: figure.layout\n  });\n  Plots.supplyDefaults(figure);\n  var data = figure.data || [];\n  var layout = figure.layout || {}; // copy over a few items to help follow the schema\n\n  layout._basePlotModules = figure._fullLayout._basePlotModules;\n  layout._modules = figure._fullLayout._modules;\n  var template = {\n    data: {},\n    layout: {}\n  };\n  /*\r\n   * Note: we do NOT validate template values, we just take what's in the\r\n   * user inputs data and layout, not the validated values in fullData and\r\n   * fullLayout. Even if we were to validate here, there's no guarantee that\r\n   * these values would still be valid when applied to a new figure, which\r\n   * may contain different trace modes, different axes, etc. So it's\r\n   * important that when applying a template we still validate the template\r\n   * values, rather than just using them as defaults.\r\n   */\n\n  data.forEach(function (trace) {\n    // TODO: What if no style info is extracted for this trace. We may\n    // not want an empty object as the null value.\n    // TODO: allow transforms to contribute to templates?\n    // as it stands they are ignored, which may be for the best...\n    var traceTemplate = {};\n    walkStyleKeys(trace, traceTemplate, getTraceInfo.bind(null, trace));\n    var traceType = Lib.coerce(trace, {}, plotAttributes, 'type');\n    var typeTemplates = template.data[traceType];\n    if (!typeTemplates) typeTemplates = template.data[traceType] = [];\n    typeTemplates.push(traceTemplate);\n  });\n  walkStyleKeys(layout, template.layout, getLayoutInfo.bind(null, layout));\n  /*\r\n   * Compose the new template with an existing one to the same effect\r\n   *\r\n   * NOTE: there's a possibility of slightly different behavior: if the plot\r\n   * has an invalid value and the old template has a valid value for the same\r\n   * attribute, the plot will use the old template value but this routine\r\n   * will pull the invalid value (resulting in the original default).\r\n   * In the general case it's not possible to solve this with a single value,\r\n   * since valid options can be context-dependent. It could be solved with\r\n   * a *list* of values, but that would be huge complexity for little gain.\r\n   */\n\n  delete template.layout.template;\n  var oldTemplate = layout.template;\n\n  if (isPlainObject(oldTemplate)) {\n    var oldLayoutTemplate = oldTemplate.layout;\n    var i, traceType, oldTypeTemplates, oldTypeLen, typeTemplates, typeLen;\n\n    if (isPlainObject(oldLayoutTemplate)) {\n      mergeTemplates(oldLayoutTemplate, template.layout);\n    }\n\n    var oldDataTemplate = oldTemplate.data;\n\n    if (isPlainObject(oldDataTemplate)) {\n      for (traceType in template.data) {\n        oldTypeTemplates = oldDataTemplate[traceType];\n\n        if (Array.isArray(oldTypeTemplates)) {\n          typeTemplates = template.data[traceType];\n          typeLen = typeTemplates.length;\n          oldTypeLen = oldTypeTemplates.length;\n\n          for (i = 0; i < typeLen; i++) {\n            mergeTemplates(oldTypeTemplates[i % oldTypeLen], typeTemplates[i]);\n          }\n\n          for (i = typeLen; i < oldTypeLen; i++) {\n            typeTemplates.push(Lib.extendDeep({}, oldTypeTemplates[i]));\n          }\n        }\n      }\n\n      for (traceType in oldDataTemplate) {\n        if (!(traceType in template.data)) {\n          template.data[traceType] = Lib.extendDeep([], oldDataTemplate[traceType]);\n        }\n      }\n    }\n  }\n\n  return template;\n};\n\nfunction mergeTemplates(oldTemplate, newTemplate) {\n  // we don't care about speed here, just make sure we have a totally\n  // distinct object from the previous template\n  oldTemplate = Lib.extendDeep({}, oldTemplate); // sort keys so we always get annotationdefaults before annotations etc\n  // so arrayTemplater will work right\n\n  var oldKeys = Object.keys(oldTemplate).sort();\n  var i, j;\n\n  function mergeOne(oldVal, newVal, key) {\n    if (isPlainObject(newVal) && isPlainObject(oldVal)) {\n      mergeTemplates(oldVal, newVal);\n    } else if (Array.isArray(newVal) && Array.isArray(oldVal)) {\n      // Note: omitted `inclusionAttr` from arrayTemplater here,\n      // it's irrelevant as we only want the resulting `_template`.\n      var templater = Template.arrayTemplater({\n        _template: oldTemplate\n      }, key);\n\n      for (j = 0; j < newVal.length; j++) {\n        var item = newVal[j];\n\n        var oldItem = templater.newItem(item)._template;\n\n        if (oldItem) mergeTemplates(oldItem, item);\n      }\n\n      var defaultItems = templater.defaultItems();\n\n      for (j = 0; j < defaultItems.length; j++) newVal.push(defaultItems[j]._template); // templateitemname only applies to receiving plots\n\n\n      for (j = 0; j < newVal.length; j++) delete newVal[j].templateitemname;\n    }\n  }\n\n  for (i = 0; i < oldKeys.length; i++) {\n    var key = oldKeys[i];\n    var oldVal = oldTemplate[key];\n\n    if (key in newTemplate) {\n      mergeOne(oldVal, newTemplate[key], key);\n    } else newTemplate[key] = oldVal; // if this is a base key from the old template (eg xaxis), look for\n    // extended keys (eg xaxis2) in the new template to merge into\n\n\n    if (getBaseKey(key) === key) {\n      for (var key2 in newTemplate) {\n        var baseKey2 = getBaseKey(key2);\n\n        if (key2 !== baseKey2 && baseKey2 === key && !(key2 in oldTemplate)) {\n          mergeOne(oldVal, newTemplate[key2], key);\n        }\n      }\n    }\n  }\n}\n\nfunction getBaseKey(key) {\n  return key.replace(/[0-9]+$/, '');\n}\n\nfunction walkStyleKeys(parent, templateOut, getAttributeInfo, path, basePath) {\n  var pathAttr = basePath && getAttributeInfo(basePath);\n\n  for (var key in parent) {\n    var child = parent[key];\n    var nextPath = getNextPath(parent, key, path);\n    var nextBasePath = getNextPath(parent, key, basePath);\n    var attr = getAttributeInfo(nextBasePath);\n\n    if (!attr) {\n      var baseKey = getBaseKey(key);\n\n      if (baseKey !== key) {\n        nextBasePath = getNextPath(parent, baseKey, basePath);\n        attr = getAttributeInfo(nextBasePath);\n      }\n    } // we'll get an attr if path starts with a valid part, then has an\n    // invalid ending. Make sure we got all the way to the end.\n\n\n    if (pathAttr && pathAttr === attr) continue;\n\n    if (!attr || attr._noTemplating || attr.valType === 'data_array' || attr.arrayOk && Array.isArray(child)) {\n      continue;\n    }\n\n    if (!attr.valType && isPlainObject(child)) {\n      walkStyleKeys(child, templateOut, getAttributeInfo, nextPath, nextBasePath);\n    } else if (attr._isLinkedToArray && Array.isArray(child)) {\n      var dfltDone = false;\n      var namedIndex = 0;\n      var usedNames = {};\n\n      for (var i = 0; i < child.length; i++) {\n        var item = child[i];\n\n        if (isPlainObject(item)) {\n          var name = item.name;\n\n          if (name) {\n            if (!usedNames[name]) {\n              // named array items: allow all attributes except data arrays\n              walkStyleKeys(item, templateOut, getAttributeInfo, getNextPath(child, namedIndex, nextPath), getNextPath(child, namedIndex, nextBasePath));\n              namedIndex++;\n              usedNames[name] = 1;\n            }\n          } else if (!dfltDone) {\n            var dfltKey = Template.arrayDefaultKey(key);\n            var dfltPath = getNextPath(parent, dfltKey, path); // getAttributeInfo will fail if we try to use dfltKey directly.\n            // Instead put this item into the next array element, then\n            // pull it out and move it to dfltKey.\n\n            var pathInArray = getNextPath(child, namedIndex, nextPath);\n            walkStyleKeys(item, templateOut, getAttributeInfo, pathInArray, getNextPath(child, namedIndex, nextBasePath));\n            var itemPropInArray = Lib.nestedProperty(templateOut, pathInArray);\n            var dfltProp = Lib.nestedProperty(templateOut, dfltPath);\n            dfltProp.set(itemPropInArray.get());\n            itemPropInArray.set(null);\n            dfltDone = true;\n          }\n        }\n      }\n    } else {\n      var templateProp = Lib.nestedProperty(templateOut, nextPath);\n      templateProp.set(child);\n    }\n  }\n}\n\nfunction getLayoutInfo(layout, path) {\n  return PlotSchema.getLayoutValObject(layout, Lib.nestedProperty({}, path).parts);\n}\n\nfunction getTraceInfo(trace, path) {\n  return PlotSchema.getTraceValObject(trace, Lib.nestedProperty({}, path).parts);\n}\n\nfunction getNextPath(parent, key, path) {\n  var nextPath;\n  if (!path) nextPath = key;else if (Array.isArray(parent)) nextPath = path + '[' + key + ']';else nextPath = path + '.' + key;\n  return nextPath;\n}\n/**\r\n * validateTemplate: Test for consistency between the given figure and\r\n * a template, either already included in the figure or given separately.\r\n * Note that not every issue we identify here is necessarily a problem,\r\n * it depends on what you're using the template for.\r\n *\r\n * @param {object|DOM element} figure: the plot, with {data, layout} members,\r\n *     to test the template against\r\n * @param {Optional(object)} template: the template, with its own {data, layout},\r\n *     to test. If omitted, we will look for a template already attached as the\r\n *     plot's `layout.template` attribute.\r\n *\r\n * @returns {array} array of error objects each containing:\r\n *  - {string} code\r\n *      error code ('missing', 'unused', 'reused', 'noLayout', 'noData')\r\n *  - {string} msg\r\n *      a full readable description of the issue.\r\n */\n\n\nexports.validateTemplate = function (figureIn, template) {\n  var figure = Lib.extendDeep({}, {\n    _context: dfltConfig,\n    data: figureIn.data,\n    layout: figureIn.layout\n  });\n  var layout = figure.layout || {};\n  if (!isPlainObject(template)) template = layout.template || {};\n  var layoutTemplate = template.layout;\n  var dataTemplate = template.data;\n  var errorList = [];\n  figure.layout = layout;\n  figure.layout.template = template;\n  Plots.supplyDefaults(figure);\n  var fullLayout = figure._fullLayout;\n  var fullData = figure._fullData;\n  var layoutPaths = {};\n\n  function crawlLayoutForContainers(obj, paths) {\n    for (var key in obj) {\n      if (key.charAt(0) !== '_' && isPlainObject(obj[key])) {\n        var baseKey = getBaseKey(key);\n        var nextPaths = [];\n        var i;\n\n        for (i = 0; i < paths.length; i++) {\n          nextPaths.push(getNextPath(obj, key, paths[i]));\n          if (baseKey !== key) nextPaths.push(getNextPath(obj, baseKey, paths[i]));\n        }\n\n        for (i = 0; i < nextPaths.length; i++) {\n          layoutPaths[nextPaths[i]] = 1;\n        }\n\n        crawlLayoutForContainers(obj[key], nextPaths);\n      }\n    }\n  }\n\n  function crawlLayoutTemplateForContainers(obj, path) {\n    for (var key in obj) {\n      if (key.indexOf('defaults') === -1 && isPlainObject(obj[key])) {\n        var nextPath = getNextPath(obj, key, path);\n\n        if (layoutPaths[nextPath]) {\n          crawlLayoutTemplateForContainers(obj[key], nextPath);\n        } else {\n          errorList.push({\n            code: 'unused',\n            path: nextPath\n          });\n        }\n      }\n    }\n  }\n\n  if (!isPlainObject(layoutTemplate)) {\n    errorList.push({\n      code: 'layout'\n    });\n  } else {\n    crawlLayoutForContainers(fullLayout, ['layout']);\n    crawlLayoutTemplateForContainers(layoutTemplate, 'layout');\n  }\n\n  if (!isPlainObject(dataTemplate)) {\n    errorList.push({\n      code: 'data'\n    });\n  } else {\n    var typeCount = {};\n    var traceType;\n\n    for (var i = 0; i < fullData.length; i++) {\n      var fullTrace = fullData[i];\n      traceType = fullTrace.type;\n      typeCount[traceType] = (typeCount[traceType] || 0) + 1;\n\n      if (!fullTrace._fullInput._template) {\n        // this takes care of the case of traceType in the data but not\n        // the template\n        errorList.push({\n          code: 'missing',\n          index: fullTrace._fullInput.index,\n          traceType: traceType\n        });\n      }\n    }\n\n    for (traceType in dataTemplate) {\n      var templateCount = dataTemplate[traceType].length;\n      var dataCount = typeCount[traceType] || 0;\n\n      if (templateCount > dataCount) {\n        errorList.push({\n          code: 'unused',\n          traceType: traceType,\n          templateCount: templateCount,\n          dataCount: dataCount\n        });\n      } else if (dataCount > templateCount) {\n        errorList.push({\n          code: 'reused',\n          traceType: traceType,\n          templateCount: templateCount,\n          dataCount: dataCount\n        });\n      }\n    }\n  } // _template: false is when someone tried to modify an array item\n  // but there was no template with matching name\n\n\n  function crawlForMissingTemplates(obj, path) {\n    for (var key in obj) {\n      if (key.charAt(0) === '_') continue;\n      var val = obj[key];\n      var nextPath = getNextPath(obj, key, path);\n\n      if (isPlainObject(val)) {\n        if (Array.isArray(obj) && val._template === false && val.templateitemname) {\n          errorList.push({\n            code: 'missing',\n            path: nextPath,\n            templateitemname: val.templateitemname\n          });\n        }\n\n        crawlForMissingTemplates(val, nextPath);\n      } else if (Array.isArray(val) && hasPlainObject(val)) {\n        crawlForMissingTemplates(val, nextPath);\n      }\n    }\n  }\n\n  crawlForMissingTemplates({\n    data: fullData,\n    layout: fullLayout\n  }, '');\n  if (errorList.length) return errorList.map(format);\n};\n\nfunction hasPlainObject(arr) {\n  for (var i = 0; i < arr.length; i++) {\n    if (isPlainObject(arr[i])) return true;\n  }\n}\n\nfunction format(opts) {\n  var msg;\n\n  switch (opts.code) {\n    case 'data':\n      msg = 'The template has no key data.';\n      break;\n\n    case 'layout':\n      msg = 'The template has no key layout.';\n      break;\n\n    case 'missing':\n      if (opts.path) {\n        msg = 'There are no templates for item ' + opts.path + ' with name ' + opts.templateitemname;\n      } else {\n        msg = 'There are no templates for trace ' + opts.index + ', of type ' + opts.traceType + '.';\n      }\n\n      break;\n\n    case 'unused':\n      if (opts.path) {\n        msg = 'The template item at ' + opts.path + ' was not used in constructing the plot.';\n      } else if (opts.dataCount) {\n        msg = 'Some of the templates of type ' + opts.traceType + ' were not used. The template has ' + opts.templateCount + ' traces, the data only has ' + opts.dataCount + ' of this type.';\n      } else {\n        msg = 'The template has ' + opts.templateCount + ' traces of type ' + opts.traceType + ' but there are none in the data.';\n      }\n\n      break;\n\n    case 'reused':\n      msg = 'Some of the templates of type ' + opts.traceType + ' were used more than once. The template has ' + opts.templateCount + ' traces, the data has ' + opts.dataCount + ' of this type.';\n      break;\n  }\n\n  opts.msg = msg;\n  return opts;\n}","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/plot_api/template_api.js"],"names":["Lib","require","isPlainObject","PlotSchema","Plots","plotAttributes","Template","dfltConfig","exports","makeTemplate","figure","getGraphDiv","extendDeep","_context","data","layout","supplyDefaults","_basePlotModules","_fullLayout","_modules","template","forEach","trace","traceTemplate","walkStyleKeys","getTraceInfo","bind","traceType","coerce","typeTemplates","push","getLayoutInfo","oldTemplate","oldLayoutTemplate","i","oldTypeTemplates","oldTypeLen","typeLen","mergeTemplates","oldDataTemplate","Array","isArray","length","newTemplate","oldKeys","Object","keys","sort","j","mergeOne","oldVal","newVal","key","templater","arrayTemplater","_template","item","oldItem","newItem","defaultItems","templateitemname","getBaseKey","key2","baseKey2","replace","parent","templateOut","getAttributeInfo","path","basePath","pathAttr","child","nextPath","getNextPath","nextBasePath","attr","baseKey","_noTemplating","valType","arrayOk","_isLinkedToArray","dfltDone","namedIndex","usedNames","name","dfltKey","arrayDefaultKey","dfltPath","pathInArray","itemPropInArray","nestedProperty","dfltProp","set","get","templateProp","getLayoutValObject","parts","getTraceValObject","validateTemplate","figureIn","layoutTemplate","dataTemplate","errorList","fullLayout","fullData","_fullData","layoutPaths","crawlLayoutForContainers","obj","paths","charAt","nextPaths","crawlLayoutTemplateForContainers","indexOf","code","typeCount","fullTrace","type","_fullInput","index","templateCount","dataCount","crawlForMissingTemplates","val","hasPlainObject","map","format","arr","opts","msg"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar Lib = require('../lib');\r\nvar isPlainObject = Lib.isPlainObject;\r\nvar PlotSchema = require('./plot_schema');\r\nvar Plots = require('../plots/plots');\r\nvar plotAttributes = require('../plots/attributes');\r\nvar Template = require('./plot_template');\r\nvar dfltConfig = require('./plot_config').dfltConfig;\r\n\r\n/**\r\n * Plotly.makeTemplate: create a template off an existing figure to reuse\r\n * style attributes on other figures.\r\n *\r\n * Note: separated from the rest of templates because otherwise we get circular\r\n * references due to PlotSchema.\r\n *\r\n * @param {object|DOM element|string} figure: The figure to base the template on\r\n *     should contain a trace array `figure.data`\r\n *     and a layout object `figure.layout`\r\n * @returns {object} template: the extracted template - can then be used as\r\n *     `layout.template` in another figure.\r\n */\r\nexports.makeTemplate = function(figure) {\r\n    figure = Lib.isPlainObject(figure) ? figure : Lib.getGraphDiv(figure);\r\n    figure = Lib.extendDeep({_context: dfltConfig}, {data: figure.data, layout: figure.layout});\r\n    Plots.supplyDefaults(figure);\r\n    var data = figure.data || [];\r\n    var layout = figure.layout || {};\r\n    // copy over a few items to help follow the schema\r\n    layout._basePlotModules = figure._fullLayout._basePlotModules;\r\n    layout._modules = figure._fullLayout._modules;\r\n\r\n    var template = {\r\n        data: {},\r\n        layout: {}\r\n    };\r\n\r\n    /*\r\n     * Note: we do NOT validate template values, we just take what's in the\r\n     * user inputs data and layout, not the validated values in fullData and\r\n     * fullLayout. Even if we were to validate here, there's no guarantee that\r\n     * these values would still be valid when applied to a new figure, which\r\n     * may contain different trace modes, different axes, etc. So it's\r\n     * important that when applying a template we still validate the template\r\n     * values, rather than just using them as defaults.\r\n     */\r\n\r\n    data.forEach(function(trace) {\r\n        // TODO: What if no style info is extracted for this trace. We may\r\n        // not want an empty object as the null value.\r\n        // TODO: allow transforms to contribute to templates?\r\n        // as it stands they are ignored, which may be for the best...\r\n\r\n        var traceTemplate = {};\r\n        walkStyleKeys(trace, traceTemplate, getTraceInfo.bind(null, trace));\r\n\r\n        var traceType = Lib.coerce(trace, {}, plotAttributes, 'type');\r\n        var typeTemplates = template.data[traceType];\r\n        if(!typeTemplates) typeTemplates = template.data[traceType] = [];\r\n        typeTemplates.push(traceTemplate);\r\n    });\r\n\r\n    walkStyleKeys(layout, template.layout, getLayoutInfo.bind(null, layout));\r\n\r\n    /*\r\n     * Compose the new template with an existing one to the same effect\r\n     *\r\n     * NOTE: there's a possibility of slightly different behavior: if the plot\r\n     * has an invalid value and the old template has a valid value for the same\r\n     * attribute, the plot will use the old template value but this routine\r\n     * will pull the invalid value (resulting in the original default).\r\n     * In the general case it's not possible to solve this with a single value,\r\n     * since valid options can be context-dependent. It could be solved with\r\n     * a *list* of values, but that would be huge complexity for little gain.\r\n     */\r\n    delete template.layout.template;\r\n    var oldTemplate = layout.template;\r\n    if(isPlainObject(oldTemplate)) {\r\n        var oldLayoutTemplate = oldTemplate.layout;\r\n\r\n        var i, traceType, oldTypeTemplates, oldTypeLen, typeTemplates, typeLen;\r\n\r\n        if(isPlainObject(oldLayoutTemplate)) {\r\n            mergeTemplates(oldLayoutTemplate, template.layout);\r\n        }\r\n        var oldDataTemplate = oldTemplate.data;\r\n        if(isPlainObject(oldDataTemplate)) {\r\n            for(traceType in template.data) {\r\n                oldTypeTemplates = oldDataTemplate[traceType];\r\n                if(Array.isArray(oldTypeTemplates)) {\r\n                    typeTemplates = template.data[traceType];\r\n                    typeLen = typeTemplates.length;\r\n                    oldTypeLen = oldTypeTemplates.length;\r\n                    for(i = 0; i < typeLen; i++) {\r\n                        mergeTemplates(oldTypeTemplates[i % oldTypeLen], typeTemplates[i]);\r\n                    }\r\n                    for(i = typeLen; i < oldTypeLen; i++) {\r\n                        typeTemplates.push(Lib.extendDeep({}, oldTypeTemplates[i]));\r\n                    }\r\n                }\r\n            }\r\n            for(traceType in oldDataTemplate) {\r\n                if(!(traceType in template.data)) {\r\n                    template.data[traceType] = Lib.extendDeep([], oldDataTemplate[traceType]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return template;\r\n};\r\n\r\nfunction mergeTemplates(oldTemplate, newTemplate) {\r\n    // we don't care about speed here, just make sure we have a totally\r\n    // distinct object from the previous template\r\n    oldTemplate = Lib.extendDeep({}, oldTemplate);\r\n\r\n    // sort keys so we always get annotationdefaults before annotations etc\r\n    // so arrayTemplater will work right\r\n    var oldKeys = Object.keys(oldTemplate).sort();\r\n    var i, j;\r\n\r\n    function mergeOne(oldVal, newVal, key) {\r\n        if(isPlainObject(newVal) && isPlainObject(oldVal)) {\r\n            mergeTemplates(oldVal, newVal);\r\n        } else if(Array.isArray(newVal) && Array.isArray(oldVal)) {\r\n            // Note: omitted `inclusionAttr` from arrayTemplater here,\r\n            // it's irrelevant as we only want the resulting `_template`.\r\n            var templater = Template.arrayTemplater({_template: oldTemplate}, key);\r\n            for(j = 0; j < newVal.length; j++) {\r\n                var item = newVal[j];\r\n                var oldItem = templater.newItem(item)._template;\r\n                if(oldItem) mergeTemplates(oldItem, item);\r\n            }\r\n            var defaultItems = templater.defaultItems();\r\n            for(j = 0; j < defaultItems.length; j++) newVal.push(defaultItems[j]._template);\r\n\r\n            // templateitemname only applies to receiving plots\r\n            for(j = 0; j < newVal.length; j++) delete newVal[j].templateitemname;\r\n        }\r\n    }\r\n\r\n    for(i = 0; i < oldKeys.length; i++) {\r\n        var key = oldKeys[i];\r\n        var oldVal = oldTemplate[key];\r\n        if(key in newTemplate) {\r\n            mergeOne(oldVal, newTemplate[key], key);\r\n        } else newTemplate[key] = oldVal;\r\n\r\n        // if this is a base key from the old template (eg xaxis), look for\r\n        // extended keys (eg xaxis2) in the new template to merge into\r\n        if(getBaseKey(key) === key) {\r\n            for(var key2 in newTemplate) {\r\n                var baseKey2 = getBaseKey(key2);\r\n                if(key2 !== baseKey2 && baseKey2 === key && !(key2 in oldTemplate)) {\r\n                    mergeOne(oldVal, newTemplate[key2], key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction getBaseKey(key) {\r\n    return key.replace(/[0-9]+$/, '');\r\n}\r\n\r\nfunction walkStyleKeys(parent, templateOut, getAttributeInfo, path, basePath) {\r\n    var pathAttr = basePath && getAttributeInfo(basePath);\r\n    for(var key in parent) {\r\n        var child = parent[key];\r\n        var nextPath = getNextPath(parent, key, path);\r\n        var nextBasePath = getNextPath(parent, key, basePath);\r\n        var attr = getAttributeInfo(nextBasePath);\r\n        if(!attr) {\r\n            var baseKey = getBaseKey(key);\r\n            if(baseKey !== key) {\r\n                nextBasePath = getNextPath(parent, baseKey, basePath);\r\n                attr = getAttributeInfo(nextBasePath);\r\n            }\r\n        }\r\n\r\n        // we'll get an attr if path starts with a valid part, then has an\r\n        // invalid ending. Make sure we got all the way to the end.\r\n        if(pathAttr && (pathAttr === attr)) continue;\r\n\r\n        if(!attr || attr._noTemplating ||\r\n            attr.valType === 'data_array' ||\r\n            (attr.arrayOk && Array.isArray(child))\r\n        ) {\r\n            continue;\r\n        }\r\n\r\n        if(!attr.valType && isPlainObject(child)) {\r\n            walkStyleKeys(child, templateOut, getAttributeInfo, nextPath, nextBasePath);\r\n        } else if(attr._isLinkedToArray && Array.isArray(child)) {\r\n            var dfltDone = false;\r\n            var namedIndex = 0;\r\n            var usedNames = {};\r\n            for(var i = 0; i < child.length; i++) {\r\n                var item = child[i];\r\n                if(isPlainObject(item)) {\r\n                    var name = item.name;\r\n                    if(name) {\r\n                        if(!usedNames[name]) {\r\n                            // named array items: allow all attributes except data arrays\r\n                            walkStyleKeys(item, templateOut, getAttributeInfo,\r\n                                getNextPath(child, namedIndex, nextPath),\r\n                                getNextPath(child, namedIndex, nextBasePath));\r\n                            namedIndex++;\r\n                            usedNames[name] = 1;\r\n                        }\r\n                    } else if(!dfltDone) {\r\n                        var dfltKey = Template.arrayDefaultKey(key);\r\n                        var dfltPath = getNextPath(parent, dfltKey, path);\r\n\r\n                        // getAttributeInfo will fail if we try to use dfltKey directly.\r\n                        // Instead put this item into the next array element, then\r\n                        // pull it out and move it to dfltKey.\r\n                        var pathInArray = getNextPath(child, namedIndex, nextPath);\r\n                        walkStyleKeys(item, templateOut, getAttributeInfo, pathInArray,\r\n                            getNextPath(child, namedIndex, nextBasePath));\r\n                        var itemPropInArray = Lib.nestedProperty(templateOut, pathInArray);\r\n                        var dfltProp = Lib.nestedProperty(templateOut, dfltPath);\r\n                        dfltProp.set(itemPropInArray.get());\r\n                        itemPropInArray.set(null);\r\n\r\n                        dfltDone = true;\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            var templateProp = Lib.nestedProperty(templateOut, nextPath);\r\n            templateProp.set(child);\r\n        }\r\n    }\r\n}\r\n\r\nfunction getLayoutInfo(layout, path) {\r\n    return PlotSchema.getLayoutValObject(\r\n        layout, Lib.nestedProperty({}, path).parts\r\n    );\r\n}\r\n\r\nfunction getTraceInfo(trace, path) {\r\n    return PlotSchema.getTraceValObject(\r\n        trace, Lib.nestedProperty({}, path).parts\r\n    );\r\n}\r\n\r\nfunction getNextPath(parent, key, path) {\r\n    var nextPath;\r\n    if(!path) nextPath = key;\r\n    else if(Array.isArray(parent)) nextPath = path + '[' + key + ']';\r\n    else nextPath = path + '.' + key;\r\n\r\n    return nextPath;\r\n}\r\n\r\n/**\r\n * validateTemplate: Test for consistency between the given figure and\r\n * a template, either already included in the figure or given separately.\r\n * Note that not every issue we identify here is necessarily a problem,\r\n * it depends on what you're using the template for.\r\n *\r\n * @param {object|DOM element} figure: the plot, with {data, layout} members,\r\n *     to test the template against\r\n * @param {Optional(object)} template: the template, with its own {data, layout},\r\n *     to test. If omitted, we will look for a template already attached as the\r\n *     plot's `layout.template` attribute.\r\n *\r\n * @returns {array} array of error objects each containing:\r\n *  - {string} code\r\n *      error code ('missing', 'unused', 'reused', 'noLayout', 'noData')\r\n *  - {string} msg\r\n *      a full readable description of the issue.\r\n */\r\nexports.validateTemplate = function(figureIn, template) {\r\n    var figure = Lib.extendDeep({}, {\r\n        _context: dfltConfig,\r\n        data: figureIn.data,\r\n        layout: figureIn.layout\r\n    });\r\n    var layout = figure.layout || {};\r\n    if(!isPlainObject(template)) template = layout.template || {};\r\n    var layoutTemplate = template.layout;\r\n    var dataTemplate = template.data;\r\n    var errorList = [];\r\n\r\n    figure.layout = layout;\r\n    figure.layout.template = template;\r\n    Plots.supplyDefaults(figure);\r\n\r\n    var fullLayout = figure._fullLayout;\r\n    var fullData = figure._fullData;\r\n\r\n    var layoutPaths = {};\r\n    function crawlLayoutForContainers(obj, paths) {\r\n        for(var key in obj) {\r\n            if(key.charAt(0) !== '_' && isPlainObject(obj[key])) {\r\n                var baseKey = getBaseKey(key);\r\n                var nextPaths = [];\r\n                var i;\r\n                for(i = 0; i < paths.length; i++) {\r\n                    nextPaths.push(getNextPath(obj, key, paths[i]));\r\n                    if(baseKey !== key) nextPaths.push(getNextPath(obj, baseKey, paths[i]));\r\n                }\r\n                for(i = 0; i < nextPaths.length; i++) {\r\n                    layoutPaths[nextPaths[i]] = 1;\r\n                }\r\n                crawlLayoutForContainers(obj[key], nextPaths);\r\n            }\r\n        }\r\n    }\r\n\r\n    function crawlLayoutTemplateForContainers(obj, path) {\r\n        for(var key in obj) {\r\n            if(key.indexOf('defaults') === -1 && isPlainObject(obj[key])) {\r\n                var nextPath = getNextPath(obj, key, path);\r\n                if(layoutPaths[nextPath]) {\r\n                    crawlLayoutTemplateForContainers(obj[key], nextPath);\r\n                } else {\r\n                    errorList.push({code: 'unused', path: nextPath});\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if(!isPlainObject(layoutTemplate)) {\r\n        errorList.push({code: 'layout'});\r\n    } else {\r\n        crawlLayoutForContainers(fullLayout, ['layout']);\r\n        crawlLayoutTemplateForContainers(layoutTemplate, 'layout');\r\n    }\r\n\r\n    if(!isPlainObject(dataTemplate)) {\r\n        errorList.push({code: 'data'});\r\n    } else {\r\n        var typeCount = {};\r\n        var traceType;\r\n        for(var i = 0; i < fullData.length; i++) {\r\n            var fullTrace = fullData[i];\r\n            traceType = fullTrace.type;\r\n            typeCount[traceType] = (typeCount[traceType] || 0) + 1;\r\n            if(!fullTrace._fullInput._template) {\r\n                // this takes care of the case of traceType in the data but not\r\n                // the template\r\n                errorList.push({\r\n                    code: 'missing',\r\n                    index: fullTrace._fullInput.index,\r\n                    traceType: traceType\r\n                });\r\n            }\r\n        }\r\n        for(traceType in dataTemplate) {\r\n            var templateCount = dataTemplate[traceType].length;\r\n            var dataCount = typeCount[traceType] || 0;\r\n            if(templateCount > dataCount) {\r\n                errorList.push({\r\n                    code: 'unused',\r\n                    traceType: traceType,\r\n                    templateCount: templateCount,\r\n                    dataCount: dataCount\r\n                });\r\n            } else if(dataCount > templateCount) {\r\n                errorList.push({\r\n                    code: 'reused',\r\n                    traceType: traceType,\r\n                    templateCount: templateCount,\r\n                    dataCount: dataCount\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    // _template: false is when someone tried to modify an array item\r\n    // but there was no template with matching name\r\n    function crawlForMissingTemplates(obj, path) {\r\n        for(var key in obj) {\r\n            if(key.charAt(0) === '_') continue;\r\n            var val = obj[key];\r\n            var nextPath = getNextPath(obj, key, path);\r\n            if(isPlainObject(val)) {\r\n                if(Array.isArray(obj) && val._template === false && val.templateitemname) {\r\n                    errorList.push({\r\n                        code: 'missing',\r\n                        path: nextPath,\r\n                        templateitemname: val.templateitemname\r\n                    });\r\n                }\r\n                crawlForMissingTemplates(val, nextPath);\r\n            } else if(Array.isArray(val) && hasPlainObject(val)) {\r\n                crawlForMissingTemplates(val, nextPath);\r\n            }\r\n        }\r\n    }\r\n    crawlForMissingTemplates({data: fullData, layout: fullLayout}, '');\r\n\r\n    if(errorList.length) return errorList.map(format);\r\n};\r\n\r\nfunction hasPlainObject(arr) {\r\n    for(var i = 0; i < arr.length; i++) {\r\n        if(isPlainObject(arr[i])) return true;\r\n    }\r\n}\r\n\r\nfunction format(opts) {\r\n    var msg;\r\n    switch(opts.code) {\r\n        case 'data':\r\n            msg = 'The template has no key data.';\r\n            break;\r\n        case 'layout':\r\n            msg = 'The template has no key layout.';\r\n            break;\r\n        case 'missing':\r\n            if(opts.path) {\r\n                msg = 'There are no templates for item ' + opts.path +\r\n                    ' with name ' + opts.templateitemname;\r\n            } else {\r\n                msg = 'There are no templates for trace ' + opts.index +\r\n                    ', of type ' + opts.traceType + '.';\r\n            }\r\n            break;\r\n        case 'unused':\r\n            if(opts.path) {\r\n                msg = 'The template item at ' + opts.path +\r\n                    ' was not used in constructing the plot.';\r\n            } else if(opts.dataCount) {\r\n                msg = 'Some of the templates of type ' + opts.traceType +\r\n                    ' were not used. The template has ' + opts.templateCount +\r\n                    ' traces, the data only has ' + opts.dataCount +\r\n                    ' of this type.';\r\n            } else {\r\n                msg = 'The template has ' + opts.templateCount +\r\n                    ' traces of type ' + opts.traceType +\r\n                    ' but there are none in the data.';\r\n            }\r\n            break;\r\n        case 'reused':\r\n            msg = 'Some of the templates of type ' + opts.traceType +\r\n                ' were used more than once. The template has ' +\r\n                opts.templateCount + ' traces, the data has ' +\r\n                opts.dataCount + ' of this type.';\r\n            break;\r\n    }\r\n    opts.msg = msg;\r\n\r\n    return opts;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}
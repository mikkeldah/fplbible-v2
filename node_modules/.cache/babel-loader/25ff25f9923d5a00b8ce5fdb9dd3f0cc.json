{"ast":null,"code":"'use strict';\n\nvar Fx = require('../../components/fx');\n\nvar Registry = require('../../registry');\n\nvar Color = require('../../components/color');\n\nvar fillText = require('../../lib').fillText;\n\nvar getLineWidth = require('./helpers').getLineWidth;\n\nvar hoverLabelText = require('../../plots/cartesian/axes').hoverLabelText;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nfunction hoverPoints(pointData, xval, yval, hovermode, opts) {\n  var barPointData = hoverOnBars(pointData, xval, yval, hovermode, opts);\n\n  if (barPointData) {\n    var cd = barPointData.cd;\n    var trace = cd[0].trace;\n    var di = cd[barPointData.index];\n    barPointData.color = getTraceColor(trace, di);\n    Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, barPointData);\n    return [barPointData];\n  }\n}\n\nfunction hoverOnBars(pointData, xval, yval, hovermode, opts) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var t = cd[0].t;\n  var isClosest = hovermode === 'closest';\n  var isWaterfall = trace.type === 'waterfall';\n  var maxHoverDistance = pointData.maxHoverDistance;\n  var maxSpikeDistance = pointData.maxSpikeDistance;\n  var posVal, sizeVal, posLetter, sizeLetter, dx, dy, pRangeCalc;\n\n  if (trace.orientation === 'h') {\n    posVal = yval;\n    sizeVal = xval;\n    posLetter = 'y';\n    sizeLetter = 'x';\n    dx = sizeFn;\n    dy = positionFn;\n  } else {\n    posVal = xval;\n    sizeVal = yval;\n    posLetter = 'x';\n    sizeLetter = 'y';\n    dy = sizeFn;\n    dx = positionFn;\n  }\n\n  var period = trace[posLetter + 'period'];\n\n  function thisBarMinPos(di) {\n    return thisBarExtPos(di, -1);\n  }\n\n  function thisBarMaxPos(di) {\n    return thisBarExtPos(di, 1);\n  }\n\n  function thisBarExtPos(di, sgn) {\n    if (period) {\n      return di.p + sgn * Math.abs(di.p - di.orig_p);\n    }\n\n    return di[posLetter] + sgn * di.w / 2;\n  }\n\n  var minPos = isClosest || period ? thisBarMinPos : function (di) {\n    /*\n     * In compare mode, accept a bar if you're on it *or* its group.\n     * Nearly always it's the group that matters, but in case the bar\n     * was explicitly set wider than its group we'd better accept the\n     * whole bar.\n     *\n     * use `bardelta` instead of `bargroupwidth` so we accept hover\n     * in the gap. That way hover doesn't flash on and off as you\n     * mouse over the plot in compare modes.\n     * In 'closest' mode though the flashing seems inevitable,\n     * without far more complex logic\n     */\n    return Math.min(thisBarMinPos(di), di.p - t.bardelta / 2);\n  };\n  var maxPos = isClosest || period ? thisBarMaxPos : function (di) {\n    return Math.max(thisBarMaxPos(di), di.p + t.bardelta / 2);\n  };\n\n  function inbox(_minPos, _maxPos, maxDistance) {\n    if (opts.finiteRange) maxDistance = 0; // add a little to the pseudo-distance for wider bars, so that like scatter,\n    // if you are over two overlapping bars, the narrower one wins.\n\n    return Fx.inbox(_minPos - posVal, _maxPos - posVal, maxDistance + Math.min(1, Math.abs(_maxPos - _minPos) / pRangeCalc) - 1);\n  }\n\n  function positionFn(di) {\n    return inbox(minPos(di), maxPos(di), maxHoverDistance);\n  }\n\n  function thisBarPositionFn(di) {\n    return inbox(thisBarMinPos(di), thisBarMaxPos(di), maxSpikeDistance);\n  }\n\n  function getSize(di) {\n    var s = di[sizeLetter];\n\n    if (isWaterfall) {\n      var rawS = Math.abs(di.rawS) || 0;\n\n      if (sizeVal > 0) {\n        s += rawS;\n      } else if (sizeVal < 0) {\n        s -= rawS;\n      }\n    }\n\n    return s;\n  }\n\n  function sizeFn(di) {\n    var v = sizeVal;\n    var b = di.b;\n    var s = getSize(di); // add a gradient so hovering near the end of a\n    // bar makes it a little closer match\n\n    return Fx.inbox(b - v, s - v, maxHoverDistance + (s - v) / (s - b) - 1);\n  }\n\n  function thisBarSizeFn(di) {\n    var v = sizeVal;\n    var b = di.b;\n    var s = getSize(di); // add a gradient so hovering near the end of a\n    // bar makes it a little closer match\n\n    return Fx.inbox(b - v, s - v, maxSpikeDistance + (s - v) / (s - b) - 1);\n  }\n\n  var pa = pointData[posLetter + 'a'];\n  var sa = pointData[sizeLetter + 'a'];\n  pRangeCalc = Math.abs(pa.r2c(pa.range[1]) - pa.r2c(pa.range[0]));\n\n  function dxy(di) {\n    return (dx(di) + dy(di)) / 2;\n  }\n\n  var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n  Fx.getClosest(cd, distfn, pointData); // skip the rest (for this trace) if we didn't find a close point\n\n  if (pointData.index === false) return; // skip points inside axis rangebreaks\n\n  if (cd[pointData.index].p === BADNUM) return; // if we get here and we're not in 'closest' mode, push min/max pos back\n  // onto the group - even though that means occasionally the mouse will be\n  // over the hover label.\n\n  if (!isClosest) {\n    minPos = function (di) {\n      return Math.min(thisBarMinPos(di), di.p - t.bargroupwidth / 2);\n    };\n\n    maxPos = function (di) {\n      return Math.max(thisBarMaxPos(di), di.p + t.bargroupwidth / 2);\n    };\n  } // the closest data point\n\n\n  var index = pointData.index;\n  var di = cd[index];\n  var size = trace.base ? di.b + di.s : di.s;\n  pointData[sizeLetter + '0'] = pointData[sizeLetter + '1'] = sa.c2p(di[sizeLetter], true);\n  pointData[sizeLetter + 'LabelVal'] = size;\n  var extent = t.extents[t.extents.round(di.p)];\n  pointData[posLetter + '0'] = pa.c2p(isClosest ? minPos(di) : extent[0], true);\n  pointData[posLetter + '1'] = pa.c2p(isClosest ? maxPos(di) : extent[1], true);\n  var hasPeriod = di.orig_p !== undefined;\n  pointData[posLetter + 'LabelVal'] = hasPeriod ? di.orig_p : di.p;\n  pointData.labelLabel = hoverLabelText(pa, pointData[posLetter + 'LabelVal'], trace[posLetter + 'hoverformat']);\n  pointData.valueLabel = hoverLabelText(sa, pointData[sizeLetter + 'LabelVal'], trace[sizeLetter + 'hoverformat']);\n  pointData.baseLabel = hoverLabelText(sa, di.b, trace[sizeLetter + 'hoverformat']); // spikelines always want \"closest\" distance regardless of hovermode\n\n  pointData.spikeDistance = (thisBarSizeFn(di) + thisBarPositionFn(di)) / 2; // they also want to point to the data value, regardless of where the label goes\n  // in case of bars shifted within groups\n\n  pointData[posLetter + 'Spike'] = pa.c2p(di.p, true);\n  fillText(di, trace, pointData);\n  pointData.hovertemplate = trace.hovertemplate;\n  return pointData;\n}\n\nfunction getTraceColor(trace, di) {\n  var mc = di.mcc || trace.marker.color;\n  var mlc = di.mlcc || trace.marker.line.color;\n  var mlw = getLineWidth(trace, di);\n  if (Color.opacity(mc)) return mc;else if (Color.opacity(mlc) && mlw) return mlc;\n}\n\nmodule.exports = {\n  hoverPoints: hoverPoints,\n  hoverOnBars: hoverOnBars,\n  getTraceColor: getTraceColor\n};","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/traces/bar/hover.js"],"names":["Fx","require","Registry","Color","fillText","getLineWidth","hoverLabelText","BADNUM","hoverPoints","pointData","xval","yval","hovermode","opts","barPointData","hoverOnBars","cd","trace","di","index","color","getTraceColor","getComponentMethod","t","isClosest","isWaterfall","type","maxHoverDistance","maxSpikeDistance","posVal","sizeVal","posLetter","sizeLetter","dx","dy","pRangeCalc","orientation","sizeFn","positionFn","period","thisBarMinPos","thisBarExtPos","thisBarMaxPos","sgn","p","Math","abs","orig_p","w","minPos","min","bardelta","maxPos","max","inbox","_minPos","_maxPos","maxDistance","finiteRange","thisBarPositionFn","getSize","s","rawS","v","b","thisBarSizeFn","pa","sa","r2c","range","dxy","distfn","getDistanceFunction","getClosest","bargroupwidth","size","base","c2p","extent","extents","round","hasPeriod","undefined","labelLabel","valueLabel","baseLabel","spikeDistance","hovertemplate","mc","mcc","marker","mlc","mlcc","line","mlw","opacity","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nvar Fx = require('../../components/fx');\nvar Registry = require('../../registry');\nvar Color = require('../../components/color');\n\nvar fillText = require('../../lib').fillText;\nvar getLineWidth = require('./helpers').getLineWidth;\nvar hoverLabelText = require('../../plots/cartesian/axes').hoverLabelText;\nvar BADNUM = require('../../constants/numerical').BADNUM;\n\nfunction hoverPoints(pointData, xval, yval, hovermode, opts) {\n    var barPointData = hoverOnBars(pointData, xval, yval, hovermode, opts);\n\n    if(barPointData) {\n        var cd = barPointData.cd;\n        var trace = cd[0].trace;\n        var di = cd[barPointData.index];\n\n        barPointData.color = getTraceColor(trace, di);\n        Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, barPointData);\n\n        return [barPointData];\n    }\n}\n\nfunction hoverOnBars(pointData, xval, yval, hovermode, opts) {\n    var cd = pointData.cd;\n    var trace = cd[0].trace;\n    var t = cd[0].t;\n    var isClosest = (hovermode === 'closest');\n    var isWaterfall = (trace.type === 'waterfall');\n    var maxHoverDistance = pointData.maxHoverDistance;\n    var maxSpikeDistance = pointData.maxSpikeDistance;\n\n    var posVal, sizeVal, posLetter, sizeLetter, dx, dy, pRangeCalc;\n\n    if(trace.orientation === 'h') {\n        posVal = yval;\n        sizeVal = xval;\n        posLetter = 'y';\n        sizeLetter = 'x';\n        dx = sizeFn;\n        dy = positionFn;\n    } else {\n        posVal = xval;\n        sizeVal = yval;\n        posLetter = 'x';\n        sizeLetter = 'y';\n        dy = sizeFn;\n        dx = positionFn;\n    }\n\n    var period = trace[posLetter + 'period'];\n\n    function thisBarMinPos(di) { return thisBarExtPos(di, -1); }\n    function thisBarMaxPos(di) { return thisBarExtPos(di, 1); }\n\n    function thisBarExtPos(di, sgn) {\n        if(period) {\n            return di.p + sgn * Math.abs(di.p - di.orig_p);\n        }\n        return di[posLetter] + sgn * di.w / 2;\n    }\n\n    var minPos = isClosest || period ?\n        thisBarMinPos :\n        function(di) {\n            /*\n             * In compare mode, accept a bar if you're on it *or* its group.\n             * Nearly always it's the group that matters, but in case the bar\n             * was explicitly set wider than its group we'd better accept the\n             * whole bar.\n             *\n             * use `bardelta` instead of `bargroupwidth` so we accept hover\n             * in the gap. That way hover doesn't flash on and off as you\n             * mouse over the plot in compare modes.\n             * In 'closest' mode though the flashing seems inevitable,\n             * without far more complex logic\n             */\n            return Math.min(thisBarMinPos(di), di.p - t.bardelta / 2);\n        };\n\n    var maxPos = isClosest || period ?\n        thisBarMaxPos :\n        function(di) {\n            return Math.max(thisBarMaxPos(di), di.p + t.bardelta / 2);\n        };\n\n    function inbox(_minPos, _maxPos, maxDistance) {\n        if(opts.finiteRange) maxDistance = 0;\n\n        // add a little to the pseudo-distance for wider bars, so that like scatter,\n        // if you are over two overlapping bars, the narrower one wins.\n        return Fx.inbox(_minPos - posVal, _maxPos - posVal,\n            maxDistance + Math.min(1, Math.abs(_maxPos - _minPos) / pRangeCalc) - 1);\n    }\n\n    function positionFn(di) {\n        return inbox(minPos(di), maxPos(di), maxHoverDistance);\n    }\n\n    function thisBarPositionFn(di) {\n        return inbox(thisBarMinPos(di), thisBarMaxPos(di), maxSpikeDistance);\n    }\n\n    function getSize(di) {\n        var s = di[sizeLetter];\n\n        if(isWaterfall) {\n            var rawS = Math.abs(di.rawS) || 0;\n            if(sizeVal > 0) {\n                s += rawS;\n            } else if(sizeVal < 0) {\n                s -= rawS;\n            }\n        }\n\n        return s;\n    }\n\n    function sizeFn(di) {\n        var v = sizeVal;\n        var b = di.b;\n        var s = getSize(di);\n\n        // add a gradient so hovering near the end of a\n        // bar makes it a little closer match\n        return Fx.inbox(b - v, s - v, maxHoverDistance + (s - v) / (s - b) - 1);\n    }\n\n    function thisBarSizeFn(di) {\n        var v = sizeVal;\n        var b = di.b;\n        var s = getSize(di);\n\n        // add a gradient so hovering near the end of a\n        // bar makes it a little closer match\n        return Fx.inbox(b - v, s - v, maxSpikeDistance + (s - v) / (s - b) - 1);\n    }\n\n    var pa = pointData[posLetter + 'a'];\n    var sa = pointData[sizeLetter + 'a'];\n\n    pRangeCalc = Math.abs(pa.r2c(pa.range[1]) - pa.r2c(pa.range[0]));\n\n    function dxy(di) { return (dx(di) + dy(di)) / 2; }\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n    Fx.getClosest(cd, distfn, pointData);\n\n    // skip the rest (for this trace) if we didn't find a close point\n    if(pointData.index === false) return;\n\n    // skip points inside axis rangebreaks\n    if(cd[pointData.index].p === BADNUM) return;\n\n    // if we get here and we're not in 'closest' mode, push min/max pos back\n    // onto the group - even though that means occasionally the mouse will be\n    // over the hover label.\n    if(!isClosest) {\n        minPos = function(di) {\n            return Math.min(thisBarMinPos(di), di.p - t.bargroupwidth / 2);\n        };\n        maxPos = function(di) {\n            return Math.max(thisBarMaxPos(di), di.p + t.bargroupwidth / 2);\n        };\n    }\n\n    // the closest data point\n    var index = pointData.index;\n    var di = cd[index];\n\n    var size = (trace.base) ? di.b + di.s : di.s;\n    pointData[sizeLetter + '0'] = pointData[sizeLetter + '1'] = sa.c2p(di[sizeLetter], true);\n    pointData[sizeLetter + 'LabelVal'] = size;\n\n    var extent = t.extents[t.extents.round(di.p)];\n    pointData[posLetter + '0'] = pa.c2p(isClosest ? minPos(di) : extent[0], true);\n    pointData[posLetter + '1'] = pa.c2p(isClosest ? maxPos(di) : extent[1], true);\n\n    var hasPeriod = di.orig_p !== undefined;\n    pointData[posLetter + 'LabelVal'] = hasPeriod ? di.orig_p : di.p;\n\n    pointData.labelLabel = hoverLabelText(pa, pointData[posLetter + 'LabelVal'], trace[posLetter + 'hoverformat']);\n    pointData.valueLabel = hoverLabelText(sa, pointData[sizeLetter + 'LabelVal'], trace[sizeLetter + 'hoverformat']);\n    pointData.baseLabel = hoverLabelText(sa, di.b, trace[sizeLetter + 'hoverformat']);\n\n    // spikelines always want \"closest\" distance regardless of hovermode\n    pointData.spikeDistance = (thisBarSizeFn(di) + thisBarPositionFn(di)) / 2;\n    // they also want to point to the data value, regardless of where the label goes\n    // in case of bars shifted within groups\n    pointData[posLetter + 'Spike'] = pa.c2p(di.p, true);\n\n    fillText(di, trace, pointData);\n    pointData.hovertemplate = trace.hovertemplate;\n\n    return pointData;\n}\n\nfunction getTraceColor(trace, di) {\n    var mc = di.mcc || trace.marker.color;\n    var mlc = di.mlcc || trace.marker.line.color;\n    var mlw = getLineWidth(trace, di);\n\n    if(Color.opacity(mc)) return mc;\n    else if(Color.opacity(mlc) && mlw) return mlc;\n}\n\nmodule.exports = {\n    hoverPoints: hoverPoints,\n    hoverOnBars: hoverOnBars,\n    getTraceColor: getTraceColor\n};\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar numConstants = require('../../constants/numerical');\n\nvar oneYear = numConstants.ONEAVGYEAR;\nvar oneMonth = numConstants.ONEAVGMONTH;\nvar oneDay = numConstants.ONEDAY;\nvar oneHour = numConstants.ONEHOUR;\nvar oneMin = numConstants.ONEMIN;\nvar oneSec = numConstants.ONESEC;\n\nvar tickIncrement = require('../../plots/cartesian/axes').tickIncrement;\n/*\r\n * make a function that will find rounded bin edges\r\n * @param {number} leftGap: how far from the left edge of any bin is the closest data value?\r\n * @param {number} rightGap: how far from the right edge of any bin is the closest data value?\r\n * @param {Array[number]} binEdges: the actual edge values used in binning\r\n * @param {object} pa: the position axis\r\n * @param {string} calendar: the data calendar\r\n *\r\n * @return {function(v, isRightEdge)}:\r\n *   find the start (isRightEdge is falsy) or end (truthy) label value for a bin edge `v`\r\n */\n\n\nmodule.exports = function getBinSpanLabelRound(leftGap, rightGap, binEdges, pa, calendar) {\n  // the rounding digit is the largest digit that changes in *all* of 4 regions:\n  // - inside the rightGap before binEdges[0] (shifted 10% to the left)\n  // - inside the leftGap after binEdges[0] (expanded by 10% of rightGap on each end)\n  // - same for binEdges[1]\n  var dv0 = -1.1 * rightGap;\n  var dv1 = -0.1 * rightGap;\n  var dv2 = leftGap - dv1;\n  var edge0 = binEdges[0];\n  var edge1 = binEdges[1];\n  var leftDigit = Math.min(biggestDigitChanged(edge0 + dv1, edge0 + dv2, pa, calendar), biggestDigitChanged(edge1 + dv1, edge1 + dv2, pa, calendar));\n  var rightDigit = Math.min(biggestDigitChanged(edge0 + dv0, edge0 + dv1, pa, calendar), biggestDigitChanged(edge1 + dv0, edge1 + dv1, pa, calendar)); // normally we try to make the label for the right edge different from\n  // the left edge label, so it's unambiguous which bin gets data on the edge.\n  // but if this results in more than 3 extra digits (or for dates, more than\n  // 2 fields ie hr&min or min&sec, which is 3600x), it'll be more clutter than\n  // useful so keep the label cleaner instead\n\n  var digit, disambiguateEdges;\n\n  if (leftDigit > rightDigit && rightDigit < Math.abs(edge1 - edge0) / 4000) {\n    digit = leftDigit;\n    disambiguateEdges = false;\n  } else {\n    digit = Math.min(leftDigit, rightDigit);\n    disambiguateEdges = true;\n  }\n\n  if (pa.type === 'date' && digit > oneDay) {\n    var dashExclude = digit === oneYear ? 1 : 6;\n    var increment = digit === oneYear ? 'M12' : 'M1';\n    return function (v, isRightEdge) {\n      var dateStr = pa.c2d(v, oneYear, calendar);\n      var dashPos = dateStr.indexOf('-', dashExclude);\n      if (dashPos > 0) dateStr = dateStr.substr(0, dashPos);\n      var roundedV = pa.d2c(dateStr, 0, calendar);\n\n      if (roundedV < v) {\n        var nextV = tickIncrement(roundedV, increment, false, calendar);\n        if ((roundedV + nextV) / 2 < v + leftGap) roundedV = nextV;\n      }\n\n      if (isRightEdge && disambiguateEdges) {\n        return tickIncrement(roundedV, increment, true, calendar);\n      }\n\n      return roundedV;\n    };\n  }\n\n  return function (v, isRightEdge) {\n    var roundedV = digit * Math.round(v / digit); // if we rounded down and we could round up and still be < leftGap\n    // (or what leftGap values round to), do that\n\n    if (roundedV + digit / 10 < v && roundedV + digit * 0.9 < v + leftGap) {\n      roundedV += digit;\n    } // finally for the right edge back off one digit - but only if we can do that\n    // and not clip off any data that's potentially in the bin\n\n\n    if (isRightEdge && disambiguateEdges) {\n      roundedV -= digit;\n    }\n\n    return roundedV;\n  };\n};\n/*\r\n * Find the largest digit that changes within a (calcdata) region [v1, v2]\r\n * if dates, \"digit\" means date/time part when it's bigger than a second\r\n * returns the unit value to round to this digit, eg 0.01 to round to hundredths, or\r\n * 100 to round to hundreds. returns oneMonth or oneYear for month or year rounding,\r\n * so that Math.min will work, rather than 'M1' and 'M12'\r\n */\n\n\nfunction biggestDigitChanged(v1, v2, pa, calendar) {\n  // are we crossing zero? can't say anything.\n  // in principle this doesn't apply to dates but turns out this doesn't matter.\n  if (v1 * v2 <= 0) return Infinity;\n  var dv = Math.abs(v2 - v1);\n  var isDate = pa.type === 'date';\n  var digit = biggestGuaranteedDigitChanged(dv, isDate); // see if a larger digit also changed\n\n  for (var i = 0; i < 10; i++) {\n    // numbers: next digit needs to be >10x but <100x then gets rounded down.\n    // dates: next digit can be as much as 60x (then rounded down)\n    var nextDigit = biggestGuaranteedDigitChanged(digit * 80, isDate); // if we get to years, the chain stops\n\n    if (digit === nextDigit) break;\n    if (didDigitChange(nextDigit, v1, v2, isDate, pa, calendar)) digit = nextDigit;else break;\n  }\n\n  return digit;\n}\n/*\r\n * Find the largest digit that *definitely* changes in a region [v, v + dv] for any v\r\n * for nonuniform date regions (months/years) pick the largest\r\n */\n\n\nfunction biggestGuaranteedDigitChanged(dv, isDate) {\n  if (isDate && dv > oneSec) {\n    // this is supposed to be the biggest *guaranteed* change\n    // so compare to the longest month and year across any calendar,\n    // and we'll iterate back up later\n    // note: does not support rounding larger than one year. We could add\n    // that if anyone wants it, but seems unusual and not strictly necessary.\n    if (dv > oneDay) {\n      if (dv > oneYear * 1.1) return oneYear;\n      if (dv > oneMonth * 1.1) return oneMonth;\n      return oneDay;\n    }\n\n    if (dv > oneHour) return oneHour;\n    if (dv > oneMin) return oneMin;\n    return oneSec;\n  }\n\n  return Math.pow(10, Math.floor(Math.log(dv) / Math.LN10));\n}\n\nfunction didDigitChange(digit, v1, v2, isDate, pa, calendar) {\n  if (isDate && digit > oneDay) {\n    var dateParts1 = dateParts(v1, pa, calendar);\n    var dateParts2 = dateParts(v2, pa, calendar);\n    var parti = digit === oneYear ? 0 : 1;\n    return dateParts1[parti] !== dateParts2[parti];\n  }\n\n  return Math.floor(v2 / digit) - Math.floor(v1 / digit) > 0.1;\n}\n\nfunction dateParts(v, pa, calendar) {\n  var parts = pa.c2d(v, oneYear, calendar).split('-');\n\n  if (parts[0] === '') {\n    parts.unshift();\n    parts[0] = '-' + parts[0];\n  }\n\n  return parts;\n}","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/traces/histogram/bin_label_vals.js"],"names":["numConstants","require","oneYear","ONEAVGYEAR","oneMonth","ONEAVGMONTH","oneDay","ONEDAY","oneHour","ONEHOUR","oneMin","ONEMIN","oneSec","ONESEC","tickIncrement","module","exports","getBinSpanLabelRound","leftGap","rightGap","binEdges","pa","calendar","dv0","dv1","dv2","edge0","edge1","leftDigit","Math","min","biggestDigitChanged","rightDigit","digit","disambiguateEdges","abs","type","dashExclude","increment","v","isRightEdge","dateStr","c2d","dashPos","indexOf","substr","roundedV","d2c","nextV","round","v1","v2","Infinity","dv","isDate","biggestGuaranteedDigitChanged","i","nextDigit","didDigitChange","pow","floor","log","LN10","dateParts1","dateParts","dateParts2","parti","parts","split","unshift"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,2BAAD,CAA1B;;AACA,IAAIC,OAAO,GAAGF,YAAY,CAACG,UAA3B;AACA,IAAIC,QAAQ,GAAGJ,YAAY,CAACK,WAA5B;AACA,IAAIC,MAAM,GAAGN,YAAY,CAACO,MAA1B;AACA,IAAIC,OAAO,GAAGR,YAAY,CAACS,OAA3B;AACA,IAAIC,MAAM,GAAGV,YAAY,CAACW,MAA1B;AACA,IAAIC,MAAM,GAAGZ,YAAY,CAACa,MAA1B;;AACA,IAAIC,aAAa,GAAGb,OAAO,CAAC,4BAAD,CAAP,CAAsCa,aAA1D;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,SAASC,oBAAT,CAA8BC,OAA9B,EAAuCC,QAAvC,EAAiDC,QAAjD,EAA2DC,EAA3D,EAA+DC,QAA/D,EAAyE;AACtF;AACA;AACA;AACA;AACA,MAAIC,GAAG,GAAG,CAAC,GAAD,GAAOJ,QAAjB;AACA,MAAIK,GAAG,GAAG,CAAC,GAAD,GAAOL,QAAjB;AACA,MAAIM,GAAG,GAAGP,OAAO,GAAGM,GAApB;AACA,MAAIE,KAAK,GAAGN,QAAQ,CAAC,CAAD,CAApB;AACA,MAAIO,KAAK,GAAGP,QAAQ,CAAC,CAAD,CAApB;AACA,MAAIQ,SAAS,GAAGC,IAAI,CAACC,GAAL,CACZC,mBAAmB,CAACL,KAAK,GAAGF,GAAT,EAAcE,KAAK,GAAGD,GAAtB,EAA2BJ,EAA3B,EAA+BC,QAA/B,CADP,EAEZS,mBAAmB,CAACJ,KAAK,GAAGH,GAAT,EAAcG,KAAK,GAAGF,GAAtB,EAA2BJ,EAA3B,EAA+BC,QAA/B,CAFP,CAAhB;AAIA,MAAIU,UAAU,GAAGH,IAAI,CAACC,GAAL,CACbC,mBAAmB,CAACL,KAAK,GAAGH,GAAT,EAAcG,KAAK,GAAGF,GAAtB,EAA2BH,EAA3B,EAA+BC,QAA/B,CADN,EAEbS,mBAAmB,CAACJ,KAAK,GAAGJ,GAAT,EAAcI,KAAK,GAAGH,GAAtB,EAA2BH,EAA3B,EAA+BC,QAA/B,CAFN,CAAjB,CAdsF,CAmBtF;AACA;AACA;AACA;AACA;;AACA,MAAIW,KAAJ,EAAWC,iBAAX;;AACA,MAAGN,SAAS,GAAGI,UAAZ,IAA0BA,UAAU,GAAGH,IAAI,CAACM,GAAL,CAASR,KAAK,GAAGD,KAAjB,IAA0B,IAApE,EAA0E;AACtEO,IAAAA,KAAK,GAAGL,SAAR;AACAM,IAAAA,iBAAiB,GAAG,KAApB;AACH,GAHD,MAGO;AACHD,IAAAA,KAAK,GAAGJ,IAAI,CAACC,GAAL,CAASF,SAAT,EAAoBI,UAApB,CAAR;AACAE,IAAAA,iBAAiB,GAAG,IAApB;AACH;;AAED,MAAGb,EAAE,CAACe,IAAH,KAAY,MAAZ,IAAsBH,KAAK,GAAG3B,MAAjC,EAAyC;AACrC,QAAI+B,WAAW,GAAIJ,KAAK,KAAK/B,OAAX,GAAsB,CAAtB,GAA0B,CAA5C;AACA,QAAIoC,SAAS,GAAIL,KAAK,KAAK/B,OAAX,GAAsB,KAAtB,GAA8B,IAA9C;AAEA,WAAO,UAASqC,CAAT,EAAYC,WAAZ,EAAyB;AAC5B,UAAIC,OAAO,GAAGpB,EAAE,CAACqB,GAAH,CAAOH,CAAP,EAAUrC,OAAV,EAAmBoB,QAAnB,CAAd;AACA,UAAIqB,OAAO,GAAGF,OAAO,CAACG,OAAR,CAAgB,GAAhB,EAAqBP,WAArB,CAAd;AACA,UAAGM,OAAO,GAAG,CAAb,EAAgBF,OAAO,GAAGA,OAAO,CAACI,MAAR,CAAe,CAAf,EAAkBF,OAAlB,CAAV;AAChB,UAAIG,QAAQ,GAAGzB,EAAE,CAAC0B,GAAH,CAAON,OAAP,EAAgB,CAAhB,EAAmBnB,QAAnB,CAAf;;AAEA,UAAGwB,QAAQ,GAAGP,CAAd,EAAiB;AACb,YAAIS,KAAK,GAAGlC,aAAa,CAACgC,QAAD,EAAWR,SAAX,EAAsB,KAAtB,EAA6BhB,QAA7B,CAAzB;AACA,YAAG,CAACwB,QAAQ,GAAGE,KAAZ,IAAqB,CAArB,GAAyBT,CAAC,GAAGrB,OAAhC,EAAyC4B,QAAQ,GAAGE,KAAX;AAC5C;;AAED,UAAGR,WAAW,IAAIN,iBAAlB,EAAqC;AACjC,eAAOpB,aAAa,CAACgC,QAAD,EAAWR,SAAX,EAAsB,IAAtB,EAA4BhB,QAA5B,CAApB;AACH;;AAED,aAAOwB,QAAP;AACH,KAhBD;AAiBH;;AAED,SAAO,UAASP,CAAT,EAAYC,WAAZ,EAAyB;AAC5B,QAAIM,QAAQ,GAAGb,KAAK,GAAGJ,IAAI,CAACoB,KAAL,CAAWV,CAAC,GAAGN,KAAf,CAAvB,CAD4B,CAE5B;AACA;;AACA,QAAGa,QAAQ,GAAIb,KAAK,GAAG,EAApB,GAA0BM,CAA1B,IAA+BO,QAAQ,GAAIb,KAAK,GAAG,GAApB,GAA2BM,CAAC,GAAGrB,OAAjE,EAA0E;AACtE4B,MAAAA,QAAQ,IAAIb,KAAZ;AACH,KAN2B,CAO5B;AACA;;;AACA,QAAGO,WAAW,IAAIN,iBAAlB,EAAqC;AACjCY,MAAAA,QAAQ,IAAIb,KAAZ;AACH;;AACD,WAAOa,QAAP;AACH,GAbD;AAcH,CAtED;AAwEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASf,mBAAT,CAA6BmB,EAA7B,EAAiCC,EAAjC,EAAqC9B,EAArC,EAAyCC,QAAzC,EAAmD;AAC/C;AACA;AACA,MAAG4B,EAAE,GAAGC,EAAL,IAAW,CAAd,EAAiB,OAAOC,QAAP;AAEjB,MAAIC,EAAE,GAAGxB,IAAI,CAACM,GAAL,CAASgB,EAAE,GAAGD,EAAd,CAAT;AACA,MAAII,MAAM,GAAGjC,EAAE,CAACe,IAAH,KAAY,MAAzB;AACA,MAAIH,KAAK,GAAGsB,6BAA6B,CAACF,EAAD,EAAKC,MAAL,CAAzC,CAP+C,CAQ/C;;AACA,OAAI,IAAIE,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG,EAAnB,EAAuBA,CAAC,EAAxB,EAA4B;AACxB;AACA;AACA,QAAIC,SAAS,GAAGF,6BAA6B,CAACtB,KAAK,GAAG,EAAT,EAAaqB,MAAb,CAA7C,CAHwB,CAIxB;;AACA,QAAGrB,KAAK,KAAKwB,SAAb,EAAwB;AACxB,QAAGC,cAAc,CAACD,SAAD,EAAYP,EAAZ,EAAgBC,EAAhB,EAAoBG,MAApB,EAA4BjC,EAA5B,EAAgCC,QAAhC,CAAjB,EAA4DW,KAAK,GAAGwB,SAAR,CAA5D,KACK;AACR;;AACD,SAAOxB,KAAP;AACH;AAED;AACA;AACA;AACA;;;AACA,SAASsB,6BAAT,CAAuCF,EAAvC,EAA2CC,MAA3C,EAAmD;AAC/C,MAAGA,MAAM,IAAID,EAAE,GAAGzC,MAAlB,EAA0B;AACtB;AACA;AACA;AACA;AACA;AACA,QAAGyC,EAAE,GAAG/C,MAAR,EAAgB;AACZ,UAAG+C,EAAE,GAAGnD,OAAO,GAAG,GAAlB,EAAuB,OAAOA,OAAP;AACvB,UAAGmD,EAAE,GAAGjD,QAAQ,GAAG,GAAnB,EAAwB,OAAOA,QAAP;AACxB,aAAOE,MAAP;AACH;;AAED,QAAG+C,EAAE,GAAG7C,OAAR,EAAiB,OAAOA,OAAP;AACjB,QAAG6C,EAAE,GAAG3C,MAAR,EAAgB,OAAOA,MAAP;AAChB,WAAOE,MAAP;AACH;;AACD,SAAOiB,IAAI,CAAC8B,GAAL,CAAS,EAAT,EAAa9B,IAAI,CAAC+B,KAAL,CAAW/B,IAAI,CAACgC,GAAL,CAASR,EAAT,IAAexB,IAAI,CAACiC,IAA/B,CAAb,CAAP;AACH;;AAED,SAASJ,cAAT,CAAwBzB,KAAxB,EAA+BiB,EAA/B,EAAmCC,EAAnC,EAAuCG,MAAvC,EAA+CjC,EAA/C,EAAmDC,QAAnD,EAA6D;AACzD,MAAGgC,MAAM,IAAIrB,KAAK,GAAG3B,MAArB,EAA6B;AACzB,QAAIyD,UAAU,GAAGC,SAAS,CAACd,EAAD,EAAK7B,EAAL,EAASC,QAAT,CAA1B;AACA,QAAI2C,UAAU,GAAGD,SAAS,CAACb,EAAD,EAAK9B,EAAL,EAASC,QAAT,CAA1B;AACA,QAAI4C,KAAK,GAAIjC,KAAK,KAAK/B,OAAX,GAAsB,CAAtB,GAA0B,CAAtC;AACA,WAAO6D,UAAU,CAACG,KAAD,CAAV,KAAsBD,UAAU,CAACC,KAAD,CAAvC;AACH;;AACD,SAAOrC,IAAI,CAAC+B,KAAL,CAAWT,EAAE,GAAGlB,KAAhB,IAAyBJ,IAAI,CAAC+B,KAAL,CAAWV,EAAE,GAAGjB,KAAhB,CAAzB,GAAkD,GAAzD;AACH;;AAED,SAAS+B,SAAT,CAAmBzB,CAAnB,EAAsBlB,EAAtB,EAA0BC,QAA1B,EAAoC;AAChC,MAAI6C,KAAK,GAAG9C,EAAE,CAACqB,GAAH,CAAOH,CAAP,EAAUrC,OAAV,EAAmBoB,QAAnB,EAA6B8C,KAA7B,CAAmC,GAAnC,CAAZ;;AACA,MAAGD,KAAK,CAAC,CAAD,CAAL,KAAa,EAAhB,EAAoB;AAChBA,IAAAA,KAAK,CAACE,OAAN;AACAF,IAAAA,KAAK,CAAC,CAAD,CAAL,GAAW,MAAMA,KAAK,CAAC,CAAD,CAAtB;AACH;;AACD,SAAOA,KAAP;AACH","sourcesContent":["'use strict';\r\n\r\nvar numConstants = require('../../constants/numerical');\r\nvar oneYear = numConstants.ONEAVGYEAR;\r\nvar oneMonth = numConstants.ONEAVGMONTH;\r\nvar oneDay = numConstants.ONEDAY;\r\nvar oneHour = numConstants.ONEHOUR;\r\nvar oneMin = numConstants.ONEMIN;\r\nvar oneSec = numConstants.ONESEC;\r\nvar tickIncrement = require('../../plots/cartesian/axes').tickIncrement;\r\n\r\n\r\n/*\r\n * make a function that will find rounded bin edges\r\n * @param {number} leftGap: how far from the left edge of any bin is the closest data value?\r\n * @param {number} rightGap: how far from the right edge of any bin is the closest data value?\r\n * @param {Array[number]} binEdges: the actual edge values used in binning\r\n * @param {object} pa: the position axis\r\n * @param {string} calendar: the data calendar\r\n *\r\n * @return {function(v, isRightEdge)}:\r\n *   find the start (isRightEdge is falsy) or end (truthy) label value for a bin edge `v`\r\n */\r\nmodule.exports = function getBinSpanLabelRound(leftGap, rightGap, binEdges, pa, calendar) {\r\n    // the rounding digit is the largest digit that changes in *all* of 4 regions:\r\n    // - inside the rightGap before binEdges[0] (shifted 10% to the left)\r\n    // - inside the leftGap after binEdges[0] (expanded by 10% of rightGap on each end)\r\n    // - same for binEdges[1]\r\n    var dv0 = -1.1 * rightGap;\r\n    var dv1 = -0.1 * rightGap;\r\n    var dv2 = leftGap - dv1;\r\n    var edge0 = binEdges[0];\r\n    var edge1 = binEdges[1];\r\n    var leftDigit = Math.min(\r\n        biggestDigitChanged(edge0 + dv1, edge0 + dv2, pa, calendar),\r\n        biggestDigitChanged(edge1 + dv1, edge1 + dv2, pa, calendar)\r\n    );\r\n    var rightDigit = Math.min(\r\n        biggestDigitChanged(edge0 + dv0, edge0 + dv1, pa, calendar),\r\n        biggestDigitChanged(edge1 + dv0, edge1 + dv1, pa, calendar)\r\n    );\r\n\r\n    // normally we try to make the label for the right edge different from\r\n    // the left edge label, so it's unambiguous which bin gets data on the edge.\r\n    // but if this results in more than 3 extra digits (or for dates, more than\r\n    // 2 fields ie hr&min or min&sec, which is 3600x), it'll be more clutter than\r\n    // useful so keep the label cleaner instead\r\n    var digit, disambiguateEdges;\r\n    if(leftDigit > rightDigit && rightDigit < Math.abs(edge1 - edge0) / 4000) {\r\n        digit = leftDigit;\r\n        disambiguateEdges = false;\r\n    } else {\r\n        digit = Math.min(leftDigit, rightDigit);\r\n        disambiguateEdges = true;\r\n    }\r\n\r\n    if(pa.type === 'date' && digit > oneDay) {\r\n        var dashExclude = (digit === oneYear) ? 1 : 6;\r\n        var increment = (digit === oneYear) ? 'M12' : 'M1';\r\n\r\n        return function(v, isRightEdge) {\r\n            var dateStr = pa.c2d(v, oneYear, calendar);\r\n            var dashPos = dateStr.indexOf('-', dashExclude);\r\n            if(dashPos > 0) dateStr = dateStr.substr(0, dashPos);\r\n            var roundedV = pa.d2c(dateStr, 0, calendar);\r\n\r\n            if(roundedV < v) {\r\n                var nextV = tickIncrement(roundedV, increment, false, calendar);\r\n                if((roundedV + nextV) / 2 < v + leftGap) roundedV = nextV;\r\n            }\r\n\r\n            if(isRightEdge && disambiguateEdges) {\r\n                return tickIncrement(roundedV, increment, true, calendar);\r\n            }\r\n\r\n            return roundedV;\r\n        };\r\n    }\r\n\r\n    return function(v, isRightEdge) {\r\n        var roundedV = digit * Math.round(v / digit);\r\n        // if we rounded down and we could round up and still be < leftGap\r\n        // (or what leftGap values round to), do that\r\n        if(roundedV + (digit / 10) < v && roundedV + (digit * 0.9) < v + leftGap) {\r\n            roundedV += digit;\r\n        }\r\n        // finally for the right edge back off one digit - but only if we can do that\r\n        // and not clip off any data that's potentially in the bin\r\n        if(isRightEdge && disambiguateEdges) {\r\n            roundedV -= digit;\r\n        }\r\n        return roundedV;\r\n    };\r\n};\r\n\r\n/*\r\n * Find the largest digit that changes within a (calcdata) region [v1, v2]\r\n * if dates, \"digit\" means date/time part when it's bigger than a second\r\n * returns the unit value to round to this digit, eg 0.01 to round to hundredths, or\r\n * 100 to round to hundreds. returns oneMonth or oneYear for month or year rounding,\r\n * so that Math.min will work, rather than 'M1' and 'M12'\r\n */\r\nfunction biggestDigitChanged(v1, v2, pa, calendar) {\r\n    // are we crossing zero? can't say anything.\r\n    // in principle this doesn't apply to dates but turns out this doesn't matter.\r\n    if(v1 * v2 <= 0) return Infinity;\r\n\r\n    var dv = Math.abs(v2 - v1);\r\n    var isDate = pa.type === 'date';\r\n    var digit = biggestGuaranteedDigitChanged(dv, isDate);\r\n    // see if a larger digit also changed\r\n    for(var i = 0; i < 10; i++) {\r\n        // numbers: next digit needs to be >10x but <100x then gets rounded down.\r\n        // dates: next digit can be as much as 60x (then rounded down)\r\n        var nextDigit = biggestGuaranteedDigitChanged(digit * 80, isDate);\r\n        // if we get to years, the chain stops\r\n        if(digit === nextDigit) break;\r\n        if(didDigitChange(nextDigit, v1, v2, isDate, pa, calendar)) digit = nextDigit;\r\n        else break;\r\n    }\r\n    return digit;\r\n}\r\n\r\n/*\r\n * Find the largest digit that *definitely* changes in a region [v, v + dv] for any v\r\n * for nonuniform date regions (months/years) pick the largest\r\n */\r\nfunction biggestGuaranteedDigitChanged(dv, isDate) {\r\n    if(isDate && dv > oneSec) {\r\n        // this is supposed to be the biggest *guaranteed* change\r\n        // so compare to the longest month and year across any calendar,\r\n        // and we'll iterate back up later\r\n        // note: does not support rounding larger than one year. We could add\r\n        // that if anyone wants it, but seems unusual and not strictly necessary.\r\n        if(dv > oneDay) {\r\n            if(dv > oneYear * 1.1) return oneYear;\r\n            if(dv > oneMonth * 1.1) return oneMonth;\r\n            return oneDay;\r\n        }\r\n\r\n        if(dv > oneHour) return oneHour;\r\n        if(dv > oneMin) return oneMin;\r\n        return oneSec;\r\n    }\r\n    return Math.pow(10, Math.floor(Math.log(dv) / Math.LN10));\r\n}\r\n\r\nfunction didDigitChange(digit, v1, v2, isDate, pa, calendar) {\r\n    if(isDate && digit > oneDay) {\r\n        var dateParts1 = dateParts(v1, pa, calendar);\r\n        var dateParts2 = dateParts(v2, pa, calendar);\r\n        var parti = (digit === oneYear) ? 0 : 1;\r\n        return dateParts1[parti] !== dateParts2[parti];\r\n    }\r\n    return Math.floor(v2 / digit) - Math.floor(v1 / digit) > 0.1;\r\n}\r\n\r\nfunction dateParts(v, pa, calendar) {\r\n    var parts = pa.c2d(v, oneYear, calendar).split('-');\r\n    if(parts[0] === '') {\r\n        parts.unshift();\r\n        parts[0] = '-' + parts[0];\r\n    }\r\n    return parts;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}
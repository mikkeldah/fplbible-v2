{"ast":null,"code":"'use strict';\n\nvar createScatter = require('regl-scatter2d');\n\nvar createLine = require('regl-line2d');\n\nvar createError = require('regl-error2d');\n\nvar Text = require('gl-text');\n\nvar Lib = require('../../lib');\n\nvar selectMode = require('../../components/dragelement/helpers').selectMode;\n\nvar prepareRegl = require('../../lib/prepare_regl');\n\nvar subTypes = require('../scatter/subtypes');\n\nvar linkTraces = require('../scatter/link_traces');\n\nvar styleTextSelection = require('./edit_style').styleTextSelection;\n\nfunction getViewport(fullLayout, xaxis, yaxis) {\n  var gs = fullLayout._size;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  return [gs.l + xaxis.domain[0] * gs.w, gs.b + yaxis.domain[0] * gs.h, width - gs.r - (1 - xaxis.domain[1]) * gs.w, height - gs.t - (1 - yaxis.domain[1]) * gs.h];\n}\n\nmodule.exports = function plot(gd, subplot, cdata) {\n  if (!cdata.length) return;\n  var fullLayout = gd._fullLayout;\n  var scene = subplot._scene;\n  var xaxis = subplot.xaxis;\n  var yaxis = subplot.yaxis;\n  var i, j; // we may have more subplots than initialized data due to Axes.getSubplots method\n\n  if (!scene) return;\n  var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint']);\n\n  if (!success) {\n    scene.init();\n    return;\n  }\n\n  var count = scene.count;\n\n  var regl = fullLayout._glcanvas.data()[0].regl; // that is needed for fills\n\n\n  linkTraces(gd, subplot, cdata);\n\n  if (scene.dirty) {\n    // make sure scenes are created\n    if (scene.error2d === true) {\n      scene.error2d = createError(regl);\n    }\n\n    if (scene.line2d === true) {\n      scene.line2d = createLine(regl);\n    }\n\n    if (scene.scatter2d === true) {\n      scene.scatter2d = createScatter(regl, {\n        constPointSize: true\n      });\n    }\n\n    if (scene.fill2d === true) {\n      scene.fill2d = createLine(regl);\n    }\n\n    if (scene.glText === true) {\n      scene.glText = new Array(count);\n\n      for (i = 0; i < count; i++) {\n        scene.glText[i] = new Text(regl);\n      }\n    } // update main marker options\n\n\n    if (scene.glText) {\n      if (count > scene.glText.length) {\n        // add gl text marker\n        var textsToAdd = count - scene.glText.length;\n\n        for (i = 0; i < textsToAdd; i++) {\n          scene.glText.push(new Text(regl));\n        }\n      } else if (count < scene.glText.length) {\n        // remove gl text marker\n        var textsToRemove = scene.glText.length - count;\n        var removedTexts = scene.glText.splice(count, textsToRemove);\n        removedTexts.forEach(function (text) {\n          text.destroy();\n        });\n      }\n\n      for (i = 0; i < count; i++) {\n        scene.glText[i].update(scene.textOptions[i]);\n      }\n    }\n\n    if (scene.line2d) {\n      scene.line2d.update(scene.lineOptions);\n      scene.lineOptions = scene.lineOptions.map(function (lineOptions) {\n        if (lineOptions && lineOptions.positions) {\n          var srcPos = lineOptions.positions;\n          var firstptdef = 0;\n\n          while (firstptdef < srcPos.length && (isNaN(srcPos[firstptdef]) || isNaN(srcPos[firstptdef + 1]))) {\n            firstptdef += 2;\n          }\n\n          var lastptdef = srcPos.length - 2;\n\n          while (lastptdef > firstptdef && (isNaN(srcPos[lastptdef]) || isNaN(srcPos[lastptdef + 1]))) {\n            lastptdef -= 2;\n          }\n\n          lineOptions.positions = srcPos.slice(firstptdef, lastptdef + 2);\n        }\n\n        return lineOptions;\n      });\n      scene.line2d.update(scene.lineOptions);\n    }\n\n    if (scene.error2d) {\n      var errorBatch = (scene.errorXOptions || []).concat(scene.errorYOptions || []);\n      scene.error2d.update(errorBatch);\n    }\n\n    if (scene.scatter2d) {\n      scene.scatter2d.update(scene.markerOptions);\n    } // fill requires linked traces, so we generate it's positions here\n\n\n    scene.fillOrder = Lib.repeat(null, count);\n\n    if (scene.fill2d) {\n      scene.fillOptions = scene.fillOptions.map(function (fillOptions, i) {\n        var cdscatter = cdata[i];\n        if (!fillOptions || !cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\n        var cd = cdscatter[0];\n        var trace = cd.trace;\n        var stash = cd.t;\n        var lineOptions = scene.lineOptions[i];\n        var last, j;\n        var fillData = [];\n        if (trace._ownfill) fillData.push(i);\n        if (trace._nexttrace) fillData.push(i + 1);\n        if (fillData.length) scene.fillOrder[i] = fillData;\n        var pos = [];\n        var srcPos = lineOptions && lineOptions.positions || stash.positions;\n        var firstptdef, lastptdef;\n\n        if (trace.fill === 'tozeroy') {\n          firstptdef = 0;\n\n          while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef + 1])) {\n            firstptdef += 2;\n          }\n\n          lastptdef = srcPos.length - 2;\n\n          while (lastptdef > firstptdef && isNaN(srcPos[lastptdef + 1])) {\n            lastptdef -= 2;\n          }\n\n          if (srcPos[firstptdef + 1] !== 0) {\n            pos = [srcPos[firstptdef], 0];\n          }\n\n          pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n\n          if (srcPos[lastptdef + 1] !== 0) {\n            pos = pos.concat([srcPos[lastptdef], 0]);\n          }\n        } else if (trace.fill === 'tozerox') {\n          firstptdef = 0;\n\n          while (firstptdef < srcPos.length && isNaN(srcPos[firstptdef])) {\n            firstptdef += 2;\n          }\n\n          lastptdef = srcPos.length - 2;\n\n          while (lastptdef > firstptdef && isNaN(srcPos[lastptdef])) {\n            lastptdef -= 2;\n          }\n\n          if (srcPos[firstptdef] !== 0) {\n            pos = [0, srcPos[firstptdef + 1]];\n          }\n\n          pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\n\n          if (srcPos[lastptdef] !== 0) {\n            pos = pos.concat([0, srcPos[lastptdef + 1]]);\n          }\n        } else if (trace.fill === 'toself' || trace.fill === 'tonext') {\n          pos = [];\n          last = 0;\n          fillOptions.splitNull = true;\n\n          for (j = 0; j < srcPos.length; j += 2) {\n            if (isNaN(srcPos[j]) || isNaN(srcPos[j + 1])) {\n              pos = pos.concat(srcPos.slice(last, j));\n              pos.push(srcPos[last], srcPos[last + 1]);\n              pos.push(null, null); // keep null to mark end of polygon\n\n              last = j + 2;\n            }\n          }\n\n          pos = pos.concat(srcPos.slice(last));\n\n          if (last) {\n            pos.push(srcPos[last], srcPos[last + 1]);\n          }\n        } else {\n          var nextTrace = trace._nexttrace;\n\n          if (nextTrace) {\n            var nextOptions = scene.lineOptions[i + 1];\n\n            if (nextOptions) {\n              var nextPos = nextOptions.positions;\n\n              if (trace.fill === 'tonexty') {\n                pos = srcPos.slice();\n\n                for (i = Math.floor(nextPos.length / 2); i--;) {\n                  var xx = nextPos[i * 2];\n                  var yy = nextPos[i * 2 + 1];\n                  if (isNaN(xx) || isNaN(yy)) continue;\n                  pos.push(xx, yy);\n                }\n\n                fillOptions.fill = nextTrace.fillcolor;\n              }\n            }\n          }\n        } // detect prev trace positions to exclude from current fill\n\n\n        if (trace._prevtrace && trace._prevtrace.fill === 'tonext') {\n          var prevLinePos = scene.lineOptions[i - 1].positions; // FIXME: likely this logic should be tested better\n\n          var offset = pos.length / 2;\n          last = offset;\n          var hole = [last];\n\n          for (j = 0; j < prevLinePos.length; j += 2) {\n            if (isNaN(prevLinePos[j]) || isNaN(prevLinePos[j + 1])) {\n              hole.push(j / 2 + offset + 1);\n              last = j + 2;\n            }\n          }\n\n          pos = pos.concat(prevLinePos);\n          fillOptions.hole = hole;\n        }\n\n        fillOptions.fillmode = trace.fill;\n        fillOptions.opacity = trace.opacity;\n        fillOptions.positions = pos;\n        return fillOptions;\n      });\n      scene.fill2d.update(scene.fillOptions);\n    }\n  } // form batch arrays, and check for selected points\n\n\n  var dragmode = fullLayout.dragmode;\n  var isSelectMode = selectMode(dragmode);\n  var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\n\n  for (i = 0; i < count; i++) {\n    var cd0 = cdata[i][0];\n    var trace = cd0.trace;\n    var stash = cd0.t;\n    var index = stash.index;\n    var len = trace._length;\n    var x = stash.x;\n    var y = stash.y;\n\n    if (trace.selectedpoints || isSelectMode || clickSelectEnabled) {\n      if (!isSelectMode) isSelectMode = true; // regenerate scene batch, if traces number changed during selection\n\n      if (trace.selectedpoints) {\n        var selPts = scene.selectBatch[index] = Lib.selIndices2selPoints(trace);\n        var selDict = {};\n\n        for (j = 0; j < selPts.length; j++) {\n          selDict[selPts[j]] = 1;\n        }\n\n        var unselPts = [];\n\n        for (j = 0; j < len; j++) {\n          if (!selDict[j]) unselPts.push(j);\n        }\n\n        scene.unselectBatch[index] = unselPts;\n      } // precalculate px coords since we are not going to pan during select\n      // TODO, could do better here e.g.\n      // - spin that in a webworker\n      // - compute selection from polygons in data coordinates\n      //   (maybe just for linear axes)\n\n\n      var xpx = stash.xpx = new Array(len);\n      var ypx = stash.ypx = new Array(len);\n\n      for (j = 0; j < len; j++) {\n        xpx[j] = xaxis.c2p(x[j]);\n        ypx[j] = yaxis.c2p(y[j]);\n      }\n    } else {\n      stash.xpx = stash.ypx = null;\n    }\n  }\n\n  if (isSelectMode) {\n    // create scatter instance by cloning scatter2d\n    if (!scene.select2d) {\n      scene.select2d = createScatter(fullLayout._glcanvas.data()[1].regl);\n    } // use unselected styles on 'context' canvas\n\n\n    if (scene.scatter2d) {\n      var unselOpts = new Array(count);\n\n      for (i = 0; i < count; i++) {\n        unselOpts[i] = scene.selectBatch[i].length || scene.unselectBatch[i].length ? scene.markerUnselectedOptions[i] : {};\n      }\n\n      scene.scatter2d.update(unselOpts);\n    } // use selected style on 'focus' canvas\n\n\n    if (scene.select2d) {\n      scene.select2d.update(scene.markerOptions);\n      scene.select2d.update(scene.markerSelectedOptions);\n    }\n\n    if (scene.glText) {\n      cdata.forEach(function (cdscatter) {\n        var trace = ((cdscatter || [])[0] || {}).trace || {};\n\n        if (subTypes.hasText(trace)) {\n          styleTextSelection(cdscatter);\n        }\n      });\n    }\n  } else {\n    // reset 'context' scatter2d opts to base opts,\n    // thus unsetting markerUnselectedOptions from selection\n    if (scene.scatter2d) {\n      scene.scatter2d.update(scene.markerOptions);\n    }\n  } // provide viewport and range\n\n\n  var vpRange0 = {\n    viewport: getViewport(fullLayout, xaxis, yaxis),\n    // TODO do we need those fallbacks?\n    range: [(xaxis._rl || xaxis.range)[0], (yaxis._rl || yaxis.range)[0], (xaxis._rl || xaxis.range)[1], (yaxis._rl || yaxis.range)[1]]\n  };\n  var vpRange = Lib.repeat(vpRange0, scene.count); // upload viewport/range data to GPU\n\n  if (scene.fill2d) {\n    scene.fill2d.update(vpRange);\n  }\n\n  if (scene.line2d) {\n    scene.line2d.update(vpRange);\n  }\n\n  if (scene.error2d) {\n    scene.error2d.update(vpRange.concat(vpRange));\n  }\n\n  if (scene.scatter2d) {\n    scene.scatter2d.update(vpRange);\n  }\n\n  if (scene.select2d) {\n    scene.select2d.update(vpRange);\n  }\n\n  if (scene.glText) {\n    scene.glText.forEach(function (text) {\n      text.update(vpRange0);\n    });\n  }\n};","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/traces/scattergl/plot.js"],"names":["createScatter","require","createLine","createError","Text","Lib","selectMode","prepareRegl","subTypes","linkTraces","styleTextSelection","getViewport","fullLayout","xaxis","yaxis","gs","_size","width","height","l","domain","w","b","h","r","t","module","exports","plot","gd","subplot","cdata","length","_fullLayout","scene","_scene","i","j","success","init","count","regl","_glcanvas","data","dirty","error2d","line2d","scatter2d","constPointSize","fill2d","glText","Array","textsToAdd","push","textsToRemove","removedTexts","splice","forEach","text","destroy","update","textOptions","lineOptions","map","positions","srcPos","firstptdef","isNaN","lastptdef","slice","errorBatch","errorXOptions","concat","errorYOptions","markerOptions","fillOrder","repeat","fillOptions","cdscatter","trace","cd","stash","last","fillData","_ownfill","_nexttrace","pos","fill","splitNull","nextTrace","nextOptions","nextPos","Math","floor","xx","yy","fillcolor","_prevtrace","prevLinePos","offset","hole","fillmode","opacity","dragmode","isSelectMode","clickSelectEnabled","clickmode","indexOf","cd0","index","len","_length","x","y","selectedpoints","selPts","selectBatch","selIndices2selPoints","selDict","unselPts","unselectBatch","xpx","ypx","c2p","select2d","unselOpts","markerUnselectedOptions","markerSelectedOptions","hasText","vpRange0","viewport","range","_rl","vpRange"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar createScatter = require('regl-scatter2d');\r\nvar createLine = require('regl-line2d');\r\nvar createError = require('regl-error2d');\r\nvar Text = require('gl-text');\r\n\r\nvar Lib = require('../../lib');\r\nvar selectMode = require('../../components/dragelement/helpers').selectMode;\r\nvar prepareRegl = require('../../lib/prepare_regl');\r\n\r\nvar subTypes = require('../scatter/subtypes');\r\nvar linkTraces = require('../scatter/link_traces');\r\n\r\nvar styleTextSelection = require('./edit_style').styleTextSelection;\r\n\r\nfunction getViewport(fullLayout, xaxis, yaxis) {\r\n    var gs = fullLayout._size;\r\n    var width = fullLayout.width;\r\n    var height = fullLayout.height;\r\n    return [\r\n        gs.l + xaxis.domain[0] * gs.w,\r\n        gs.b + yaxis.domain[0] * gs.h,\r\n        (width - gs.r) - (1 - xaxis.domain[1]) * gs.w,\r\n        (height - gs.t) - (1 - yaxis.domain[1]) * gs.h\r\n    ];\r\n}\r\n\r\nmodule.exports = function plot(gd, subplot, cdata) {\r\n    if(!cdata.length) return;\r\n\r\n    var fullLayout = gd._fullLayout;\r\n    var scene = subplot._scene;\r\n    var xaxis = subplot.xaxis;\r\n    var yaxis = subplot.yaxis;\r\n    var i, j;\r\n\r\n    // we may have more subplots than initialized data due to Axes.getSubplots method\r\n    if(!scene) return;\r\n\r\n    var success = prepareRegl(gd, ['ANGLE_instanced_arrays', 'OES_element_index_uint']);\r\n    if(!success) {\r\n        scene.init();\r\n        return;\r\n    }\r\n\r\n    var count = scene.count;\r\n    var regl = fullLayout._glcanvas.data()[0].regl;\r\n\r\n    // that is needed for fills\r\n    linkTraces(gd, subplot, cdata);\r\n\r\n    if(scene.dirty) {\r\n        // make sure scenes are created\r\n        if(scene.error2d === true) {\r\n            scene.error2d = createError(regl);\r\n        }\r\n        if(scene.line2d === true) {\r\n            scene.line2d = createLine(regl);\r\n        }\r\n        if(scene.scatter2d === true) {\r\n            scene.scatter2d = createScatter(regl, { constPointSize: true });\r\n        }\r\n        if(scene.fill2d === true) {\r\n            scene.fill2d = createLine(regl);\r\n        }\r\n        if(scene.glText === true) {\r\n            scene.glText = new Array(count);\r\n            for(i = 0; i < count; i++) {\r\n                scene.glText[i] = new Text(regl);\r\n            }\r\n        }\r\n\r\n        // update main marker options\r\n        if(scene.glText) {\r\n            if(count > scene.glText.length) {\r\n                // add gl text marker\r\n                var textsToAdd = count - scene.glText.length;\r\n                for(i = 0; i < textsToAdd; i++) {\r\n                    scene.glText.push(new Text(regl));\r\n                }\r\n            } else if(count < scene.glText.length) {\r\n                // remove gl text marker\r\n                var textsToRemove = scene.glText.length - count;\r\n                var removedTexts = scene.glText.splice(count, textsToRemove);\r\n                removedTexts.forEach(function(text) { text.destroy(); });\r\n            }\r\n\r\n            for(i = 0; i < count; i++) {\r\n                scene.glText[i].update(scene.textOptions[i]);\r\n            }\r\n        }\r\n        if(scene.line2d) {\r\n            scene.line2d.update(scene.lineOptions);\r\n            scene.lineOptions = scene.lineOptions.map(function(lineOptions) {\r\n                if(lineOptions && lineOptions.positions) {\r\n                    var srcPos = lineOptions.positions;\r\n\r\n                    var firstptdef = 0;\r\n                    while(firstptdef < srcPos.length && (isNaN(srcPos[firstptdef]) || isNaN(srcPos[firstptdef + 1]))) {\r\n                        firstptdef += 2;\r\n                    }\r\n                    var lastptdef = srcPos.length - 2;\r\n                    while(lastptdef > firstptdef && (isNaN(srcPos[lastptdef]) || isNaN(srcPos[lastptdef + 1]))) {\r\n                        lastptdef -= 2;\r\n                    }\r\n                    lineOptions.positions = srcPos.slice(firstptdef, lastptdef + 2);\r\n                }\r\n                return lineOptions;\r\n            });\r\n            scene.line2d.update(scene.lineOptions);\r\n        }\r\n        if(scene.error2d) {\r\n            var errorBatch = (scene.errorXOptions || []).concat(scene.errorYOptions || []);\r\n            scene.error2d.update(errorBatch);\r\n        }\r\n        if(scene.scatter2d) {\r\n            scene.scatter2d.update(scene.markerOptions);\r\n        }\r\n\r\n        // fill requires linked traces, so we generate it's positions here\r\n        scene.fillOrder = Lib.repeat(null, count);\r\n        if(scene.fill2d) {\r\n            scene.fillOptions = scene.fillOptions.map(function(fillOptions, i) {\r\n                var cdscatter = cdata[i];\r\n                if(!fillOptions || !cdscatter || !cdscatter[0] || !cdscatter[0].trace) return;\r\n                var cd = cdscatter[0];\r\n                var trace = cd.trace;\r\n                var stash = cd.t;\r\n                var lineOptions = scene.lineOptions[i];\r\n                var last, j;\r\n\r\n                var fillData = [];\r\n                if(trace._ownfill) fillData.push(i);\r\n                if(trace._nexttrace) fillData.push(i + 1);\r\n                if(fillData.length) scene.fillOrder[i] = fillData;\r\n\r\n                var pos = [];\r\n                var srcPos = (lineOptions && lineOptions.positions) || stash.positions;\r\n                var firstptdef, lastptdef;\r\n\r\n                if(trace.fill === 'tozeroy') {\r\n                    firstptdef = 0;\r\n                    while(firstptdef < srcPos.length && isNaN(srcPos[firstptdef + 1])) {\r\n                        firstptdef += 2;\r\n                    }\r\n                    lastptdef = srcPos.length - 2;\r\n                    while(lastptdef > firstptdef && isNaN(srcPos[lastptdef + 1])) {\r\n                        lastptdef -= 2;\r\n                    }\r\n                    if(srcPos[firstptdef + 1] !== 0) {\r\n                        pos = [srcPos[firstptdef], 0];\r\n                    }\r\n                    pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\r\n                    if(srcPos[lastptdef + 1] !== 0) {\r\n                        pos = pos.concat([srcPos[lastptdef], 0]);\r\n                    }\r\n                } else if(trace.fill === 'tozerox') {\r\n                    firstptdef = 0;\r\n                    while(firstptdef < srcPos.length && isNaN(srcPos[firstptdef])) {\r\n                        firstptdef += 2;\r\n                    }\r\n                    lastptdef = srcPos.length - 2;\r\n                    while(lastptdef > firstptdef && isNaN(srcPos[lastptdef])) {\r\n                        lastptdef -= 2;\r\n                    }\r\n                    if(srcPos[firstptdef] !== 0) {\r\n                        pos = [0, srcPos[firstptdef + 1]];\r\n                    }\r\n                    pos = pos.concat(srcPos.slice(firstptdef, lastptdef + 2));\r\n                    if(srcPos[lastptdef] !== 0) {\r\n                        pos = pos.concat([ 0, srcPos[lastptdef + 1]]);\r\n                    }\r\n                } else if(trace.fill === 'toself' || trace.fill === 'tonext') {\r\n                    pos = [];\r\n                    last = 0;\r\n\r\n                    fillOptions.splitNull = true;\r\n\r\n                    for(j = 0; j < srcPos.length; j += 2) {\r\n                        if(isNaN(srcPos[j]) || isNaN(srcPos[j + 1])) {\r\n                            pos = pos.concat(srcPos.slice(last, j));\r\n                            pos.push(srcPos[last], srcPos[last + 1]);\r\n                            pos.push(null, null); // keep null to mark end of polygon\r\n                            last = j + 2;\r\n                        }\r\n                    }\r\n                    pos = pos.concat(srcPos.slice(last));\r\n                    if(last) {\r\n                        pos.push(srcPos[last], srcPos[last + 1]);\r\n                    }\r\n                } else {\r\n                    var nextTrace = trace._nexttrace;\r\n\r\n                    if(nextTrace) {\r\n                        var nextOptions = scene.lineOptions[i + 1];\r\n\r\n                        if(nextOptions) {\r\n                            var nextPos = nextOptions.positions;\r\n                            if(trace.fill === 'tonexty') {\r\n                                pos = srcPos.slice();\r\n\r\n                                for(i = Math.floor(nextPos.length / 2); i--;) {\r\n                                    var xx = nextPos[i * 2];\r\n                                    var yy = nextPos[i * 2 + 1];\r\n                                    if(isNaN(xx) || isNaN(yy)) continue;\r\n                                    pos.push(xx, yy);\r\n                                }\r\n                                fillOptions.fill = nextTrace.fillcolor;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // detect prev trace positions to exclude from current fill\r\n                if(trace._prevtrace && trace._prevtrace.fill === 'tonext') {\r\n                    var prevLinePos = scene.lineOptions[i - 1].positions;\r\n\r\n                    // FIXME: likely this logic should be tested better\r\n                    var offset = pos.length / 2;\r\n                    last = offset;\r\n                    var hole = [last];\r\n                    for(j = 0; j < prevLinePos.length; j += 2) {\r\n                        if(isNaN(prevLinePos[j]) || isNaN(prevLinePos[j + 1])) {\r\n                            hole.push(j / 2 + offset + 1);\r\n                            last = j + 2;\r\n                        }\r\n                    }\r\n\r\n                    pos = pos.concat(prevLinePos);\r\n                    fillOptions.hole = hole;\r\n                }\r\n                fillOptions.fillmode = trace.fill;\r\n                fillOptions.opacity = trace.opacity;\r\n                fillOptions.positions = pos;\r\n\r\n                return fillOptions;\r\n            });\r\n\r\n            scene.fill2d.update(scene.fillOptions);\r\n        }\r\n    }\r\n\r\n    // form batch arrays, and check for selected points\r\n    var dragmode = fullLayout.dragmode;\r\n    var isSelectMode = selectMode(dragmode);\r\n    var clickSelectEnabled = fullLayout.clickmode.indexOf('select') > -1;\r\n\r\n    for(i = 0; i < count; i++) {\r\n        var cd0 = cdata[i][0];\r\n        var trace = cd0.trace;\r\n        var stash = cd0.t;\r\n        var index = stash.index;\r\n        var len = trace._length;\r\n        var x = stash.x;\r\n        var y = stash.y;\r\n\r\n        if(trace.selectedpoints || isSelectMode || clickSelectEnabled) {\r\n            if(!isSelectMode) isSelectMode = true;\r\n\r\n            // regenerate scene batch, if traces number changed during selection\r\n            if(trace.selectedpoints) {\r\n                var selPts = scene.selectBatch[index] = Lib.selIndices2selPoints(trace);\r\n\r\n                var selDict = {};\r\n                for(j = 0; j < selPts.length; j++) {\r\n                    selDict[selPts[j]] = 1;\r\n                }\r\n                var unselPts = [];\r\n                for(j = 0; j < len; j++) {\r\n                    if(!selDict[j]) unselPts.push(j);\r\n                }\r\n                scene.unselectBatch[index] = unselPts;\r\n            }\r\n\r\n            // precalculate px coords since we are not going to pan during select\r\n            // TODO, could do better here e.g.\r\n            // - spin that in a webworker\r\n            // - compute selection from polygons in data coordinates\r\n            //   (maybe just for linear axes)\r\n            var xpx = stash.xpx = new Array(len);\r\n            var ypx = stash.ypx = new Array(len);\r\n            for(j = 0; j < len; j++) {\r\n                xpx[j] = xaxis.c2p(x[j]);\r\n                ypx[j] = yaxis.c2p(y[j]);\r\n            }\r\n        } else {\r\n            stash.xpx = stash.ypx = null;\r\n        }\r\n    }\r\n\r\n    if(isSelectMode) {\r\n        // create scatter instance by cloning scatter2d\r\n        if(!scene.select2d) {\r\n            scene.select2d = createScatter(fullLayout._glcanvas.data()[1].regl);\r\n        }\r\n\r\n        // use unselected styles on 'context' canvas\r\n        if(scene.scatter2d) {\r\n            var unselOpts = new Array(count);\r\n            for(i = 0; i < count; i++) {\r\n                unselOpts[i] = scene.selectBatch[i].length || scene.unselectBatch[i].length ?\r\n                    scene.markerUnselectedOptions[i] :\r\n                    {};\r\n            }\r\n            scene.scatter2d.update(unselOpts);\r\n        }\r\n\r\n        // use selected style on 'focus' canvas\r\n        if(scene.select2d) {\r\n            scene.select2d.update(scene.markerOptions);\r\n            scene.select2d.update(scene.markerSelectedOptions);\r\n        }\r\n\r\n        if(scene.glText) {\r\n            cdata.forEach(function(cdscatter) {\r\n                var trace = ((cdscatter || [])[0] || {}).trace || {};\r\n                if(subTypes.hasText(trace)) {\r\n                    styleTextSelection(cdscatter);\r\n                }\r\n            });\r\n        }\r\n    } else {\r\n        // reset 'context' scatter2d opts to base opts,\r\n        // thus unsetting markerUnselectedOptions from selection\r\n        if(scene.scatter2d) {\r\n            scene.scatter2d.update(scene.markerOptions);\r\n        }\r\n    }\r\n\r\n    // provide viewport and range\r\n    var vpRange0 = {\r\n        viewport: getViewport(fullLayout, xaxis, yaxis),\r\n        // TODO do we need those fallbacks?\r\n        range: [\r\n            (xaxis._rl || xaxis.range)[0],\r\n            (yaxis._rl || yaxis.range)[0],\r\n            (xaxis._rl || xaxis.range)[1],\r\n            (yaxis._rl || yaxis.range)[1]\r\n        ]\r\n    };\r\n    var vpRange = Lib.repeat(vpRange0, scene.count);\r\n\r\n    // upload viewport/range data to GPU\r\n    if(scene.fill2d) {\r\n        scene.fill2d.update(vpRange);\r\n    }\r\n    if(scene.line2d) {\r\n        scene.line2d.update(vpRange);\r\n    }\r\n    if(scene.error2d) {\r\n        scene.error2d.update(vpRange.concat(vpRange));\r\n    }\r\n    if(scene.scatter2d) {\r\n        scene.scatter2d.update(vpRange);\r\n    }\r\n    if(scene.select2d) {\r\n        scene.select2d.update(vpRange);\r\n    }\r\n    if(scene.glText) {\r\n        scene.glText.forEach(function(text) { text.update(vpRange0); });\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar isPlainObject = require('../lib/is_plain_object');\n\nvar noop = require('../lib/noop');\n\nvar Loggers = require('../lib/loggers');\n\nvar sorterAsc = require('../lib/search').sorterAsc;\n\nvar Registry = require('../registry');\n\nexports.containerArrayMatch = require('./container_array_match');\n\nvar isAddVal = exports.isAddVal = function isAddVal(val) {\n  return val === 'add' || isPlainObject(val);\n};\n\nvar isRemoveVal = exports.isRemoveVal = function isRemoveVal(val) {\n  return val === null || val === 'remove';\n};\n/*\r\n * applyContainerArrayChanges: for managing arrays of layout components in relayout\r\n * handles them all with a consistent interface.\r\n *\r\n * Here are the supported actions -> relayout calls -> edits we get here\r\n * (as prepared in _relayout):\r\n *\r\n * add an empty obj -> {'annotations[2]': 'add'} -> {2: {'': 'add'}}\r\n * add a specific obj -> {'annotations[2]': {attrs}} -> {2: {'': {attrs}}}\r\n * delete an obj -> {'annotations[2]': 'remove'} -> {2: {'': 'remove'}}\r\n *               -> {'annotations[2]': null} -> {2: {'': null}}\r\n * delete the whole array -> {'annotations': 'remove'} -> {'': {'': 'remove'}}\r\n *                        -> {'annotations': null} -> {'': {'': null}}\r\n * edit an object -> {'annotations[2].text': 'boo'} -> {2: {'text': 'boo'}}\r\n *\r\n * You can combine many edits to different objects. Objects are added and edited\r\n * in ascending order, then removed in descending order.\r\n * For example, starting with [a, b, c], if you want to:\r\n * - replace b with d:\r\n *   {'annotations[1]': d, 'annotations[2]': null} (b is item 2 after adding d)\r\n * - add a new item d between a and b, and edit b:\r\n *    {'annotations[1]': d, 'annotations[2].x': newX} (b is item 2 after adding d)\r\n * - delete b and edit c:\r\n *    {'annotations[1]': null, 'annotations[2].x': newX} (c is edited before b is removed)\r\n *\r\n * You CANNOT combine adding/deleting an item at index `i` with edits to the same index `i`\r\n * You CANNOT combine replacing/deleting the whole array with anything else (for the same array).\r\n *\r\n * @param {HTMLDivElement} gd\r\n *  the DOM element of the graph container div\r\n * @param {Lib.nestedProperty} componentType: the array we are editing\r\n * @param {Object} edits\r\n *  the changes to make; keys are indices to edit, values are themselves objects:\r\n *  {attr: newValue} of changes to make to that index (with add/remove behavior\r\n *  in special values of the empty attr)\r\n * @param {Object} flags\r\n *  the flags for which actions we're going to perform to display these (and\r\n *  any other) changes. If we're already `recalc`ing, we don't need to redraw\r\n *  individual items\r\n * @param {function} _nestedProperty\r\n *  a (possibly modified for gui edits) nestedProperty constructor\r\n *  The modified version takes a 3rd argument, for a prefix to the attribute\r\n *  string necessary for storing GUI edits\r\n *\r\n * @returns {bool} `true` if it managed to complete drawing of the changes\r\n *  `false` would mean the parent should replot.\r\n */\n\n\nexports.applyContainerArrayChanges = function applyContainerArrayChanges(gd, np, edits, flags, _nestedProperty) {\n  var componentType = np.astr;\n  var supplyComponentDefaults = Registry.getComponentMethod(componentType, 'supplyLayoutDefaults');\n  var draw = Registry.getComponentMethod(componentType, 'draw');\n  var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n  var replotLater = flags.replot || flags.recalc || supplyComponentDefaults === noop || draw === noop;\n  var layout = gd.layout;\n  var fullLayout = gd._fullLayout;\n\n  if (edits['']) {\n    if (Object.keys(edits).length > 1) {\n      Loggers.warn('Full array edits are incompatible with other edits', componentType);\n    }\n\n    var fullVal = edits[''][''];\n    if (isRemoveVal(fullVal)) np.set(null);else if (Array.isArray(fullVal)) np.set(fullVal);else {\n      Loggers.warn('Unrecognized full array edit value', componentType, fullVal);\n      return true;\n    }\n    if (replotLater) return false;\n    supplyComponentDefaults(layout, fullLayout);\n    draw(gd);\n    return true;\n  }\n\n  var componentNums = Object.keys(edits).map(Number).sort(sorterAsc);\n  var componentArrayIn = np.get();\n  var componentArray = componentArrayIn || []; // componentArrayFull is used just to keep splices in line between\n  // full and input arrays, so private keys can be copied over after\n  // redoing supplyDefaults\n  // TODO: this assumes componentArray is in gd.layout - which will not be\n  // true after we extend this to restyle\n\n  var componentArrayFull = _nestedProperty(fullLayout, componentType).get();\n\n  var deletes = [];\n  var firstIndexChange = -1;\n  var maxIndex = componentArray.length;\n  var i;\n  var j;\n  var componentNum;\n  var objEdits;\n  var objKeys;\n  var objVal;\n  var adding, prefix; // first make the add and edit changes\n\n  for (i = 0; i < componentNums.length; i++) {\n    componentNum = componentNums[i];\n    objEdits = edits[componentNum];\n    objKeys = Object.keys(objEdits);\n    objVal = objEdits[''], adding = isAddVal(objVal);\n\n    if (componentNum < 0 || componentNum > componentArray.length - (adding ? 0 : 1)) {\n      Loggers.warn('index out of range', componentType, componentNum);\n      continue;\n    }\n\n    if (objVal !== undefined) {\n      if (objKeys.length > 1) {\n        Loggers.warn('Insertion & removal are incompatible with edits to the same index.', componentType, componentNum);\n      }\n\n      if (isRemoveVal(objVal)) {\n        deletes.push(componentNum);\n      } else if (adding) {\n        if (objVal === 'add') objVal = {};\n        componentArray.splice(componentNum, 0, objVal);\n        if (componentArrayFull) componentArrayFull.splice(componentNum, 0, {});\n      } else {\n        Loggers.warn('Unrecognized full object edit value', componentType, componentNum, objVal);\n      }\n\n      if (firstIndexChange === -1) firstIndexChange = componentNum;\n    } else {\n      for (j = 0; j < objKeys.length; j++) {\n        prefix = componentType + '[' + componentNum + '].';\n\n        _nestedProperty(componentArray[componentNum], objKeys[j], prefix).set(objEdits[objKeys[j]]);\n      }\n    }\n  } // now do deletes\n\n\n  for (i = deletes.length - 1; i >= 0; i--) {\n    componentArray.splice(deletes[i], 1); // TODO: this drops private keys that had been stored in componentArrayFull\n    // does this have any ill effects?\n\n    if (componentArrayFull) componentArrayFull.splice(deletes[i], 1);\n  }\n\n  if (!componentArray.length) np.set(null);else if (!componentArrayIn) np.set(componentArray);\n  if (replotLater) return false;\n  supplyComponentDefaults(layout, fullLayout); // finally draw all the components we need to\n  // if we added or removed any, redraw all after it\n\n  if (drawOne !== noop) {\n    var indicesToDraw;\n\n    if (firstIndexChange === -1) {\n      // there's no re-indexing to do, so only redraw components that changed\n      indicesToDraw = componentNums;\n    } else {\n      // in case the component array was shortened, we still need do call\n      // drawOne on the latter items so they get properly removed\n      maxIndex = Math.max(componentArray.length, maxIndex);\n      indicesToDraw = [];\n\n      for (i = 0; i < componentNums.length; i++) {\n        componentNum = componentNums[i];\n        if (componentNum >= firstIndexChange) break;\n        indicesToDraw.push(componentNum);\n      }\n\n      for (i = firstIndexChange; i < maxIndex; i++) {\n        indicesToDraw.push(i);\n      }\n    }\n\n    for (i = 0; i < indicesToDraw.length; i++) {\n      drawOne(gd, indicesToDraw[i]);\n    }\n  } else draw(gd);\n\n  return true;\n};","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/plot_api/manage_arrays.js"],"names":["isPlainObject","require","noop","Loggers","sorterAsc","Registry","exports","containerArrayMatch","isAddVal","val","isRemoveVal","applyContainerArrayChanges","gd","np","edits","flags","_nestedProperty","componentType","astr","supplyComponentDefaults","getComponentMethod","draw","drawOne","replotLater","replot","recalc","layout","fullLayout","_fullLayout","Object","keys","length","warn","fullVal","set","Array","isArray","componentNums","map","Number","sort","componentArrayIn","get","componentArray","componentArrayFull","deletes","firstIndexChange","maxIndex","i","j","componentNum","objEdits","objKeys","objVal","adding","prefix","undefined","push","splice","indicesToDraw","Math","max"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar isPlainObject = require('../lib/is_plain_object');\r\nvar noop = require('../lib/noop');\r\nvar Loggers = require('../lib/loggers');\r\nvar sorterAsc = require('../lib/search').sorterAsc;\r\nvar Registry = require('../registry');\r\n\r\n\r\nexports.containerArrayMatch = require('./container_array_match');\r\n\r\nvar isAddVal = exports.isAddVal = function isAddVal(val) {\r\n    return val === 'add' || isPlainObject(val);\r\n};\r\n\r\nvar isRemoveVal = exports.isRemoveVal = function isRemoveVal(val) {\r\n    return val === null || val === 'remove';\r\n};\r\n\r\n/*\r\n * applyContainerArrayChanges: for managing arrays of layout components in relayout\r\n * handles them all with a consistent interface.\r\n *\r\n * Here are the supported actions -> relayout calls -> edits we get here\r\n * (as prepared in _relayout):\r\n *\r\n * add an empty obj -> {'annotations[2]': 'add'} -> {2: {'': 'add'}}\r\n * add a specific obj -> {'annotations[2]': {attrs}} -> {2: {'': {attrs}}}\r\n * delete an obj -> {'annotations[2]': 'remove'} -> {2: {'': 'remove'}}\r\n *               -> {'annotations[2]': null} -> {2: {'': null}}\r\n * delete the whole array -> {'annotations': 'remove'} -> {'': {'': 'remove'}}\r\n *                        -> {'annotations': null} -> {'': {'': null}}\r\n * edit an object -> {'annotations[2].text': 'boo'} -> {2: {'text': 'boo'}}\r\n *\r\n * You can combine many edits to different objects. Objects are added and edited\r\n * in ascending order, then removed in descending order.\r\n * For example, starting with [a, b, c], if you want to:\r\n * - replace b with d:\r\n *   {'annotations[1]': d, 'annotations[2]': null} (b is item 2 after adding d)\r\n * - add a new item d between a and b, and edit b:\r\n *    {'annotations[1]': d, 'annotations[2].x': newX} (b is item 2 after adding d)\r\n * - delete b and edit c:\r\n *    {'annotations[1]': null, 'annotations[2].x': newX} (c is edited before b is removed)\r\n *\r\n * You CANNOT combine adding/deleting an item at index `i` with edits to the same index `i`\r\n * You CANNOT combine replacing/deleting the whole array with anything else (for the same array).\r\n *\r\n * @param {HTMLDivElement} gd\r\n *  the DOM element of the graph container div\r\n * @param {Lib.nestedProperty} componentType: the array we are editing\r\n * @param {Object} edits\r\n *  the changes to make; keys are indices to edit, values are themselves objects:\r\n *  {attr: newValue} of changes to make to that index (with add/remove behavior\r\n *  in special values of the empty attr)\r\n * @param {Object} flags\r\n *  the flags for which actions we're going to perform to display these (and\r\n *  any other) changes. If we're already `recalc`ing, we don't need to redraw\r\n *  individual items\r\n * @param {function} _nestedProperty\r\n *  a (possibly modified for gui edits) nestedProperty constructor\r\n *  The modified version takes a 3rd argument, for a prefix to the attribute\r\n *  string necessary for storing GUI edits\r\n *\r\n * @returns {bool} `true` if it managed to complete drawing of the changes\r\n *  `false` would mean the parent should replot.\r\n */\r\nexports.applyContainerArrayChanges = function applyContainerArrayChanges(gd, np, edits, flags, _nestedProperty) {\r\n    var componentType = np.astr;\r\n    var supplyComponentDefaults = Registry.getComponentMethod(componentType, 'supplyLayoutDefaults');\r\n    var draw = Registry.getComponentMethod(componentType, 'draw');\r\n    var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\r\n    var replotLater = flags.replot || flags.recalc || (supplyComponentDefaults === noop) || (draw === noop);\r\n    var layout = gd.layout;\r\n    var fullLayout = gd._fullLayout;\r\n\r\n    if(edits['']) {\r\n        if(Object.keys(edits).length > 1) {\r\n            Loggers.warn('Full array edits are incompatible with other edits',\r\n                componentType);\r\n        }\r\n\r\n        var fullVal = edits[''][''];\r\n\r\n        if(isRemoveVal(fullVal)) np.set(null);\r\n        else if(Array.isArray(fullVal)) np.set(fullVal);\r\n        else {\r\n            Loggers.warn('Unrecognized full array edit value', componentType, fullVal);\r\n            return true;\r\n        }\r\n\r\n        if(replotLater) return false;\r\n\r\n        supplyComponentDefaults(layout, fullLayout);\r\n        draw(gd);\r\n        return true;\r\n    }\r\n\r\n    var componentNums = Object.keys(edits).map(Number).sort(sorterAsc);\r\n    var componentArrayIn = np.get();\r\n    var componentArray = componentArrayIn || [];\r\n    // componentArrayFull is used just to keep splices in line between\r\n    // full and input arrays, so private keys can be copied over after\r\n    // redoing supplyDefaults\r\n    // TODO: this assumes componentArray is in gd.layout - which will not be\r\n    // true after we extend this to restyle\r\n    var componentArrayFull = _nestedProperty(fullLayout, componentType).get();\r\n\r\n    var deletes = [];\r\n    var firstIndexChange = -1;\r\n    var maxIndex = componentArray.length;\r\n    var i;\r\n    var j;\r\n    var componentNum;\r\n    var objEdits;\r\n    var objKeys;\r\n    var objVal;\r\n    var adding, prefix;\r\n\r\n    // first make the add and edit changes\r\n    for(i = 0; i < componentNums.length; i++) {\r\n        componentNum = componentNums[i];\r\n        objEdits = edits[componentNum];\r\n        objKeys = Object.keys(objEdits);\r\n        objVal = objEdits[''],\r\n        adding = isAddVal(objVal);\r\n\r\n        if(componentNum < 0 || componentNum > componentArray.length - (adding ? 0 : 1)) {\r\n            Loggers.warn('index out of range', componentType, componentNum);\r\n            continue;\r\n        }\r\n\r\n        if(objVal !== undefined) {\r\n            if(objKeys.length > 1) {\r\n                Loggers.warn(\r\n                    'Insertion & removal are incompatible with edits to the same index.',\r\n                    componentType, componentNum);\r\n            }\r\n\r\n            if(isRemoveVal(objVal)) {\r\n                deletes.push(componentNum);\r\n            } else if(adding) {\r\n                if(objVal === 'add') objVal = {};\r\n                componentArray.splice(componentNum, 0, objVal);\r\n                if(componentArrayFull) componentArrayFull.splice(componentNum, 0, {});\r\n            } else {\r\n                Loggers.warn('Unrecognized full object edit value',\r\n                    componentType, componentNum, objVal);\r\n            }\r\n\r\n            if(firstIndexChange === -1) firstIndexChange = componentNum;\r\n        } else {\r\n            for(j = 0; j < objKeys.length; j++) {\r\n                prefix = componentType + '[' + componentNum + '].';\r\n                _nestedProperty(componentArray[componentNum], objKeys[j], prefix)\r\n                    .set(objEdits[objKeys[j]]);\r\n            }\r\n        }\r\n    }\r\n\r\n    // now do deletes\r\n    for(i = deletes.length - 1; i >= 0; i--) {\r\n        componentArray.splice(deletes[i], 1);\r\n        // TODO: this drops private keys that had been stored in componentArrayFull\r\n        // does this have any ill effects?\r\n        if(componentArrayFull) componentArrayFull.splice(deletes[i], 1);\r\n    }\r\n\r\n    if(!componentArray.length) np.set(null);\r\n    else if(!componentArrayIn) np.set(componentArray);\r\n\r\n    if(replotLater) return false;\r\n\r\n    supplyComponentDefaults(layout, fullLayout);\r\n\r\n    // finally draw all the components we need to\r\n    // if we added or removed any, redraw all after it\r\n    if(drawOne !== noop) {\r\n        var indicesToDraw;\r\n        if(firstIndexChange === -1) {\r\n            // there's no re-indexing to do, so only redraw components that changed\r\n            indicesToDraw = componentNums;\r\n        } else {\r\n            // in case the component array was shortened, we still need do call\r\n            // drawOne on the latter items so they get properly removed\r\n            maxIndex = Math.max(componentArray.length, maxIndex);\r\n            indicesToDraw = [];\r\n            for(i = 0; i < componentNums.length; i++) {\r\n                componentNum = componentNums[i];\r\n                if(componentNum >= firstIndexChange) break;\r\n                indicesToDraw.push(componentNum);\r\n            }\r\n            for(i = firstIndexChange; i < maxIndex; i++) {\r\n                indicesToDraw.push(i);\r\n            }\r\n        }\r\n        for(i = 0; i < indicesToDraw.length; i++) {\r\n            drawOne(gd, indicesToDraw[i]);\r\n        }\r\n    } else draw(gd);\r\n\r\n    return true;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar constants = require('./constants');\n\nmodule.exports = function findAllPaths(pathinfo, xtol, ytol) {\n  var cnt, startLoc, i, pi, j; // Default just passes these values through as they were before:\n\n  xtol = xtol || 0.01;\n  ytol = ytol || 0.01;\n\n  for (i = 0; i < pathinfo.length; i++) {\n    pi = pathinfo[i];\n\n    for (j = 0; j < pi.starts.length; j++) {\n      startLoc = pi.starts[j];\n      makePath(pi, startLoc, 'edge', xtol, ytol);\n    }\n\n    cnt = 0;\n\n    while (Object.keys(pi.crossings).length && cnt < 10000) {\n      cnt++;\n      startLoc = Object.keys(pi.crossings)[0].split(',').map(Number);\n      makePath(pi, startLoc, undefined, xtol, ytol);\n    }\n\n    if (cnt === 10000) Lib.log('Infinite loop in contour?');\n  }\n};\n\nfunction equalPts(pt1, pt2, xtol, ytol) {\n  return Math.abs(pt1[0] - pt2[0]) < xtol && Math.abs(pt1[1] - pt2[1]) < ytol;\n} // distance in index units - uses the 3rd and 4th items in points\n\n\nfunction ptDist(pt1, pt2) {\n  var dx = pt1[2] - pt2[2];\n  var dy = pt1[3] - pt2[3];\n  return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction makePath(pi, loc, edgeflag, xtol, ytol) {\n  var locStr = loc.join(',');\n  var mi = pi.crossings[locStr];\n  var marchStep = getStartStep(mi, edgeflag, loc); // start by going backward a half step and finding the crossing point\n\n  var pts = [getInterpPx(pi, loc, [-marchStep[0], -marchStep[1]])];\n  var m = pi.z.length;\n  var n = pi.z[0].length;\n  var startLoc = loc.slice();\n  var startStep = marchStep.slice();\n  var cnt; // now follow the path\n\n  for (cnt = 0; cnt < 10000; cnt++) {\n    // just to avoid infinite loops\n    if (mi > 20) {\n      mi = constants.CHOOSESADDLE[mi][(marchStep[0] || marchStep[1]) < 0 ? 0 : 1];\n      pi.crossings[locStr] = constants.SADDLEREMAINDER[mi];\n    } else {\n      delete pi.crossings[locStr];\n    }\n\n    marchStep = constants.NEWDELTA[mi];\n\n    if (!marchStep) {\n      Lib.log('Found bad marching index:', mi, loc, pi.level);\n      break;\n    } // find the crossing a half step forward, and then take the full step\n\n\n    pts.push(getInterpPx(pi, loc, marchStep));\n    loc[0] += marchStep[0];\n    loc[1] += marchStep[1];\n    locStr = loc.join(','); // don't include the same point multiple times\n\n    if (equalPts(pts[pts.length - 1], pts[pts.length - 2], xtol, ytol)) pts.pop();\n    var atEdge = marchStep[0] && (loc[0] < 0 || loc[0] > n - 2) || marchStep[1] && (loc[1] < 0 || loc[1] > m - 2);\n    var closedLoop = loc[0] === startLoc[0] && loc[1] === startLoc[1] && marchStep[0] === startStep[0] && marchStep[1] === startStep[1]; // have we completed a loop, or reached an edge?\n\n    if (closedLoop || edgeflag && atEdge) break;\n    mi = pi.crossings[locStr];\n  }\n\n  if (cnt === 10000) {\n    Lib.log('Infinite loop in contour?');\n  }\n\n  var closedpath = equalPts(pts[0], pts[pts.length - 1], xtol, ytol);\n  var totaldist = 0;\n  var distThresholdFactor = 0.2 * pi.smoothing;\n  var alldists = [];\n  var cropstart = 0;\n  var distgroup, cnt2, cnt3, newpt, ptcnt, ptavg, thisdist, i, j, edgepathi, edgepathj;\n  /*\r\n   * Check for points that are too close together (<1/5 the average dist\r\n   * *in grid index units* (important for log axes and nonuniform grids),\r\n   * less if less smoothed) and just take the center (or avg of center 2).\r\n   * This cuts down on funny behavior when a point is very close to a\r\n   * contour level.\r\n   */\n\n  for (cnt = 1; cnt < pts.length; cnt++) {\n    thisdist = ptDist(pts[cnt], pts[cnt - 1]);\n    totaldist += thisdist;\n    alldists.push(thisdist);\n  }\n\n  var distThreshold = totaldist / alldists.length * distThresholdFactor;\n\n  function getpt(i) {\n    return pts[i % pts.length];\n  }\n\n  for (cnt = pts.length - 2; cnt >= cropstart; cnt--) {\n    distgroup = alldists[cnt];\n\n    if (distgroup < distThreshold) {\n      cnt3 = 0;\n\n      for (cnt2 = cnt - 1; cnt2 >= cropstart; cnt2--) {\n        if (distgroup + alldists[cnt2] < distThreshold) {\n          distgroup += alldists[cnt2];\n        } else break;\n      } // closed path with close points wrapping around the boundary?\n\n\n      if (closedpath && cnt === pts.length - 2) {\n        for (cnt3 = 0; cnt3 < cnt2; cnt3++) {\n          if (distgroup + alldists[cnt3] < distThreshold) {\n            distgroup += alldists[cnt3];\n          } else break;\n        }\n      }\n\n      ptcnt = cnt - cnt2 + cnt3 + 1;\n      ptavg = Math.floor((cnt + cnt2 + cnt3 + 2) / 2); // either endpoint included: keep the endpoint\n\n      if (!closedpath && cnt === pts.length - 2) newpt = pts[pts.length - 1];else if (!closedpath && cnt2 === -1) newpt = pts[0]; // odd # of points - just take the central one\n      else if (ptcnt % 2) newpt = getpt(ptavg); // even # of pts - average central two\n        else {\n            newpt = [(getpt(ptavg)[0] + getpt(ptavg + 1)[0]) / 2, (getpt(ptavg)[1] + getpt(ptavg + 1)[1]) / 2];\n          }\n      pts.splice(cnt2 + 1, cnt - cnt2 + 1, newpt);\n      cnt = cnt2 + 1;\n      if (cnt3) cropstart = cnt3;\n\n      if (closedpath) {\n        if (cnt === pts.length - 2) pts[cnt3] = pts[pts.length - 1];else if (cnt === 0) pts[pts.length - 1] = pts[0];\n      }\n    }\n  }\n\n  pts.splice(0, cropstart); // done with the index parts - remove them so path generation works right\n  // because it depends on only having [xpx, ypx]\n\n  for (cnt = 0; cnt < pts.length; cnt++) pts[cnt].length = 2; // don't return single-point paths (ie all points were the same\n  // so they got deleted?)\n\n\n  if (pts.length < 2) return;else if (closedpath) {\n    pts.pop();\n    pi.paths.push(pts);\n  } else {\n    if (!edgeflag) {\n      Lib.log('Unclosed interior contour?', pi.level, startLoc.join(','), pts.join('L'));\n    } // edge path - does it start where an existing edge path ends, or vice versa?\n\n\n    var merged = false;\n\n    for (i = 0; i < pi.edgepaths.length; i++) {\n      edgepathi = pi.edgepaths[i];\n\n      if (!merged && equalPts(edgepathi[0], pts[pts.length - 1], xtol, ytol)) {\n        pts.pop();\n        merged = true; // now does it ALSO meet the end of another (or the same) path?\n\n        var doublemerged = false;\n\n        for (j = 0; j < pi.edgepaths.length; j++) {\n          edgepathj = pi.edgepaths[j];\n\n          if (equalPts(edgepathj[edgepathj.length - 1], pts[0], xtol, ytol)) {\n            doublemerged = true;\n            pts.shift();\n            pi.edgepaths.splice(i, 1);\n\n            if (j === i) {\n              // the path is now closed\n              pi.paths.push(pts.concat(edgepathj));\n            } else {\n              if (j > i) j--;\n              pi.edgepaths[j] = edgepathj.concat(pts, edgepathi);\n            }\n\n            break;\n          }\n        }\n\n        if (!doublemerged) {\n          pi.edgepaths[i] = pts.concat(edgepathi);\n        }\n      }\n    }\n\n    for (i = 0; i < pi.edgepaths.length; i++) {\n      if (merged) break;\n      edgepathi = pi.edgepaths[i];\n\n      if (equalPts(edgepathi[edgepathi.length - 1], pts[0], xtol, ytol)) {\n        pts.shift();\n        pi.edgepaths[i] = edgepathi.concat(pts);\n        merged = true;\n      }\n    }\n\n    if (!merged) pi.edgepaths.push(pts);\n  }\n} // special function to get the marching step of the\n// first point in the path (leading to loc)\n\n\nfunction getStartStep(mi, edgeflag, loc) {\n  var dx = 0;\n  var dy = 0;\n\n  if (mi > 20 && edgeflag) {\n    // these saddles start at +/- x\n    if (mi === 208 || mi === 1114) {\n      // if we're starting at the left side, we must be going right\n      dx = loc[0] === 0 ? 1 : -1;\n    } else {\n      // if we're starting at the bottom, we must be going up\n      dy = loc[1] === 0 ? 1 : -1;\n    }\n  } else if (constants.BOTTOMSTART.indexOf(mi) !== -1) dy = 1;else if (constants.LEFTSTART.indexOf(mi) !== -1) dx = 1;else if (constants.TOPSTART.indexOf(mi) !== -1) dy = -1;else dx = -1;\n\n  return [dx, dy];\n}\n/*\r\n * Find the pixel coordinates of a particular crossing\r\n *\r\n * @param {object} pi: the pathinfo object at this level\r\n * @param {array} loc: the grid index [x, y] of the crossing\r\n * @param {array} step: the direction [dx, dy] we're moving on the grid\r\n *\r\n * @return {array} [xpx, ypx, xi, yi]: the first two are the pixel location,\r\n *   the next two are the interpolated grid indices, which we use for\r\n *   distance calculations to delete points that are too close together.\r\n *   This is important when the grid is nonuniform (and most dramatically when\r\n *   we're on log axes and include invalid (0 or negative) values.\r\n *   It's crucial to delete these extra two before turning an array of these\r\n *   points into a path, because those routines require length-2 points.\r\n */\n\n\nfunction getInterpPx(pi, loc, step) {\n  var locx = loc[0] + Math.max(step[0], 0);\n  var locy = loc[1] + Math.max(step[1], 0);\n  var zxy = pi.z[locy][locx];\n  var xa = pi.xaxis;\n  var ya = pi.yaxis;\n\n  if (step[1]) {\n    var dx = (pi.level - zxy) / (pi.z[locy][locx + 1] - zxy);\n    return [xa.c2p((1 - dx) * pi.x[locx] + dx * pi.x[locx + 1], true), ya.c2p(pi.y[locy], true), locx + dx, locy];\n  } else {\n    var dy = (pi.level - zxy) / (pi.z[locy + 1][locx] - zxy);\n    return [xa.c2p(pi.x[locx], true), ya.c2p((1 - dy) * pi.y[locy] + dy * pi.y[locy + 1], true), locx, locy + dy];\n  }\n}","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/traces/contour/find_all_paths.js"],"names":["Lib","require","constants","module","exports","findAllPaths","pathinfo","xtol","ytol","cnt","startLoc","i","pi","j","length","starts","makePath","Object","keys","crossings","split","map","Number","undefined","log","equalPts","pt1","pt2","Math","abs","ptDist","dx","dy","sqrt","loc","edgeflag","locStr","join","mi","marchStep","getStartStep","pts","getInterpPx","m","z","n","slice","startStep","CHOOSESADDLE","SADDLEREMAINDER","NEWDELTA","level","push","pop","atEdge","closedLoop","closedpath","totaldist","distThresholdFactor","smoothing","alldists","cropstart","distgroup","cnt2","cnt3","newpt","ptcnt","ptavg","thisdist","edgepathi","edgepathj","distThreshold","getpt","floor","splice","paths","merged","edgepaths","doublemerged","shift","concat","BOTTOMSTART","indexOf","LEFTSTART","TOPSTART","step","locx","max","locy","zxy","xa","xaxis","ya","yaxis","c2p","x","y"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar Lib = require('../../lib');\r\nvar constants = require('./constants');\r\n\r\nmodule.exports = function findAllPaths(pathinfo, xtol, ytol) {\r\n    var cnt,\r\n        startLoc,\r\n        i,\r\n        pi,\r\n        j;\r\n\r\n    // Default just passes these values through as they were before:\r\n    xtol = xtol || 0.01;\r\n    ytol = ytol || 0.01;\r\n\r\n    for(i = 0; i < pathinfo.length; i++) {\r\n        pi = pathinfo[i];\r\n\r\n        for(j = 0; j < pi.starts.length; j++) {\r\n            startLoc = pi.starts[j];\r\n            makePath(pi, startLoc, 'edge', xtol, ytol);\r\n        }\r\n\r\n        cnt = 0;\r\n        while(Object.keys(pi.crossings).length && cnt < 10000) {\r\n            cnt++;\r\n            startLoc = Object.keys(pi.crossings)[0].split(',').map(Number);\r\n            makePath(pi, startLoc, undefined, xtol, ytol);\r\n        }\r\n        if(cnt === 10000) Lib.log('Infinite loop in contour?');\r\n    }\r\n};\r\n\r\nfunction equalPts(pt1, pt2, xtol, ytol) {\r\n    return Math.abs(pt1[0] - pt2[0]) < xtol &&\r\n           Math.abs(pt1[1] - pt2[1]) < ytol;\r\n}\r\n\r\n// distance in index units - uses the 3rd and 4th items in points\r\nfunction ptDist(pt1, pt2) {\r\n    var dx = pt1[2] - pt2[2];\r\n    var dy = pt1[3] - pt2[3];\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n\r\nfunction makePath(pi, loc, edgeflag, xtol, ytol) {\r\n    var locStr = loc.join(',');\r\n    var mi = pi.crossings[locStr];\r\n    var marchStep = getStartStep(mi, edgeflag, loc);\r\n    // start by going backward a half step and finding the crossing point\r\n    var pts = [getInterpPx(pi, loc, [-marchStep[0], -marchStep[1]])];\r\n    var m = pi.z.length;\r\n    var n = pi.z[0].length;\r\n    var startLoc = loc.slice();\r\n    var startStep = marchStep.slice();\r\n    var cnt;\r\n\r\n    // now follow the path\r\n    for(cnt = 0; cnt < 10000; cnt++) { // just to avoid infinite loops\r\n        if(mi > 20) {\r\n            mi = constants.CHOOSESADDLE[mi][(marchStep[0] || marchStep[1]) < 0 ? 0 : 1];\r\n            pi.crossings[locStr] = constants.SADDLEREMAINDER[mi];\r\n        } else {\r\n            delete pi.crossings[locStr];\r\n        }\r\n\r\n        marchStep = constants.NEWDELTA[mi];\r\n        if(!marchStep) {\r\n            Lib.log('Found bad marching index:', mi, loc, pi.level);\r\n            break;\r\n        }\r\n\r\n        // find the crossing a half step forward, and then take the full step\r\n        pts.push(getInterpPx(pi, loc, marchStep));\r\n        loc[0] += marchStep[0];\r\n        loc[1] += marchStep[1];\r\n        locStr = loc.join(',');\r\n\r\n        // don't include the same point multiple times\r\n        if(equalPts(pts[pts.length - 1], pts[pts.length - 2], xtol, ytol)) pts.pop();\r\n\r\n        var atEdge = (marchStep[0] && (loc[0] < 0 || loc[0] > n - 2)) ||\r\n                (marchStep[1] && (loc[1] < 0 || loc[1] > m - 2));\r\n\r\n        var closedLoop = loc[0] === startLoc[0] && loc[1] === startLoc[1] &&\r\n                marchStep[0] === startStep[0] && marchStep[1] === startStep[1];\r\n\r\n        // have we completed a loop, or reached an edge?\r\n        if((closedLoop) || (edgeflag && atEdge)) break;\r\n\r\n        mi = pi.crossings[locStr];\r\n    }\r\n\r\n    if(cnt === 10000) {\r\n        Lib.log('Infinite loop in contour?');\r\n    }\r\n    var closedpath = equalPts(pts[0], pts[pts.length - 1], xtol, ytol);\r\n    var totaldist = 0;\r\n    var distThresholdFactor = 0.2 * pi.smoothing;\r\n    var alldists = [];\r\n    var cropstart = 0;\r\n    var distgroup, cnt2, cnt3, newpt, ptcnt, ptavg, thisdist,\r\n        i, j, edgepathi, edgepathj;\r\n\r\n    /*\r\n     * Check for points that are too close together (<1/5 the average dist\r\n     * *in grid index units* (important for log axes and nonuniform grids),\r\n     * less if less smoothed) and just take the center (or avg of center 2).\r\n     * This cuts down on funny behavior when a point is very close to a\r\n     * contour level.\r\n     */\r\n    for(cnt = 1; cnt < pts.length; cnt++) {\r\n        thisdist = ptDist(pts[cnt], pts[cnt - 1]);\r\n        totaldist += thisdist;\r\n        alldists.push(thisdist);\r\n    }\r\n\r\n    var distThreshold = totaldist / alldists.length * distThresholdFactor;\r\n\r\n    function getpt(i) { return pts[i % pts.length]; }\r\n\r\n    for(cnt = pts.length - 2; cnt >= cropstart; cnt--) {\r\n        distgroup = alldists[cnt];\r\n        if(distgroup < distThreshold) {\r\n            cnt3 = 0;\r\n            for(cnt2 = cnt - 1; cnt2 >= cropstart; cnt2--) {\r\n                if(distgroup + alldists[cnt2] < distThreshold) {\r\n                    distgroup += alldists[cnt2];\r\n                } else break;\r\n            }\r\n\r\n            // closed path with close points wrapping around the boundary?\r\n            if(closedpath && cnt === pts.length - 2) {\r\n                for(cnt3 = 0; cnt3 < cnt2; cnt3++) {\r\n                    if(distgroup + alldists[cnt3] < distThreshold) {\r\n                        distgroup += alldists[cnt3];\r\n                    } else break;\r\n                }\r\n            }\r\n            ptcnt = cnt - cnt2 + cnt3 + 1;\r\n            ptavg = Math.floor((cnt + cnt2 + cnt3 + 2) / 2);\r\n\r\n            // either endpoint included: keep the endpoint\r\n            if(!closedpath && cnt === pts.length - 2) newpt = pts[pts.length - 1];\r\n            else if(!closedpath && cnt2 === -1) newpt = pts[0];\r\n\r\n            // odd # of points - just take the central one\r\n            else if(ptcnt % 2) newpt = getpt(ptavg);\r\n\r\n            // even # of pts - average central two\r\n            else {\r\n                newpt = [(getpt(ptavg)[0] + getpt(ptavg + 1)[0]) / 2,\r\n                    (getpt(ptavg)[1] + getpt(ptavg + 1)[1]) / 2];\r\n            }\r\n\r\n            pts.splice(cnt2 + 1, cnt - cnt2 + 1, newpt);\r\n            cnt = cnt2 + 1;\r\n            if(cnt3) cropstart = cnt3;\r\n            if(closedpath) {\r\n                if(cnt === pts.length - 2) pts[cnt3] = pts[pts.length - 1];\r\n                else if(cnt === 0) pts[pts.length - 1] = pts[0];\r\n            }\r\n        }\r\n    }\r\n    pts.splice(0, cropstart);\r\n\r\n    // done with the index parts - remove them so path generation works right\r\n    // because it depends on only having [xpx, ypx]\r\n    for(cnt = 0; cnt < pts.length; cnt++) pts[cnt].length = 2;\r\n\r\n    // don't return single-point paths (ie all points were the same\r\n    // so they got deleted?)\r\n    if(pts.length < 2) return;\r\n    else if(closedpath) {\r\n        pts.pop();\r\n        pi.paths.push(pts);\r\n    } else {\r\n        if(!edgeflag) {\r\n            Lib.log('Unclosed interior contour?',\r\n                pi.level, startLoc.join(','), pts.join('L'));\r\n        }\r\n\r\n        // edge path - does it start where an existing edge path ends, or vice versa?\r\n        var merged = false;\r\n        for(i = 0; i < pi.edgepaths.length; i++) {\r\n            edgepathi = pi.edgepaths[i];\r\n            if(!merged && equalPts(edgepathi[0], pts[pts.length - 1], xtol, ytol)) {\r\n                pts.pop();\r\n                merged = true;\r\n\r\n                // now does it ALSO meet the end of another (or the same) path?\r\n                var doublemerged = false;\r\n                for(j = 0; j < pi.edgepaths.length; j++) {\r\n                    edgepathj = pi.edgepaths[j];\r\n                    if(equalPts(edgepathj[edgepathj.length - 1], pts[0], xtol, ytol)) {\r\n                        doublemerged = true;\r\n                        pts.shift();\r\n                        pi.edgepaths.splice(i, 1);\r\n                        if(j === i) {\r\n                            // the path is now closed\r\n                            pi.paths.push(pts.concat(edgepathj));\r\n                        } else {\r\n                            if(j > i) j--;\r\n                            pi.edgepaths[j] = edgepathj.concat(pts, edgepathi);\r\n                        }\r\n                        break;\r\n                    }\r\n                }\r\n                if(!doublemerged) {\r\n                    pi.edgepaths[i] = pts.concat(edgepathi);\r\n                }\r\n            }\r\n        }\r\n        for(i = 0; i < pi.edgepaths.length; i++) {\r\n            if(merged) break;\r\n            edgepathi = pi.edgepaths[i];\r\n            if(equalPts(edgepathi[edgepathi.length - 1], pts[0], xtol, ytol)) {\r\n                pts.shift();\r\n                pi.edgepaths[i] = edgepathi.concat(pts);\r\n                merged = true;\r\n            }\r\n        }\r\n\r\n        if(!merged) pi.edgepaths.push(pts);\r\n    }\r\n}\r\n\r\n// special function to get the marching step of the\r\n// first point in the path (leading to loc)\r\nfunction getStartStep(mi, edgeflag, loc) {\r\n    var dx = 0;\r\n    var dy = 0;\r\n    if(mi > 20 && edgeflag) {\r\n        // these saddles start at +/- x\r\n        if(mi === 208 || mi === 1114) {\r\n            // if we're starting at the left side, we must be going right\r\n            dx = loc[0] === 0 ? 1 : -1;\r\n        } else {\r\n            // if we're starting at the bottom, we must be going up\r\n            dy = loc[1] === 0 ? 1 : -1;\r\n        }\r\n    } else if(constants.BOTTOMSTART.indexOf(mi) !== -1) dy = 1;\r\n    else if(constants.LEFTSTART.indexOf(mi) !== -1) dx = 1;\r\n    else if(constants.TOPSTART.indexOf(mi) !== -1) dy = -1;\r\n    else dx = -1;\r\n    return [dx, dy];\r\n}\r\n\r\n/*\r\n * Find the pixel coordinates of a particular crossing\r\n *\r\n * @param {object} pi: the pathinfo object at this level\r\n * @param {array} loc: the grid index [x, y] of the crossing\r\n * @param {array} step: the direction [dx, dy] we're moving on the grid\r\n *\r\n * @return {array} [xpx, ypx, xi, yi]: the first two are the pixel location,\r\n *   the next two are the interpolated grid indices, which we use for\r\n *   distance calculations to delete points that are too close together.\r\n *   This is important when the grid is nonuniform (and most dramatically when\r\n *   we're on log axes and include invalid (0 or negative) values.\r\n *   It's crucial to delete these extra two before turning an array of these\r\n *   points into a path, because those routines require length-2 points.\r\n */\r\nfunction getInterpPx(pi, loc, step) {\r\n    var locx = loc[0] + Math.max(step[0], 0);\r\n    var locy = loc[1] + Math.max(step[1], 0);\r\n    var zxy = pi.z[locy][locx];\r\n    var xa = pi.xaxis;\r\n    var ya = pi.yaxis;\r\n\r\n    if(step[1]) {\r\n        var dx = (pi.level - zxy) / (pi.z[locy][locx + 1] - zxy);\r\n\r\n        return [xa.c2p((1 - dx) * pi.x[locx] + dx * pi.x[locx + 1], true),\r\n            ya.c2p(pi.y[locy], true),\r\n            locx + dx, locy];\r\n    } else {\r\n        var dy = (pi.level - zxy) / (pi.z[locy + 1][locx] - zxy);\r\n        return [xa.c2p(pi.x[locx], true),\r\n            ya.c2p((1 - dy) * pi.y[locy] + dy * pi.y[locy + 1], true),\r\n            locx, locy + dy];\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar Lib = require('../lib');\n\nvar dfltConfig = require('../plot_api/plot_config').dfltConfig;\n/**\r\n * Copy arg array *without* removing `undefined` values from objects.\r\n *\r\n * @param gd\r\n * @param args\r\n * @returns {Array}\r\n */\n\n\nfunction copyArgArray(gd, args) {\n  var copy = [];\n  var arg;\n\n  for (var i = 0; i < args.length; i++) {\n    arg = args[i];\n    if (arg === gd) copy[i] = arg;else if (typeof arg === 'object') {\n      copy[i] = Array.isArray(arg) ? Lib.extendDeep([], arg) : Lib.extendDeepAll({}, arg);\n    } else copy[i] = arg;\n  }\n\n  return copy;\n} // -----------------------------------------------------\n// Undo/Redo queue for plots\n// -----------------------------------------------------\n\n\nvar queue = {}; // TODO: disable/enable undo and redo buttons appropriately\n\n/**\r\n * Add an item to the undoQueue for a graphDiv\r\n *\r\n * @param gd\r\n * @param undoFunc Function undo this operation\r\n * @param undoArgs Args to supply undoFunc with\r\n * @param redoFunc Function to redo this operation\r\n * @param redoArgs Args to supply redoFunc with\r\n */\n\nqueue.add = function (gd, undoFunc, undoArgs, redoFunc, redoArgs) {\n  var queueObj, queueIndex; // make sure we have the queue and our position in it\n\n  gd.undoQueue = gd.undoQueue || {\n    index: 0,\n    queue: [],\n    sequence: false\n  };\n  queueIndex = gd.undoQueue.index; // if we're already playing an undo or redo, or if this is an auto operation\n  // (like pane resize... any others?) then we don't save this to the undo queue\n\n  if (gd.autoplay) {\n    if (!gd.undoQueue.inSequence) gd.autoplay = false;\n    return;\n  } // if we're not in a sequence or are just starting, we need a new queue item\n\n\n  if (!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {\n    queueObj = {\n      undo: {\n        calls: [],\n        args: []\n      },\n      redo: {\n        calls: [],\n        args: []\n      }\n    };\n    gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);\n    gd.undoQueue.index += 1;\n  } else {\n    queueObj = gd.undoQueue.queue[queueIndex - 1];\n  }\n\n  gd.undoQueue.beginSequence = false; // we unshift to handle calls for undo in a forward for loop later\n\n  if (queueObj) {\n    queueObj.undo.calls.unshift(undoFunc);\n    queueObj.undo.args.unshift(undoArgs);\n    queueObj.redo.calls.push(redoFunc);\n    queueObj.redo.args.push(redoArgs);\n  }\n\n  if (gd.undoQueue.queue.length > dfltConfig.queueLength) {\n    gd.undoQueue.queue.shift();\n    gd.undoQueue.index--;\n  }\n};\n/**\r\n * Begin a sequence of undoQueue changes\r\n *\r\n * @param gd\r\n */\n\n\nqueue.startSequence = function (gd) {\n  gd.undoQueue = gd.undoQueue || {\n    index: 0,\n    queue: [],\n    sequence: false\n  };\n  gd.undoQueue.sequence = true;\n  gd.undoQueue.beginSequence = true;\n};\n/**\r\n * Stop a sequence of undoQueue changes\r\n *\r\n * Call this *after* you're sure your undo chain has ended\r\n *\r\n * @param gd\r\n */\n\n\nqueue.stopSequence = function (gd) {\n  gd.undoQueue = gd.undoQueue || {\n    index: 0,\n    queue: [],\n    sequence: false\n  };\n  gd.undoQueue.sequence = false;\n  gd.undoQueue.beginSequence = false;\n};\n/**\r\n * Move one step back in the undo queue, and undo the object there.\r\n *\r\n * @param gd\r\n */\n\n\nqueue.undo = function undo(gd) {\n  var queueObj, i;\n\n  if (gd.undoQueue === undefined || isNaN(gd.undoQueue.index) || gd.undoQueue.index <= 0) {\n    return;\n  } // index is pointing to next *forward* queueObj, point to the one we're undoing\n\n\n  gd.undoQueue.index--; // get the queueObj for instructions on how to undo\n\n  queueObj = gd.undoQueue.queue[gd.undoQueue.index]; // this sequence keeps things from adding to the queue during undo/redo\n\n  gd.undoQueue.inSequence = true;\n\n  for (i = 0; i < queueObj.undo.calls.length; i++) {\n    queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);\n  }\n\n  gd.undoQueue.inSequence = false;\n  gd.autoplay = false;\n};\n/**\r\n * Redo the current object in the undo, then move forward in the queue.\r\n *\r\n * @param gd\r\n */\n\n\nqueue.redo = function redo(gd) {\n  var queueObj, i;\n\n  if (gd.undoQueue === undefined || isNaN(gd.undoQueue.index) || gd.undoQueue.index >= gd.undoQueue.queue.length) {\n    return;\n  } // get the queueObj for instructions on how to undo\n\n\n  queueObj = gd.undoQueue.queue[gd.undoQueue.index]; // this sequence keeps things from adding to the queue during undo/redo\n\n  gd.undoQueue.inSequence = true;\n\n  for (i = 0; i < queueObj.redo.calls.length; i++) {\n    queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);\n  }\n\n  gd.undoQueue.inSequence = false;\n  gd.autoplay = false; // index is pointing to the thing we just redid, move it\n\n  gd.undoQueue.index++;\n};\n/**\r\n * Called by undo/redo to make the actual changes.\r\n *\r\n * Not meant to be called publically, but included for mocking out in tests.\r\n *\r\n * @param gd\r\n * @param func\r\n * @param args\r\n */\n\n\nqueue.plotDo = function (gd, func, args) {\n  gd.autoplay = true; // this *won't* copy gd and it preserves `undefined` properties!\n\n  args = copyArgArray(gd, args); // call the supplied function\n\n  func.apply(null, args);\n};\n\nmodule.exports = queue;","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/lib/queue.js"],"names":["Lib","require","dfltConfig","copyArgArray","gd","args","copy","arg","i","length","Array","isArray","extendDeep","extendDeepAll","queue","add","undoFunc","undoArgs","redoFunc","redoArgs","queueObj","queueIndex","undoQueue","index","sequence","autoplay","inSequence","beginSequence","undo","calls","redo","splice","unshift","push","queueLength","shift","startSequence","stopSequence","undefined","isNaN","plotDo","func","apply","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar Lib = require('../lib');\r\nvar dfltConfig = require('../plot_api/plot_config').dfltConfig;\r\n\r\n/**\r\n * Copy arg array *without* removing `undefined` values from objects.\r\n *\r\n * @param gd\r\n * @param args\r\n * @returns {Array}\r\n */\r\nfunction copyArgArray(gd, args) {\r\n    var copy = [];\r\n    var arg;\r\n\r\n    for(var i = 0; i < args.length; i++) {\r\n        arg = args[i];\r\n\r\n        if(arg === gd) copy[i] = arg;\r\n        else if(typeof arg === 'object') {\r\n            copy[i] = Array.isArray(arg) ?\r\n                Lib.extendDeep([], arg) :\r\n                Lib.extendDeepAll({}, arg);\r\n        } else copy[i] = arg;\r\n    }\r\n\r\n    return copy;\r\n}\r\n\r\n\r\n// -----------------------------------------------------\r\n// Undo/Redo queue for plots\r\n// -----------------------------------------------------\r\n\r\n\r\nvar queue = {};\r\n\r\n// TODO: disable/enable undo and redo buttons appropriately\r\n\r\n/**\r\n * Add an item to the undoQueue for a graphDiv\r\n *\r\n * @param gd\r\n * @param undoFunc Function undo this operation\r\n * @param undoArgs Args to supply undoFunc with\r\n * @param redoFunc Function to redo this operation\r\n * @param redoArgs Args to supply redoFunc with\r\n */\r\nqueue.add = function(gd, undoFunc, undoArgs, redoFunc, redoArgs) {\r\n    var queueObj,\r\n        queueIndex;\r\n\r\n    // make sure we have the queue and our position in it\r\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\r\n    queueIndex = gd.undoQueue.index;\r\n\r\n    // if we're already playing an undo or redo, or if this is an auto operation\r\n    // (like pane resize... any others?) then we don't save this to the undo queue\r\n    if(gd.autoplay) {\r\n        if(!gd.undoQueue.inSequence) gd.autoplay = false;\r\n        return;\r\n    }\r\n\r\n    // if we're not in a sequence or are just starting, we need a new queue item\r\n    if(!gd.undoQueue.sequence || gd.undoQueue.beginSequence) {\r\n        queueObj = {undo: {calls: [], args: []}, redo: {calls: [], args: []}};\r\n        gd.undoQueue.queue.splice(queueIndex, gd.undoQueue.queue.length - queueIndex, queueObj);\r\n        gd.undoQueue.index += 1;\r\n    } else {\r\n        queueObj = gd.undoQueue.queue[queueIndex - 1];\r\n    }\r\n    gd.undoQueue.beginSequence = false;\r\n\r\n    // we unshift to handle calls for undo in a forward for loop later\r\n    if(queueObj) {\r\n        queueObj.undo.calls.unshift(undoFunc);\r\n        queueObj.undo.args.unshift(undoArgs);\r\n        queueObj.redo.calls.push(redoFunc);\r\n        queueObj.redo.args.push(redoArgs);\r\n    }\r\n\r\n    if(gd.undoQueue.queue.length > dfltConfig.queueLength) {\r\n        gd.undoQueue.queue.shift();\r\n        gd.undoQueue.index--;\r\n    }\r\n};\r\n\r\n/**\r\n * Begin a sequence of undoQueue changes\r\n *\r\n * @param gd\r\n */\r\nqueue.startSequence = function(gd) {\r\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\r\n    gd.undoQueue.sequence = true;\r\n    gd.undoQueue.beginSequence = true;\r\n};\r\n\r\n/**\r\n * Stop a sequence of undoQueue changes\r\n *\r\n * Call this *after* you're sure your undo chain has ended\r\n *\r\n * @param gd\r\n */\r\nqueue.stopSequence = function(gd) {\r\n    gd.undoQueue = gd.undoQueue || {index: 0, queue: [], sequence: false};\r\n    gd.undoQueue.sequence = false;\r\n    gd.undoQueue.beginSequence = false;\r\n};\r\n\r\n/**\r\n * Move one step back in the undo queue, and undo the object there.\r\n *\r\n * @param gd\r\n */\r\nqueue.undo = function undo(gd) {\r\n    var queueObj, i;\r\n\r\n    if(gd.undoQueue === undefined ||\r\n            isNaN(gd.undoQueue.index) ||\r\n            gd.undoQueue.index <= 0) {\r\n        return;\r\n    }\r\n\r\n    // index is pointing to next *forward* queueObj, point to the one we're undoing\r\n    gd.undoQueue.index--;\r\n\r\n    // get the queueObj for instructions on how to undo\r\n    queueObj = gd.undoQueue.queue[gd.undoQueue.index];\r\n\r\n    // this sequence keeps things from adding to the queue during undo/redo\r\n    gd.undoQueue.inSequence = true;\r\n    for(i = 0; i < queueObj.undo.calls.length; i++) {\r\n        queue.plotDo(gd, queueObj.undo.calls[i], queueObj.undo.args[i]);\r\n    }\r\n    gd.undoQueue.inSequence = false;\r\n    gd.autoplay = false;\r\n};\r\n\r\n/**\r\n * Redo the current object in the undo, then move forward in the queue.\r\n *\r\n * @param gd\r\n */\r\nqueue.redo = function redo(gd) {\r\n    var queueObj, i;\r\n\r\n    if(gd.undoQueue === undefined ||\r\n            isNaN(gd.undoQueue.index) ||\r\n            gd.undoQueue.index >= gd.undoQueue.queue.length) {\r\n        return;\r\n    }\r\n\r\n    // get the queueObj for instructions on how to undo\r\n    queueObj = gd.undoQueue.queue[gd.undoQueue.index];\r\n\r\n    // this sequence keeps things from adding to the queue during undo/redo\r\n    gd.undoQueue.inSequence = true;\r\n    for(i = 0; i < queueObj.redo.calls.length; i++) {\r\n        queue.plotDo(gd, queueObj.redo.calls[i], queueObj.redo.args[i]);\r\n    }\r\n    gd.undoQueue.inSequence = false;\r\n    gd.autoplay = false;\r\n\r\n    // index is pointing to the thing we just redid, move it\r\n    gd.undoQueue.index++;\r\n};\r\n\r\n/**\r\n * Called by undo/redo to make the actual changes.\r\n *\r\n * Not meant to be called publically, but included for mocking out in tests.\r\n *\r\n * @param gd\r\n * @param func\r\n * @param args\r\n */\r\nqueue.plotDo = function(gd, func, args) {\r\n    gd.autoplay = true;\r\n\r\n    // this *won't* copy gd and it preserves `undefined` properties!\r\n    args = copyArgArray(gd, args);\r\n\r\n    // call the supplied function\r\n    func.apply(null, args);\r\n};\r\n\r\nmodule.exports = queue;\r\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar Lib = require('../../lib');\n\nvar Fx = require('../../components/fx');\n\nvar Registry = require('../../registry');\n\nvar getTraceColor = require('./get_trace_color');\n\nvar Color = require('../../components/color');\n\nvar fillText = Lib.fillText;\n\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\n  var cd = pointData.cd;\n  var trace = cd[0].trace;\n  var xa = pointData.xa;\n  var ya = pointData.ya;\n  var xpx = xa.c2p(xval);\n  var ypx = ya.c2p(yval);\n  var pt = [xpx, ypx];\n  var hoveron = trace.hoveron || '';\n  var minRad = trace.mode.indexOf('markers') !== -1 ? 3 : 0.5; // look for points to hover on first, then take fills only if we\n  // didn't find a point\n\n  if (hoveron.indexOf('points') !== -1) {\n    var dx = function (di) {\n      // dx and dy are used in compare modes - here we want to always\n      // prioritize the closest data point, at least as long as markers are\n      // the same size or nonexistent, but still try to prioritize small markers too.\n      var rad = Math.max(3, di.mrc || 0);\n      var kink = 1 - 1 / rad;\n      var dxRaw = Math.abs(xa.c2p(di.x) - xpx);\n      if (di.orig_x !== undefined) dxRaw += xa.c2p(di.orig_x) - xa.c2p(di.x);\n      return dxRaw < rad ? kink * dxRaw / rad : dxRaw - rad + kink;\n    };\n\n    var dy = function (di) {\n      var rad = Math.max(3, di.mrc || 0);\n      var kink = 1 - 1 / rad;\n      var dyRaw = Math.abs(ya.c2p(di.y) - ypx);\n      if (di.orig_y !== undefined) dyRaw += ya.c2p(di.orig_y) - ya.c2p(di.y);\n      return dyRaw < rad ? kink * dyRaw / rad : dyRaw - rad + kink;\n    };\n\n    var dxy = function (di) {\n      // scatter points: d.mrc is the calculated marker radius\n      // adjust the distance so if you're inside the marker it\n      // always will show up regardless of point size, but\n      // prioritize smaller points\n      var rad = Math.max(minRad, di.mrc || 0);\n      var dx = xa.c2p(di.x) - xpx;\n      var dy = ya.c2p(di.y) - ypx;\n      return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - minRad / rad);\n    };\n\n    var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\n    Fx.getClosest(cd, distfn, pointData); // skip the rest (for this trace) if we didn't find a close point\n\n    if (pointData.index !== false) {\n      // the closest data point\n      var di = cd[pointData.index];\n      var xc = xa.c2p(di.x, true);\n      var yc = ya.c2p(di.y, true);\n      var rad = di.mrc || 1; // now we're done using the whole `calcdata` array, replace the\n      // index with the original index (in case of inserted point from\n      // stacked area)\n\n      pointData.index = di.i;\n      var orientation = cd[0].t.orientation; // TODO: for scatter and bar, option to show (sub)totals and\n      // raw data? Currently stacked and/or normalized bars just show\n      // the normalized individual sizes, so that's what I'm doing here\n      // for now.\n\n      var sizeVal = orientation && (di.sNorm || di.s);\n      var xLabelVal = orientation === 'h' ? sizeVal : di.orig_x !== undefined ? di.orig_x : di.x;\n      var yLabelVal = orientation === 'v' ? sizeVal : di.orig_y !== undefined ? di.orig_y : di.y;\n      Lib.extendFlat(pointData, {\n        color: getTraceColor(trace, di),\n        x0: xc - rad,\n        x1: xc + rad,\n        xLabelVal: xLabelVal,\n        y0: yc - rad,\n        y1: yc + rad,\n        yLabelVal: yLabelVal,\n        spikeDistance: dxy(di),\n        hovertemplate: trace.hovertemplate\n      });\n      fillText(di, trace, pointData);\n      Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData);\n      return [pointData];\n    }\n  } // even if hoveron is 'fills', only use it if we have polygons too\n\n\n  if (hoveron.indexOf('fills') !== -1 && trace._polygons) {\n    var polygons = trace._polygons;\n    var polygonsIn = [];\n    var inside = false;\n    var xmin = Infinity;\n    var xmax = -Infinity;\n    var ymin = Infinity;\n    var ymax = -Infinity;\n    var i, j, polygon, pts, xCross, x0, x1, y0, y1;\n\n    for (i = 0; i < polygons.length; i++) {\n      polygon = polygons[i]; // TODO: this is not going to work right for curved edges, it will\n      // act as though they're straight. That's probably going to need\n      // the elements themselves to capture the events. Worth it?\n\n      if (polygon.contains(pt)) {\n        inside = !inside; // TODO: need better than just the overall bounding box\n\n        polygonsIn.push(polygon);\n        ymin = Math.min(ymin, polygon.ymin);\n        ymax = Math.max(ymax, polygon.ymax);\n      }\n    }\n\n    if (inside) {\n      // constrain ymin/max to the visible plot, so the label goes\n      // at the middle of the piece you can see\n      ymin = Math.max(ymin, 0);\n      ymax = Math.min(ymax, ya._length); // find the overall left-most and right-most points of the\n      // polygon(s) we're inside at their combined vertical midpoint.\n      // This is where we will draw the hover label.\n      // Note that this might not be the vertical midpoint of the\n      // whole trace, if it's disjoint.\n\n      var yAvg = (ymin + ymax) / 2;\n\n      for (i = 0; i < polygonsIn.length; i++) {\n        pts = polygonsIn[i].pts;\n\n        for (j = 1; j < pts.length; j++) {\n          y0 = pts[j - 1][1];\n          y1 = pts[j][1];\n\n          if (y0 > yAvg !== y1 >= yAvg) {\n            x0 = pts[j - 1][0];\n            x1 = pts[j][0];\n\n            if (y1 - y0) {\n              xCross = x0 + (x1 - x0) * (yAvg - y0) / (y1 - y0);\n              xmin = Math.min(xmin, xCross);\n              xmax = Math.max(xmax, xCross);\n            }\n          }\n        }\n      } // constrain xmin/max to the visible plot now too\n\n\n      xmin = Math.max(xmin, 0);\n      xmax = Math.min(xmax, xa._length); // get only fill or line color for the hover color\n\n      var color = Color.defaultLine;\n      if (Color.opacity(trace.fillcolor)) color = trace.fillcolor;else if (Color.opacity((trace.line || {}).color)) {\n        color = trace.line.color;\n      }\n      Lib.extendFlat(pointData, {\n        // never let a 2D override 1D type as closest point\n        // also: no spikeDistance, it's not allowed for fills\n        distance: pointData.maxHoverDistance,\n        x0: xmin,\n        x1: xmax,\n        y0: yAvg,\n        y1: yAvg,\n        color: color,\n        hovertemplate: false\n      });\n      delete pointData.index;\n\n      if (trace.text && !Array.isArray(trace.text)) {\n        pointData.text = String(trace.text);\n      } else pointData.text = trace.name;\n\n      return [pointData];\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/traces/scatter/hover.js"],"names":["Lib","require","Fx","Registry","getTraceColor","Color","fillText","module","exports","hoverPoints","pointData","xval","yval","hovermode","cd","trace","xa","ya","xpx","c2p","ypx","pt","hoveron","minRad","mode","indexOf","dx","di","rad","Math","max","mrc","kink","dxRaw","abs","x","orig_x","undefined","dy","dyRaw","y","orig_y","dxy","sqrt","distfn","getDistanceFunction","getClosest","index","xc","yc","i","orientation","t","sizeVal","sNorm","s","xLabelVal","yLabelVal","extendFlat","color","x0","x1","y0","y1","spikeDistance","hovertemplate","getComponentMethod","_polygons","polygons","polygonsIn","inside","xmin","Infinity","xmax","ymin","ymax","j","polygon","pts","xCross","length","contains","push","min","_length","yAvg","defaultLine","opacity","fillcolor","line","distance","maxHoverDistance","text","Array","isArray","String","name"],"mappings":"AAAA;;AAEA,IAAIA,GAAG,GAAGC,OAAO,CAAC,WAAD,CAAjB;;AACA,IAAIC,EAAE,GAAGD,OAAO,CAAC,qBAAD,CAAhB;;AACA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,gBAAD,CAAtB;;AACA,IAAIG,aAAa,GAAGH,OAAO,CAAC,mBAAD,CAA3B;;AACA,IAAII,KAAK,GAAGJ,OAAO,CAAC,wBAAD,CAAnB;;AACA,IAAIK,QAAQ,GAAGN,GAAG,CAACM,QAAnB;;AAEAC,MAAM,CAACC,OAAP,GAAiB,SAASC,WAAT,CAAqBC,SAArB,EAAgCC,IAAhC,EAAsCC,IAAtC,EAA4CC,SAA5C,EAAuD;AACpE,MAAIC,EAAE,GAAGJ,SAAS,CAACI,EAAnB;AACA,MAAIC,KAAK,GAAGD,EAAE,CAAC,CAAD,CAAF,CAAMC,KAAlB;AACA,MAAIC,EAAE,GAAGN,SAAS,CAACM,EAAnB;AACA,MAAIC,EAAE,GAAGP,SAAS,CAACO,EAAnB;AACA,MAAIC,GAAG,GAAGF,EAAE,CAACG,GAAH,CAAOR,IAAP,CAAV;AACA,MAAIS,GAAG,GAAGH,EAAE,CAACE,GAAH,CAAOP,IAAP,CAAV;AACA,MAAIS,EAAE,GAAG,CAACH,GAAD,EAAME,GAAN,CAAT;AACA,MAAIE,OAAO,GAAGP,KAAK,CAACO,OAAN,IAAiB,EAA/B;AACA,MAAIC,MAAM,GAAIR,KAAK,CAACS,IAAN,CAAWC,OAAX,CAAmB,SAAnB,MAAkC,CAAC,CAApC,GAAyC,CAAzC,GAA6C,GAA1D,CAToE,CAWpE;AACA;;AACA,MAAGH,OAAO,CAACG,OAAR,CAAgB,QAAhB,MAA8B,CAAC,CAAlC,EAAqC;AACjC,QAAIC,EAAE,GAAG,UAASC,EAAT,EAAa;AAClB;AACA;AACA;AACA,UAAIC,GAAG,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,EAAE,CAACI,GAAH,IAAU,CAAtB,CAAV;AACA,UAAIC,IAAI,GAAG,IAAI,IAAIJ,GAAnB;AACA,UAAIK,KAAK,GAAGJ,IAAI,CAACK,GAAL,CAASlB,EAAE,CAACG,GAAH,CAAOQ,EAAE,CAACQ,CAAV,IAAejB,GAAxB,CAAZ;AACA,UAAGS,EAAE,CAACS,MAAH,KAAcC,SAAjB,EAA4BJ,KAAK,IAAIjB,EAAE,CAACG,GAAH,CAAOQ,EAAE,CAACS,MAAV,IAAoBpB,EAAE,CAACG,GAAH,CAAOQ,EAAE,CAACQ,CAAV,CAA7B;AAC5B,aAAQF,KAAK,GAAGL,GAAT,GAAiBI,IAAI,GAAGC,KAAP,GAAeL,GAAhC,GAAwCK,KAAK,GAAGL,GAAR,GAAcI,IAA7D;AACH,KATD;;AAUA,QAAIM,EAAE,GAAG,UAASX,EAAT,EAAa;AAClB,UAAIC,GAAG,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,EAAE,CAACI,GAAH,IAAU,CAAtB,CAAV;AACA,UAAIC,IAAI,GAAG,IAAI,IAAIJ,GAAnB;AACA,UAAIW,KAAK,GAAGV,IAAI,CAACK,GAAL,CAASjB,EAAE,CAACE,GAAH,CAAOQ,EAAE,CAACa,CAAV,IAAepB,GAAxB,CAAZ;AACA,UAAGO,EAAE,CAACc,MAAH,KAAcJ,SAAjB,EAA4BE,KAAK,IAAItB,EAAE,CAACE,GAAH,CAAOQ,EAAE,CAACc,MAAV,IAAoBxB,EAAE,CAACE,GAAH,CAAOQ,EAAE,CAACa,CAAV,CAA7B;AAC5B,aAAQD,KAAK,GAAGX,GAAT,GAAiBI,IAAI,GAAGO,KAAP,GAAeX,GAAhC,GAAwCW,KAAK,GAAGX,GAAR,GAAcI,IAA7D;AACH,KAND;;AAOA,QAAIU,GAAG,GAAG,UAASf,EAAT,EAAa;AACnB;AACA;AACA;AACA;AACA,UAAIC,GAAG,GAAGC,IAAI,CAACC,GAAL,CAASP,MAAT,EAAiBI,EAAE,CAACI,GAAH,IAAU,CAA3B,CAAV;AACA,UAAIL,EAAE,GAAGV,EAAE,CAACG,GAAH,CAAOQ,EAAE,CAACQ,CAAV,IAAejB,GAAxB;AACA,UAAIoB,EAAE,GAAGrB,EAAE,CAACE,GAAH,CAAOQ,EAAE,CAACa,CAAV,IAAepB,GAAxB;AACA,aAAOS,IAAI,CAACC,GAAL,CAASD,IAAI,CAACc,IAAL,CAAUjB,EAAE,GAAGA,EAAL,GAAUY,EAAE,GAAGA,EAAzB,IAA+BV,GAAxC,EAA6C,IAAIL,MAAM,GAAGK,GAA1D,CAAP;AACH,KATD;;AAUA,QAAIgB,MAAM,GAAG1C,EAAE,CAAC2C,mBAAH,CAAuBhC,SAAvB,EAAkCa,EAAlC,EAAsCY,EAAtC,EAA0CI,GAA1C,CAAb;AAEAxC,IAAAA,EAAE,CAAC4C,UAAH,CAAchC,EAAd,EAAkB8B,MAAlB,EAA0BlC,SAA1B,EA9BiC,CAgCjC;;AACA,QAAGA,SAAS,CAACqC,KAAV,KAAoB,KAAvB,EAA8B;AAC1B;AACA,UAAIpB,EAAE,GAAGb,EAAE,CAACJ,SAAS,CAACqC,KAAX,CAAX;AACA,UAAIC,EAAE,GAAGhC,EAAE,CAACG,GAAH,CAAOQ,EAAE,CAACQ,CAAV,EAAa,IAAb,CAAT;AACA,UAAIc,EAAE,GAAGhC,EAAE,CAACE,GAAH,CAAOQ,EAAE,CAACa,CAAV,EAAa,IAAb,CAAT;AACA,UAAIZ,GAAG,GAAGD,EAAE,CAACI,GAAH,IAAU,CAApB,CAL0B,CAO1B;AACA;AACA;;AACArB,MAAAA,SAAS,CAACqC,KAAV,GAAkBpB,EAAE,CAACuB,CAArB;AAEA,UAAIC,WAAW,GAAGrC,EAAE,CAAC,CAAD,CAAF,CAAMsC,CAAN,CAAQD,WAA1B,CAZ0B,CAa1B;AACA;AACA;AACA;;AACA,UAAIE,OAAO,GAAGF,WAAW,KAAKxB,EAAE,CAAC2B,KAAH,IAAY3B,EAAE,CAAC4B,CAApB,CAAzB;AACA,UAAIC,SAAS,GAAIL,WAAW,KAAK,GAAjB,GAAwBE,OAAxB,GAAkC1B,EAAE,CAACS,MAAH,KAAcC,SAAd,GAA0BV,EAAE,CAACS,MAA7B,GAAsCT,EAAE,CAACQ,CAA3F;AACA,UAAIsB,SAAS,GAAIN,WAAW,KAAK,GAAjB,GAAwBE,OAAxB,GAAkC1B,EAAE,CAACc,MAAH,KAAcJ,SAAd,GAA0BV,EAAE,CAACc,MAA7B,GAAsCd,EAAE,CAACa,CAA3F;AAEAxC,MAAAA,GAAG,CAAC0D,UAAJ,CAAehD,SAAf,EAA0B;AACtBiD,QAAAA,KAAK,EAAEvD,aAAa,CAACW,KAAD,EAAQY,EAAR,CADE;AAGtBiC,QAAAA,EAAE,EAAEZ,EAAE,GAAGpB,GAHa;AAItBiC,QAAAA,EAAE,EAAEb,EAAE,GAAGpB,GAJa;AAKtB4B,QAAAA,SAAS,EAAEA,SALW;AAOtBM,QAAAA,EAAE,EAAEb,EAAE,GAAGrB,GAPa;AAQtBmC,QAAAA,EAAE,EAAEd,EAAE,GAAGrB,GARa;AAStB6B,QAAAA,SAAS,EAAEA,SATW;AAWtBO,QAAAA,aAAa,EAAEtB,GAAG,CAACf,EAAD,CAXI;AAYtBsC,QAAAA,aAAa,EAAElD,KAAK,CAACkD;AAZC,OAA1B;AAeA3D,MAAAA,QAAQ,CAACqB,EAAD,EAAKZ,KAAL,EAAYL,SAAZ,CAAR;AACAP,MAAAA,QAAQ,CAAC+D,kBAAT,CAA4B,WAA5B,EAAyC,WAAzC,EAAsDvC,EAAtD,EAA0DZ,KAA1D,EAAiEL,SAAjE;AAEA,aAAO,CAACA,SAAD,CAAP;AACH;AACJ,GAvFmE,CAyFpE;;;AACA,MAAGY,OAAO,CAACG,OAAR,CAAgB,OAAhB,MAA6B,CAAC,CAA9B,IAAmCV,KAAK,CAACoD,SAA5C,EAAuD;AACnD,QAAIC,QAAQ,GAAGrD,KAAK,CAACoD,SAArB;AACA,QAAIE,UAAU,GAAG,EAAjB;AACA,QAAIC,MAAM,GAAG,KAAb;AACA,QAAIC,IAAI,GAAGC,QAAX;AACA,QAAIC,IAAI,GAAG,CAACD,QAAZ;AACA,QAAIE,IAAI,GAAGF,QAAX;AACA,QAAIG,IAAI,GAAG,CAACH,QAAZ;AAEA,QAAItB,CAAJ,EAAO0B,CAAP,EAAUC,OAAV,EAAmBC,GAAnB,EAAwBC,MAAxB,EAAgCnB,EAAhC,EAAoCC,EAApC,EAAwCC,EAAxC,EAA4CC,EAA5C;;AAEA,SAAIb,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGkB,QAAQ,CAACY,MAAxB,EAAgC9B,CAAC,EAAjC,EAAqC;AACjC2B,MAAAA,OAAO,GAAGT,QAAQ,CAAClB,CAAD,CAAlB,CADiC,CAEjC;AACA;AACA;;AACA,UAAG2B,OAAO,CAACI,QAAR,CAAiB5D,EAAjB,CAAH,EAAyB;AACrBiD,QAAAA,MAAM,GAAG,CAACA,MAAV,CADqB,CAErB;;AACAD,QAAAA,UAAU,CAACa,IAAX,CAAgBL,OAAhB;AACAH,QAAAA,IAAI,GAAG7C,IAAI,CAACsD,GAAL,CAAST,IAAT,EAAeG,OAAO,CAACH,IAAvB,CAAP;AACAC,QAAAA,IAAI,GAAG9C,IAAI,CAACC,GAAL,CAAS6C,IAAT,EAAeE,OAAO,CAACF,IAAvB,CAAP;AACH;AACJ;;AAED,QAAGL,MAAH,EAAW;AACP;AACA;AACAI,MAAAA,IAAI,GAAG7C,IAAI,CAACC,GAAL,CAAS4C,IAAT,EAAe,CAAf,CAAP;AACAC,MAAAA,IAAI,GAAG9C,IAAI,CAACsD,GAAL,CAASR,IAAT,EAAe1D,EAAE,CAACmE,OAAlB,CAAP,CAJO,CAMP;AACA;AACA;AACA;AACA;;AACA,UAAIC,IAAI,GAAG,CAACX,IAAI,GAAGC,IAAR,IAAgB,CAA3B;;AACA,WAAIzB,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGmB,UAAU,CAACW,MAA1B,EAAkC9B,CAAC,EAAnC,EAAuC;AACnC4B,QAAAA,GAAG,GAAGT,UAAU,CAACnB,CAAD,CAAV,CAAc4B,GAApB;;AACA,aAAIF,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGE,GAAG,CAACE,MAAnB,EAA2BJ,CAAC,EAA5B,EAAgC;AAC5Bd,UAAAA,EAAE,GAAGgB,GAAG,CAACF,CAAC,GAAG,CAAL,CAAH,CAAW,CAAX,CAAL;AACAb,UAAAA,EAAE,GAAGe,GAAG,CAACF,CAAD,CAAH,CAAO,CAAP,CAAL;;AACA,cAAId,EAAE,GAAGuB,IAAN,KAAiBtB,EAAE,IAAIsB,IAA1B,EAAiC;AAC7BzB,YAAAA,EAAE,GAAGkB,GAAG,CAACF,CAAC,GAAG,CAAL,CAAH,CAAW,CAAX,CAAL;AACAf,YAAAA,EAAE,GAAGiB,GAAG,CAACF,CAAD,CAAH,CAAO,CAAP,CAAL;;AACA,gBAAGb,EAAE,GAAGD,EAAR,EAAY;AACRiB,cAAAA,MAAM,GAAGnB,EAAE,GAAG,CAACC,EAAE,GAAGD,EAAN,KAAayB,IAAI,GAAGvB,EAApB,KAA2BC,EAAE,GAAGD,EAAhC,CAAd;AACAS,cAAAA,IAAI,GAAG1C,IAAI,CAACsD,GAAL,CAASZ,IAAT,EAAeQ,MAAf,CAAP;AACAN,cAAAA,IAAI,GAAG5C,IAAI,CAACC,GAAL,CAAS2C,IAAT,EAAeM,MAAf,CAAP;AACH;AACJ;AACJ;AACJ,OA3BM,CA6BP;;;AACAR,MAAAA,IAAI,GAAG1C,IAAI,CAACC,GAAL,CAASyC,IAAT,EAAe,CAAf,CAAP;AACAE,MAAAA,IAAI,GAAG5C,IAAI,CAACsD,GAAL,CAASV,IAAT,EAAezD,EAAE,CAACoE,OAAlB,CAAP,CA/BO,CAiCP;;AACA,UAAIzB,KAAK,GAAGtD,KAAK,CAACiF,WAAlB;AACA,UAAGjF,KAAK,CAACkF,OAAN,CAAcxE,KAAK,CAACyE,SAApB,CAAH,EAAmC7B,KAAK,GAAG5C,KAAK,CAACyE,SAAd,CAAnC,KACK,IAAGnF,KAAK,CAACkF,OAAN,CAAc,CAACxE,KAAK,CAAC0E,IAAN,IAAc,EAAf,EAAmB9B,KAAjC,CAAH,EAA4C;AAC7CA,QAAAA,KAAK,GAAG5C,KAAK,CAAC0E,IAAN,CAAW9B,KAAnB;AACH;AAED3D,MAAAA,GAAG,CAAC0D,UAAJ,CAAehD,SAAf,EAA0B;AACtB;AACA;AACAgF,QAAAA,QAAQ,EAAEhF,SAAS,CAACiF,gBAHE;AAItB/B,QAAAA,EAAE,EAAEW,IAJkB;AAKtBV,QAAAA,EAAE,EAAEY,IALkB;AAMtBX,QAAAA,EAAE,EAAEuB,IANkB;AAOtBtB,QAAAA,EAAE,EAAEsB,IAPkB;AAQtB1B,QAAAA,KAAK,EAAEA,KARe;AAStBM,QAAAA,aAAa,EAAE;AATO,OAA1B;AAYA,aAAOvD,SAAS,CAACqC,KAAjB;;AAEA,UAAGhC,KAAK,CAAC6E,IAAN,IAAc,CAACC,KAAK,CAACC,OAAN,CAAc/E,KAAK,CAAC6E,IAApB,CAAlB,EAA6C;AACzClF,QAAAA,SAAS,CAACkF,IAAV,GAAiBG,MAAM,CAAChF,KAAK,CAAC6E,IAAP,CAAvB;AACH,OAFD,MAEOlF,SAAS,CAACkF,IAAV,GAAiB7E,KAAK,CAACiF,IAAvB;;AAEP,aAAO,CAACtF,SAAD,CAAP;AACH;AACJ;AACJ,CAhLD","sourcesContent":["'use strict';\r\n\r\nvar Lib = require('../../lib');\r\nvar Fx = require('../../components/fx');\r\nvar Registry = require('../../registry');\r\nvar getTraceColor = require('./get_trace_color');\r\nvar Color = require('../../components/color');\r\nvar fillText = Lib.fillText;\r\n\r\nmodule.exports = function hoverPoints(pointData, xval, yval, hovermode) {\r\n    var cd = pointData.cd;\r\n    var trace = cd[0].trace;\r\n    var xa = pointData.xa;\r\n    var ya = pointData.ya;\r\n    var xpx = xa.c2p(xval);\r\n    var ypx = ya.c2p(yval);\r\n    var pt = [xpx, ypx];\r\n    var hoveron = trace.hoveron || '';\r\n    var minRad = (trace.mode.indexOf('markers') !== -1) ? 3 : 0.5;\r\n\r\n    // look for points to hover on first, then take fills only if we\r\n    // didn't find a point\r\n    if(hoveron.indexOf('points') !== -1) {\r\n        var dx = function(di) {\r\n            // dx and dy are used in compare modes - here we want to always\r\n            // prioritize the closest data point, at least as long as markers are\r\n            // the same size or nonexistent, but still try to prioritize small markers too.\r\n            var rad = Math.max(3, di.mrc || 0);\r\n            var kink = 1 - 1 / rad;\r\n            var dxRaw = Math.abs(xa.c2p(di.x) - xpx);\r\n            if(di.orig_x !== undefined) dxRaw += xa.c2p(di.orig_x) - xa.c2p(di.x);\r\n            return (dxRaw < rad) ? (kink * dxRaw / rad) : (dxRaw - rad + kink);\r\n        };\r\n        var dy = function(di) {\r\n            var rad = Math.max(3, di.mrc || 0);\r\n            var kink = 1 - 1 / rad;\r\n            var dyRaw = Math.abs(ya.c2p(di.y) - ypx);\r\n            if(di.orig_y !== undefined) dyRaw += ya.c2p(di.orig_y) - ya.c2p(di.y);\r\n            return (dyRaw < rad) ? (kink * dyRaw / rad) : (dyRaw - rad + kink);\r\n        };\r\n        var dxy = function(di) {\r\n            // scatter points: d.mrc is the calculated marker radius\r\n            // adjust the distance so if you're inside the marker it\r\n            // always will show up regardless of point size, but\r\n            // prioritize smaller points\r\n            var rad = Math.max(minRad, di.mrc || 0);\r\n            var dx = xa.c2p(di.x) - xpx;\r\n            var dy = ya.c2p(di.y) - ypx;\r\n            return Math.max(Math.sqrt(dx * dx + dy * dy) - rad, 1 - minRad / rad);\r\n        };\r\n        var distfn = Fx.getDistanceFunction(hovermode, dx, dy, dxy);\r\n\r\n        Fx.getClosest(cd, distfn, pointData);\r\n\r\n        // skip the rest (for this trace) if we didn't find a close point\r\n        if(pointData.index !== false) {\r\n            // the closest data point\r\n            var di = cd[pointData.index];\r\n            var xc = xa.c2p(di.x, true);\r\n            var yc = ya.c2p(di.y, true);\r\n            var rad = di.mrc || 1;\r\n\r\n            // now we're done using the whole `calcdata` array, replace the\r\n            // index with the original index (in case of inserted point from\r\n            // stacked area)\r\n            pointData.index = di.i;\r\n\r\n            var orientation = cd[0].t.orientation;\r\n            // TODO: for scatter and bar, option to show (sub)totals and\r\n            // raw data? Currently stacked and/or normalized bars just show\r\n            // the normalized individual sizes, so that's what I'm doing here\r\n            // for now.\r\n            var sizeVal = orientation && (di.sNorm || di.s);\r\n            var xLabelVal = (orientation === 'h') ? sizeVal : di.orig_x !== undefined ? di.orig_x : di.x;\r\n            var yLabelVal = (orientation === 'v') ? sizeVal : di.orig_y !== undefined ? di.orig_y : di.y;\r\n\r\n            Lib.extendFlat(pointData, {\r\n                color: getTraceColor(trace, di),\r\n\r\n                x0: xc - rad,\r\n                x1: xc + rad,\r\n                xLabelVal: xLabelVal,\r\n\r\n                y0: yc - rad,\r\n                y1: yc + rad,\r\n                yLabelVal: yLabelVal,\r\n\r\n                spikeDistance: dxy(di),\r\n                hovertemplate: trace.hovertemplate\r\n            });\r\n\r\n            fillText(di, trace, pointData);\r\n            Registry.getComponentMethod('errorbars', 'hoverInfo')(di, trace, pointData);\r\n\r\n            return [pointData];\r\n        }\r\n    }\r\n\r\n    // even if hoveron is 'fills', only use it if we have polygons too\r\n    if(hoveron.indexOf('fills') !== -1 && trace._polygons) {\r\n        var polygons = trace._polygons;\r\n        var polygonsIn = [];\r\n        var inside = false;\r\n        var xmin = Infinity;\r\n        var xmax = -Infinity;\r\n        var ymin = Infinity;\r\n        var ymax = -Infinity;\r\n\r\n        var i, j, polygon, pts, xCross, x0, x1, y0, y1;\r\n\r\n        for(i = 0; i < polygons.length; i++) {\r\n            polygon = polygons[i];\r\n            // TODO: this is not going to work right for curved edges, it will\r\n            // act as though they're straight. That's probably going to need\r\n            // the elements themselves to capture the events. Worth it?\r\n            if(polygon.contains(pt)) {\r\n                inside = !inside;\r\n                // TODO: need better than just the overall bounding box\r\n                polygonsIn.push(polygon);\r\n                ymin = Math.min(ymin, polygon.ymin);\r\n                ymax = Math.max(ymax, polygon.ymax);\r\n            }\r\n        }\r\n\r\n        if(inside) {\r\n            // constrain ymin/max to the visible plot, so the label goes\r\n            // at the middle of the piece you can see\r\n            ymin = Math.max(ymin, 0);\r\n            ymax = Math.min(ymax, ya._length);\r\n\r\n            // find the overall left-most and right-most points of the\r\n            // polygon(s) we're inside at their combined vertical midpoint.\r\n            // This is where we will draw the hover label.\r\n            // Note that this might not be the vertical midpoint of the\r\n            // whole trace, if it's disjoint.\r\n            var yAvg = (ymin + ymax) / 2;\r\n            for(i = 0; i < polygonsIn.length; i++) {\r\n                pts = polygonsIn[i].pts;\r\n                for(j = 1; j < pts.length; j++) {\r\n                    y0 = pts[j - 1][1];\r\n                    y1 = pts[j][1];\r\n                    if((y0 > yAvg) !== (y1 >= yAvg)) {\r\n                        x0 = pts[j - 1][0];\r\n                        x1 = pts[j][0];\r\n                        if(y1 - y0) {\r\n                            xCross = x0 + (x1 - x0) * (yAvg - y0) / (y1 - y0);\r\n                            xmin = Math.min(xmin, xCross);\r\n                            xmax = Math.max(xmax, xCross);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // constrain xmin/max to the visible plot now too\r\n            xmin = Math.max(xmin, 0);\r\n            xmax = Math.min(xmax, xa._length);\r\n\r\n            // get only fill or line color for the hover color\r\n            var color = Color.defaultLine;\r\n            if(Color.opacity(trace.fillcolor)) color = trace.fillcolor;\r\n            else if(Color.opacity((trace.line || {}).color)) {\r\n                color = trace.line.color;\r\n            }\r\n\r\n            Lib.extendFlat(pointData, {\r\n                // never let a 2D override 1D type as closest point\r\n                // also: no spikeDistance, it's not allowed for fills\r\n                distance: pointData.maxHoverDistance,\r\n                x0: xmin,\r\n                x1: xmax,\r\n                y0: yAvg,\r\n                y1: yAvg,\r\n                color: color,\r\n                hovertemplate: false\r\n            });\r\n\r\n            delete pointData.index;\r\n\r\n            if(trace.text && !Array.isArray(trace.text)) {\r\n                pointData.text = String(trace.text);\r\n            } else pointData.text = trace.name;\r\n\r\n            return [pointData];\r\n        }\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}
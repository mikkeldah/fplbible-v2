{"ast":null,"code":"'use strict';\n\nvar perStackAttrs = ['orientation', 'groupnorm', 'stackgaps'];\n\nmodule.exports = function handleStackDefaults(traceIn, traceOut, layout, coerce) {\n  var stackOpts = layout._scatterStackOpts;\n  var stackGroup = coerce('stackgroup');\n\n  if (stackGroup) {\n    // use independent stacking options per subplot\n    var subplot = traceOut.xaxis + traceOut.yaxis;\n    var subplotStackOpts = stackOpts[subplot];\n    if (!subplotStackOpts) subplotStackOpts = stackOpts[subplot] = {};\n    var groupOpts = subplotStackOpts[stackGroup];\n    var firstTrace = false;\n\n    if (groupOpts) {\n      groupOpts.traces.push(traceOut);\n    } else {\n      groupOpts = subplotStackOpts[stackGroup] = {\n        // keep track of trace indices for use during stacking calculations\n        // this will be filled in during `calc` and used during `crossTraceCalc`\n        // so it's OK if we don't recreate it during a non-calc edit\n        traceIndices: [],\n        // Hold on to the whole set of prior traces\n        // First one is most important, so we can clear defaults\n        // there if we find explicit values only in later traces.\n        // We're only going to *use* the values stored in groupOpts,\n        // but for the editor and validate we want things self-consistent\n        // The full set of traces is used only to fix `fill` default if\n        // we find `orientation: 'h'` beyond the first trace\n        traces: [traceOut]\n      };\n      firstTrace = true;\n    } // TODO: how is this going to work with groupby transforms?\n    // in principle it should be OK I guess, as long as explicit group styles\n    // don't override explicit base-trace styles?\n\n\n    var dflts = {\n      orientation: traceOut.x && !traceOut.y ? 'h' : 'v'\n    };\n\n    for (var i = 0; i < perStackAttrs.length; i++) {\n      var attr = perStackAttrs[i];\n      var attrFound = attr + 'Found';\n\n      if (!groupOpts[attrFound]) {\n        var traceHasAttr = traceIn[attr] !== undefined;\n        var isOrientation = attr === 'orientation';\n\n        if (traceHasAttr || firstTrace) {\n          groupOpts[attr] = coerce(attr, dflts[attr]);\n\n          if (isOrientation) {\n            groupOpts.fillDflt = groupOpts[attr] === 'h' ? 'tonextx' : 'tonexty';\n          }\n\n          if (traceHasAttr) {\n            // Note: this will show a value here even if it's invalid\n            // in which case it will revert to default.\n            groupOpts[attrFound] = true; // Note: only one trace in the stack will get a _fullData\n            // entry for a given stack-wide attribute. If no traces\n            // (or the first trace) specify that attribute, the\n            // first trace will get it. If the first trace does NOT\n            // specify it but some later trace does, then it gets\n            // removed from the first trace and only included in the\n            // one that specified it. This is mostly important for\n            // editors (that want to see the full values to know\n            // what settings are available) and Plotly.react diffing.\n            // Editors may want to use fullLayout._scatterStackOpts\n            // directly and make these settings available from all\n            // traces in the stack... then set the new value into\n            // the first trace, and clear all later traces.\n\n            if (!firstTrace) {\n              delete groupOpts.traces[0][attr]; // orientation can affect default fill of previous traces\n\n              if (isOrientation) {\n                for (var j = 0; j < groupOpts.traces.length - 1; j++) {\n                  var trace2 = groupOpts.traces[j];\n\n                  if (trace2._input.fill !== trace2.fill) {\n                    trace2.fill = groupOpts.fillDflt;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return groupOpts;\n  }\n};","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/traces/scatter/stack_defaults.js"],"names":["perStackAttrs","module","exports","handleStackDefaults","traceIn","traceOut","layout","coerce","stackOpts","_scatterStackOpts","stackGroup","subplot","xaxis","yaxis","subplotStackOpts","groupOpts","firstTrace","traces","push","traceIndices","dflts","orientation","x","y","i","length","attr","attrFound","traceHasAttr","undefined","isOrientation","fillDflt","j","trace2","_input","fill"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar perStackAttrs = ['orientation', 'groupnorm', 'stackgaps'];\r\n\r\nmodule.exports = function handleStackDefaults(traceIn, traceOut, layout, coerce) {\r\n    var stackOpts = layout._scatterStackOpts;\r\n\r\n    var stackGroup = coerce('stackgroup');\r\n    if(stackGroup) {\r\n        // use independent stacking options per subplot\r\n        var subplot = traceOut.xaxis + traceOut.yaxis;\r\n        var subplotStackOpts = stackOpts[subplot];\r\n        if(!subplotStackOpts) subplotStackOpts = stackOpts[subplot] = {};\r\n\r\n        var groupOpts = subplotStackOpts[stackGroup];\r\n        var firstTrace = false;\r\n        if(groupOpts) {\r\n            groupOpts.traces.push(traceOut);\r\n        } else {\r\n            groupOpts = subplotStackOpts[stackGroup] = {\r\n                // keep track of trace indices for use during stacking calculations\r\n                // this will be filled in during `calc` and used during `crossTraceCalc`\r\n                // so it's OK if we don't recreate it during a non-calc edit\r\n                traceIndices: [],\r\n                // Hold on to the whole set of prior traces\r\n                // First one is most important, so we can clear defaults\r\n                // there if we find explicit values only in later traces.\r\n                // We're only going to *use* the values stored in groupOpts,\r\n                // but for the editor and validate we want things self-consistent\r\n                // The full set of traces is used only to fix `fill` default if\r\n                // we find `orientation: 'h'` beyond the first trace\r\n                traces: [traceOut]\r\n            };\r\n            firstTrace = true;\r\n        }\r\n        // TODO: how is this going to work with groupby transforms?\r\n        // in principle it should be OK I guess, as long as explicit group styles\r\n        // don't override explicit base-trace styles?\r\n\r\n        var dflts = {\r\n            orientation: (traceOut.x && !traceOut.y) ? 'h' : 'v'\r\n        };\r\n\r\n        for(var i = 0; i < perStackAttrs.length; i++) {\r\n            var attr = perStackAttrs[i];\r\n            var attrFound = attr + 'Found';\r\n            if(!groupOpts[attrFound]) {\r\n                var traceHasAttr = traceIn[attr] !== undefined;\r\n                var isOrientation = attr === 'orientation';\r\n                if(traceHasAttr || firstTrace) {\r\n                    groupOpts[attr] = coerce(attr, dflts[attr]);\r\n\r\n                    if(isOrientation) {\r\n                        groupOpts.fillDflt = groupOpts[attr] === 'h' ?\r\n                            'tonextx' : 'tonexty';\r\n                    }\r\n\r\n                    if(traceHasAttr) {\r\n                        // Note: this will show a value here even if it's invalid\r\n                        // in which case it will revert to default.\r\n                        groupOpts[attrFound] = true;\r\n\r\n                        // Note: only one trace in the stack will get a _fullData\r\n                        // entry for a given stack-wide attribute. If no traces\r\n                        // (or the first trace) specify that attribute, the\r\n                        // first trace will get it. If the first trace does NOT\r\n                        // specify it but some later trace does, then it gets\r\n                        // removed from the first trace and only included in the\r\n                        // one that specified it. This is mostly important for\r\n                        // editors (that want to see the full values to know\r\n                        // what settings are available) and Plotly.react diffing.\r\n                        // Editors may want to use fullLayout._scatterStackOpts\r\n                        // directly and make these settings available from all\r\n                        // traces in the stack... then set the new value into\r\n                        // the first trace, and clear all later traces.\r\n                        if(!firstTrace) {\r\n                            delete groupOpts.traces[0][attr];\r\n\r\n                            // orientation can affect default fill of previous traces\r\n                            if(isOrientation) {\r\n                                for(var j = 0; j < groupOpts.traces.length - 1; j++) {\r\n                                    var trace2 = groupOpts.traces[j];\r\n                                    if(trace2._input.fill !== trace2.fill) {\r\n                                        trace2.fill = groupOpts.fillDflt;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return groupOpts;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}
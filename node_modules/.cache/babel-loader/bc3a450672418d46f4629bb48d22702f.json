{"ast":null,"code":"'use strict';\n/* global jQuery:false */\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Events = {\n  init: function (plotObj) {\n    /*\r\n     * If we have already instantiated an emitter for this plot\r\n     * return early.\r\n     */\n    if (plotObj._ev instanceof EventEmitter) return plotObj;\n    var ev = new EventEmitter();\n    var internalEv = new EventEmitter();\n    /*\r\n     * Assign to plot._ev while we still live in a land\r\n     * where plot is a DOM element with stuff attached to it.\r\n     * In the future we can make plot the event emitter itself.\r\n     */\n\n    plotObj._ev = ev;\n    /*\r\n     * Create a second event handler that will manage events *internally*.\r\n     * This allows parts of plotly to respond to thing like relayout without\r\n     * having to use the user-facing event handler. They cannot peacefully\r\n     * coexist on the same handler because a user invoking\r\n     * plotObj.removeAllListeners() would detach internal events, breaking\r\n     * plotly.\r\n     */\n\n    plotObj._internalEv = internalEv;\n    /*\r\n     * Assign bound methods from the ev to the plot object. These methods\r\n     * will reference the 'this' of plot._ev even though they are methods\r\n     * of plot. This will keep the event machinery away from the plot object\r\n     * which currently is often a DOM element but presents an API that will\r\n     * continue to function when plot becomes an emitter. Not all EventEmitter\r\n     * methods have been bound to `plot` as some do not currently add value to\r\n     * the Plotly event API.\r\n     */\n\n    plotObj.on = ev.on.bind(ev);\n    plotObj.once = ev.once.bind(ev);\n    plotObj.removeListener = ev.removeListener.bind(ev);\n    plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);\n    /*\r\n     * Create functions for managing internal events. These are *only* triggered\r\n     * by the mirroring of external events via the emit function.\r\n     */\n\n    plotObj._internalOn = internalEv.on.bind(internalEv);\n    plotObj._internalOnce = internalEv.once.bind(internalEv);\n    plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);\n    plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);\n    /*\r\n     * We must wrap emit to continue to support JQuery events. The idea\r\n     * is to check to see if the user is using JQuery events, if they are\r\n     * we emit JQuery events to trigger user handlers as well as the EventEmitter\r\n     * events.\r\n     */\n\n    plotObj.emit = function (event, data) {\n      if (typeof jQuery !== 'undefined') {\n        jQuery(plotObj).trigger(event, data);\n      }\n\n      ev.emit(event, data);\n      internalEv.emit(event, data);\n    };\n\n    return plotObj;\n  },\n\n  /*\r\n   * This function behaves like jQuery's triggerHandler. It calls\r\n   * all handlers for a particular event and returns the return value\r\n   * of the LAST handler. This function also triggers jQuery's\r\n   * triggerHandler for backwards compatibility.\r\n   */\n  triggerHandler: function (plotObj, event, data) {\n    var jQueryHandlerValue;\n    var nodeEventHandlerValue;\n    /*\r\n     * If jQuery exists run all its handlers for this event and\r\n     * collect the return value of the LAST handler function\r\n     */\n\n    if (typeof jQuery !== 'undefined') {\n      jQueryHandlerValue = jQuery(plotObj).triggerHandler(event, data);\n    }\n    /*\r\n     * Now run all the node style event handlers\r\n     */\n\n\n    var ev = plotObj._ev;\n    if (!ev) return jQueryHandlerValue;\n    var handlers = ev._events[event];\n    if (!handlers) return jQueryHandlerValue; // making sure 'this' is the EventEmitter instance\n\n    function apply(handler) {\n      // The 'once' case, we can't just call handler() as we need\n      // the return value here. So,\n      // - remove handler\n      // - call listener and grab return value!\n      // - stash 'fired' key to not call handler twice\n      if (handler.listener) {\n        ev.removeListener(event, handler.listener);\n\n        if (!handler.fired) {\n          handler.fired = true;\n          return handler.listener.apply(ev, [data]);\n        }\n      } else {\n        return handler.apply(ev, [data]);\n      }\n    } // handlers can be function or an array of functions\n\n\n    handlers = Array.isArray(handlers) ? handlers : [handlers];\n    var i;\n\n    for (i = 0; i < handlers.length - 1; i++) {\n      apply(handlers[i]);\n    } // now call the final handler and collect its value\n\n\n    nodeEventHandlerValue = apply(handlers[i]);\n    /*\r\n     * Return either the jQuery handler value if it exists or the\r\n     * nodeEventHandler value. jQuery event value supersedes nodejs\r\n     * events for backwards compatibility reasons.\r\n     */\n\n    return jQueryHandlerValue !== undefined ? jQueryHandlerValue : nodeEventHandlerValue;\n  },\n  purge: function (plotObj) {\n    delete plotObj._ev;\n    delete plotObj.on;\n    delete plotObj.once;\n    delete plotObj.removeListener;\n    delete plotObj.removeAllListeners;\n    delete plotObj.emit;\n    delete plotObj._ev;\n    delete plotObj._internalEv;\n    delete plotObj._internalOn;\n    delete plotObj._internalOnce;\n    delete plotObj._removeInternalListener;\n    delete plotObj._removeAllInternalListeners;\n    return plotObj;\n  }\n};\nmodule.exports = Events;","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/lib/events.js"],"names":["EventEmitter","require","Events","init","plotObj","_ev","ev","internalEv","_internalEv","on","bind","once","removeListener","removeAllListeners","_internalOn","_internalOnce","_removeInternalListener","_removeAllInternalListeners","emit","event","data","jQuery","trigger","triggerHandler","jQueryHandlerValue","nodeEventHandlerValue","handlers","_events","apply","handler","listener","fired","Array","isArray","i","length","undefined","purge","module","exports"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\n/* global jQuery:false */\r\n\r\nvar EventEmitter = require('events').EventEmitter;\r\n\r\nvar Events = {\r\n\r\n    init: function(plotObj) {\r\n        /*\r\n         * If we have already instantiated an emitter for this plot\r\n         * return early.\r\n         */\r\n        if(plotObj._ev instanceof EventEmitter) return plotObj;\r\n\r\n        var ev = new EventEmitter();\r\n        var internalEv = new EventEmitter();\r\n\r\n        /*\r\n         * Assign to plot._ev while we still live in a land\r\n         * where plot is a DOM element with stuff attached to it.\r\n         * In the future we can make plot the event emitter itself.\r\n         */\r\n        plotObj._ev = ev;\r\n\r\n        /*\r\n         * Create a second event handler that will manage events *internally*.\r\n         * This allows parts of plotly to respond to thing like relayout without\r\n         * having to use the user-facing event handler. They cannot peacefully\r\n         * coexist on the same handler because a user invoking\r\n         * plotObj.removeAllListeners() would detach internal events, breaking\r\n         * plotly.\r\n         */\r\n        plotObj._internalEv = internalEv;\r\n\r\n        /*\r\n         * Assign bound methods from the ev to the plot object. These methods\r\n         * will reference the 'this' of plot._ev even though they are methods\r\n         * of plot. This will keep the event machinery away from the plot object\r\n         * which currently is often a DOM element but presents an API that will\r\n         * continue to function when plot becomes an emitter. Not all EventEmitter\r\n         * methods have been bound to `plot` as some do not currently add value to\r\n         * the Plotly event API.\r\n         */\r\n        plotObj.on = ev.on.bind(ev);\r\n        plotObj.once = ev.once.bind(ev);\r\n        plotObj.removeListener = ev.removeListener.bind(ev);\r\n        plotObj.removeAllListeners = ev.removeAllListeners.bind(ev);\r\n\r\n        /*\r\n         * Create functions for managing internal events. These are *only* triggered\r\n         * by the mirroring of external events via the emit function.\r\n         */\r\n        plotObj._internalOn = internalEv.on.bind(internalEv);\r\n        plotObj._internalOnce = internalEv.once.bind(internalEv);\r\n        plotObj._removeInternalListener = internalEv.removeListener.bind(internalEv);\r\n        plotObj._removeAllInternalListeners = internalEv.removeAllListeners.bind(internalEv);\r\n\r\n        /*\r\n         * We must wrap emit to continue to support JQuery events. The idea\r\n         * is to check to see if the user is using JQuery events, if they are\r\n         * we emit JQuery events to trigger user handlers as well as the EventEmitter\r\n         * events.\r\n         */\r\n        plotObj.emit = function(event, data) {\r\n            if(typeof jQuery !== 'undefined') {\r\n                jQuery(plotObj).trigger(event, data);\r\n            }\r\n\r\n            ev.emit(event, data);\r\n            internalEv.emit(event, data);\r\n        };\r\n\r\n        return plotObj;\r\n    },\r\n\r\n    /*\r\n     * This function behaves like jQuery's triggerHandler. It calls\r\n     * all handlers for a particular event and returns the return value\r\n     * of the LAST handler. This function also triggers jQuery's\r\n     * triggerHandler for backwards compatibility.\r\n     */\r\n    triggerHandler: function(plotObj, event, data) {\r\n        var jQueryHandlerValue;\r\n        var nodeEventHandlerValue;\r\n\r\n        /*\r\n         * If jQuery exists run all its handlers for this event and\r\n         * collect the return value of the LAST handler function\r\n         */\r\n        if(typeof jQuery !== 'undefined') {\r\n            jQueryHandlerValue = jQuery(plotObj).triggerHandler(event, data);\r\n        }\r\n\r\n        /*\r\n         * Now run all the node style event handlers\r\n         */\r\n        var ev = plotObj._ev;\r\n        if(!ev) return jQueryHandlerValue;\r\n\r\n        var handlers = ev._events[event];\r\n        if(!handlers) return jQueryHandlerValue;\r\n\r\n        // making sure 'this' is the EventEmitter instance\r\n        function apply(handler) {\r\n            // The 'once' case, we can't just call handler() as we need\r\n            // the return value here. So,\r\n            // - remove handler\r\n            // - call listener and grab return value!\r\n            // - stash 'fired' key to not call handler twice\r\n            if(handler.listener) {\r\n                ev.removeListener(event, handler.listener);\r\n                if(!handler.fired) {\r\n                    handler.fired = true;\r\n                    return handler.listener.apply(ev, [data]);\r\n                }\r\n            } else {\r\n                return handler.apply(ev, [data]);\r\n            }\r\n        }\r\n\r\n        // handlers can be function or an array of functions\r\n        handlers = Array.isArray(handlers) ? handlers : [handlers];\r\n\r\n        var i;\r\n        for(i = 0; i < handlers.length - 1; i++) {\r\n            apply(handlers[i]);\r\n        }\r\n        // now call the final handler and collect its value\r\n        nodeEventHandlerValue = apply(handlers[i]);\r\n\r\n        /*\r\n         * Return either the jQuery handler value if it exists or the\r\n         * nodeEventHandler value. jQuery event value supersedes nodejs\r\n         * events for backwards compatibility reasons.\r\n         */\r\n        return jQueryHandlerValue !== undefined ?\r\n            jQueryHandlerValue :\r\n            nodeEventHandlerValue;\r\n    },\r\n\r\n    purge: function(plotObj) {\r\n        delete plotObj._ev;\r\n        delete plotObj.on;\r\n        delete plotObj.once;\r\n        delete plotObj.removeListener;\r\n        delete plotObj.removeAllListeners;\r\n        delete plotObj.emit;\r\n\r\n        delete plotObj._ev;\r\n        delete plotObj._internalEv;\r\n        delete plotObj._internalOn;\r\n        delete plotObj._internalOnce;\r\n        delete plotObj._removeInternalListener;\r\n        delete plotObj._removeAllInternalListeners;\r\n\r\n        return plotObj;\r\n    }\r\n\r\n};\r\n\r\nmodule.exports = Events;\r\n"]},"metadata":{},"sourceType":"script"}
{"ast":null,"code":"'use strict';\n\nvar isNumeric = require('fast-isnumeric');\n\nvar isArrayOrTypedArray = require('./array').isArrayOrTypedArray;\n/**\r\n * convert a string s (such as 'xaxis.range[0]')\r\n * representing a property of nested object into set and get methods\r\n * also return the string and object so we don't have to keep track of them\r\n * allows [-1] for an array index, to set a property inside all elements\r\n * of an array\r\n * eg if obj = {arr: [{a: 1}, {a: 2}]}\r\n * you can do p = nestedProperty(obj, 'arr[-1].a')\r\n * but you cannot set the array itself this way, to do that\r\n * just set the whole array.\r\n * eg if obj = {arr: [1, 2, 3]}\r\n * you can't do nestedProperty(obj, 'arr[-1]').set(5)\r\n * but you can do nestedProperty(obj, 'arr').set([5, 5, 5])\r\n */\n\n\nmodule.exports = function nestedProperty(container, propStr) {\n  if (isNumeric(propStr)) propStr = String(propStr);else if (typeof propStr !== 'string' || propStr.substr(propStr.length - 4) === '[-1]') {\n    throw 'bad property string';\n  }\n  var j = 0;\n  var propParts = propStr.split('.');\n  var indexed;\n  var indices;\n  var i; // check for parts of the nesting hierarchy that are numbers (ie array elements)\n\n  while (j < propParts.length) {\n    // look for non-bracket chars, then any number of [##] blocks\n    indexed = String(propParts[j]).match(/^([^\\[\\]]*)((\\[\\-?[0-9]*\\])+)$/);\n\n    if (indexed) {\n      if (indexed[1]) propParts[j] = indexed[1]; // allow propStr to start with bracketed array indices\n      else if (j === 0) propParts.splice(0, 1);else throw 'bad property string';\n      indices = indexed[2].substr(1, indexed[2].length - 2).split('][');\n\n      for (i = 0; i < indices.length; i++) {\n        j++;\n        propParts.splice(j, 0, Number(indices[i]));\n      }\n    }\n\n    j++;\n  }\n\n  if (typeof container !== 'object') {\n    return badContainer(container, propStr, propParts);\n  }\n\n  return {\n    set: npSet(container, propParts, propStr),\n    get: npGet(container, propParts),\n    astr: propStr,\n    parts: propParts,\n    obj: container\n  };\n};\n\nfunction npGet(cont, parts) {\n  return function () {\n    var curCont = cont;\n    var curPart;\n    var allSame;\n    var out;\n    var i;\n    var j;\n\n    for (i = 0; i < parts.length - 1; i++) {\n      curPart = parts[i];\n\n      if (curPart === -1) {\n        allSame = true;\n        out = [];\n\n        for (j = 0; j < curCont.length; j++) {\n          out[j] = npGet(curCont[j], parts.slice(i + 1))();\n          if (out[j] !== out[0]) allSame = false;\n        }\n\n        return allSame ? out[0] : out;\n      }\n\n      if (typeof curPart === 'number' && !isArrayOrTypedArray(curCont)) {\n        return undefined;\n      }\n\n      curCont = curCont[curPart];\n\n      if (typeof curCont !== 'object' || curCont === null) {\n        return undefined;\n      }\n    } // only hit this if parts.length === 1\n\n\n    if (typeof curCont !== 'object' || curCont === null) return undefined;\n    out = curCont[parts[i]];\n    if (out === null) return undefined;\n    return out;\n  };\n}\n/*\r\n * Can this value be deleted? We can delete `undefined`, and `null` except INSIDE an\r\n * *args* array.\r\n *\r\n * Previously we also deleted some `{}` and `[]`, in order to try and make set/unset\r\n * a net noop; but this causes far more complication than it's worth, and still had\r\n * lots of exceptions. See https://github.com/plotly/plotly.js/issues/1410\r\n *\r\n * *args* arrays get passed directly to API methods and we should respect null if\r\n * the user put it there, but otherwise null is deleted as we use it as code\r\n * in restyle/relayout/update for \"delete this value\" whereas undefined means\r\n * \"ignore this edit\"\r\n */\n\n\nvar ARGS_PATTERN = /(^|\\.)args\\[/;\n\nfunction isDeletable(val, propStr) {\n  return val === undefined || val === null && !propStr.match(ARGS_PATTERN);\n}\n\nfunction npSet(cont, parts, propStr) {\n  return function (val) {\n    var curCont = cont;\n    var propPart = '';\n    var containerLevels = [[cont, propPart]];\n    var toDelete = isDeletable(val, propStr);\n    var curPart;\n    var i;\n\n    for (i = 0; i < parts.length - 1; i++) {\n      curPart = parts[i];\n\n      if (typeof curPart === 'number' && !isArrayOrTypedArray(curCont)) {\n        throw 'array index but container is not an array';\n      } // handle special -1 array index\n\n\n      if (curPart === -1) {\n        toDelete = !setArrayAll(curCont, parts.slice(i + 1), val, propStr);\n        if (toDelete) break;else return;\n      }\n\n      if (!checkNewContainer(curCont, curPart, parts[i + 1], toDelete)) {\n        break;\n      }\n\n      curCont = curCont[curPart];\n\n      if (typeof curCont !== 'object' || curCont === null) {\n        throw 'container is not an object';\n      }\n\n      propPart = joinPropStr(propPart, curPart);\n      containerLevels.push([curCont, propPart]);\n    }\n\n    if (toDelete) {\n      if (i === parts.length - 1) {\n        delete curCont[parts[i]]; // The one bit of pruning we still do: drop `undefined` from the end of arrays.\n        // In case someone has already unset previous items, continue until we hit a\n        // non-undefined value.\n\n        if (Array.isArray(curCont) && +parts[i] === curCont.length - 1) {\n          while (curCont.length && curCont[curCont.length - 1] === undefined) {\n            curCont.pop();\n          }\n        }\n      }\n    } else curCont[parts[i]] = val;\n  };\n}\n\nfunction joinPropStr(propStr, newPart) {\n  var toAdd = newPart;\n  if (isNumeric(newPart)) toAdd = '[' + newPart + ']';else if (propStr) toAdd = '.' + newPart;\n  return propStr + toAdd;\n} // handle special -1 array index\n\n\nfunction setArrayAll(containerArray, innerParts, val, propStr) {\n  var arrayVal = isArrayOrTypedArray(val);\n  var allSet = true;\n  var thisVal = val;\n  var thisPropStr = propStr.replace('-1', 0);\n  var deleteThis = arrayVal ? false : isDeletable(val, thisPropStr);\n  var firstPart = innerParts[0];\n  var i;\n\n  for (i = 0; i < containerArray.length; i++) {\n    thisPropStr = propStr.replace('-1', i);\n\n    if (arrayVal) {\n      thisVal = val[i % val.length];\n      deleteThis = isDeletable(thisVal, thisPropStr);\n    }\n\n    if (deleteThis) allSet = false;\n\n    if (!checkNewContainer(containerArray, i, firstPart, deleteThis)) {\n      continue;\n    }\n\n    npSet(containerArray[i], innerParts, propStr.replace('-1', i))(thisVal);\n  }\n\n  return allSet;\n}\n/**\r\n * make new sub-container as needed.\r\n * returns false if there's no container and none is needed\r\n * because we're only deleting an attribute\r\n */\n\n\nfunction checkNewContainer(container, part, nextPart, toDelete) {\n  if (container[part] === undefined) {\n    if (toDelete) return false;\n    if (typeof nextPart === 'number') container[part] = [];else container[part] = {};\n  }\n\n  return true;\n}\n\nfunction badContainer(container, propStr, propParts) {\n  return {\n    set: function () {\n      throw 'bad container';\n    },\n    get: function () {},\n    astr: propStr,\n    parts: propParts,\n    obj: container\n  };\n}","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/lib/nested_property.js"],"names":["isNumeric","require","isArrayOrTypedArray","module","exports","nestedProperty","container","propStr","String","substr","length","j","propParts","split","indexed","indices","i","match","splice","Number","badContainer","set","npSet","get","npGet","astr","parts","obj","cont","curCont","curPart","allSame","out","slice","undefined","ARGS_PATTERN","isDeletable","val","propPart","containerLevels","toDelete","setArrayAll","checkNewContainer","joinPropStr","push","Array","isArray","pop","newPart","toAdd","containerArray","innerParts","arrayVal","allSet","thisVal","thisPropStr","replace","deleteThis","firstPart","part","nextPart"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar isNumeric = require('fast-isnumeric');\r\nvar isArrayOrTypedArray = require('./array').isArrayOrTypedArray;\r\n\r\n/**\r\n * convert a string s (such as 'xaxis.range[0]')\r\n * representing a property of nested object into set and get methods\r\n * also return the string and object so we don't have to keep track of them\r\n * allows [-1] for an array index, to set a property inside all elements\r\n * of an array\r\n * eg if obj = {arr: [{a: 1}, {a: 2}]}\r\n * you can do p = nestedProperty(obj, 'arr[-1].a')\r\n * but you cannot set the array itself this way, to do that\r\n * just set the whole array.\r\n * eg if obj = {arr: [1, 2, 3]}\r\n * you can't do nestedProperty(obj, 'arr[-1]').set(5)\r\n * but you can do nestedProperty(obj, 'arr').set([5, 5, 5])\r\n */\r\nmodule.exports = function nestedProperty(container, propStr) {\r\n    if(isNumeric(propStr)) propStr = String(propStr);\r\n    else if(typeof propStr !== 'string' ||\r\n            propStr.substr(propStr.length - 4) === '[-1]') {\r\n        throw 'bad property string';\r\n    }\r\n\r\n    var j = 0;\r\n    var propParts = propStr.split('.');\r\n    var indexed;\r\n    var indices;\r\n    var i;\r\n\r\n    // check for parts of the nesting hierarchy that are numbers (ie array elements)\r\n    while(j < propParts.length) {\r\n        // look for non-bracket chars, then any number of [##] blocks\r\n        indexed = String(propParts[j]).match(/^([^\\[\\]]*)((\\[\\-?[0-9]*\\])+)$/);\r\n        if(indexed) {\r\n            if(indexed[1]) propParts[j] = indexed[1];\r\n            // allow propStr to start with bracketed array indices\r\n            else if(j === 0) propParts.splice(0, 1);\r\n            else throw 'bad property string';\r\n\r\n            indices = indexed[2]\r\n                .substr(1, indexed[2].length - 2)\r\n                .split('][');\r\n\r\n            for(i = 0; i < indices.length; i++) {\r\n                j++;\r\n                propParts.splice(j, 0, Number(indices[i]));\r\n            }\r\n        }\r\n        j++;\r\n    }\r\n\r\n    if(typeof container !== 'object') {\r\n        return badContainer(container, propStr, propParts);\r\n    }\r\n\r\n    return {\r\n        set: npSet(container, propParts, propStr),\r\n        get: npGet(container, propParts),\r\n        astr: propStr,\r\n        parts: propParts,\r\n        obj: container\r\n    };\r\n};\r\n\r\nfunction npGet(cont, parts) {\r\n    return function() {\r\n        var curCont = cont;\r\n        var curPart;\r\n        var allSame;\r\n        var out;\r\n        var i;\r\n        var j;\r\n\r\n        for(i = 0; i < parts.length - 1; i++) {\r\n            curPart = parts[i];\r\n            if(curPart === -1) {\r\n                allSame = true;\r\n                out = [];\r\n                for(j = 0; j < curCont.length; j++) {\r\n                    out[j] = npGet(curCont[j], parts.slice(i + 1))();\r\n                    if(out[j] !== out[0]) allSame = false;\r\n                }\r\n                return allSame ? out[0] : out;\r\n            }\r\n            if(typeof curPart === 'number' && !isArrayOrTypedArray(curCont)) {\r\n                return undefined;\r\n            }\r\n            curCont = curCont[curPart];\r\n            if(typeof curCont !== 'object' || curCont === null) {\r\n                return undefined;\r\n            }\r\n        }\r\n\r\n        // only hit this if parts.length === 1\r\n        if(typeof curCont !== 'object' || curCont === null) return undefined;\r\n\r\n        out = curCont[parts[i]];\r\n        if(out === null) return undefined;\r\n        return out;\r\n    };\r\n}\r\n\r\n/*\r\n * Can this value be deleted? We can delete `undefined`, and `null` except INSIDE an\r\n * *args* array.\r\n *\r\n * Previously we also deleted some `{}` and `[]`, in order to try and make set/unset\r\n * a net noop; but this causes far more complication than it's worth, and still had\r\n * lots of exceptions. See https://github.com/plotly/plotly.js/issues/1410\r\n *\r\n * *args* arrays get passed directly to API methods and we should respect null if\r\n * the user put it there, but otherwise null is deleted as we use it as code\r\n * in restyle/relayout/update for \"delete this value\" whereas undefined means\r\n * \"ignore this edit\"\r\n */\r\nvar ARGS_PATTERN = /(^|\\.)args\\[/;\r\nfunction isDeletable(val, propStr) {\r\n    return (val === undefined) || (val === null && !propStr.match(ARGS_PATTERN));\r\n}\r\n\r\nfunction npSet(cont, parts, propStr) {\r\n    return function(val) {\r\n        var curCont = cont;\r\n        var propPart = '';\r\n        var containerLevels = [[cont, propPart]];\r\n        var toDelete = isDeletable(val, propStr);\r\n        var curPart;\r\n        var i;\r\n\r\n        for(i = 0; i < parts.length - 1; i++) {\r\n            curPart = parts[i];\r\n\r\n            if(typeof curPart === 'number' && !isArrayOrTypedArray(curCont)) {\r\n                throw 'array index but container is not an array';\r\n            }\r\n\r\n            // handle special -1 array index\r\n            if(curPart === -1) {\r\n                toDelete = !setArrayAll(curCont, parts.slice(i + 1), val, propStr);\r\n                if(toDelete) break;\r\n                else return;\r\n            }\r\n\r\n            if(!checkNewContainer(curCont, curPart, parts[i + 1], toDelete)) {\r\n                break;\r\n            }\r\n\r\n            curCont = curCont[curPart];\r\n\r\n            if(typeof curCont !== 'object' || curCont === null) {\r\n                throw 'container is not an object';\r\n            }\r\n\r\n            propPart = joinPropStr(propPart, curPart);\r\n\r\n            containerLevels.push([curCont, propPart]);\r\n        }\r\n\r\n        if(toDelete) {\r\n            if(i === parts.length - 1) {\r\n                delete curCont[parts[i]];\r\n\r\n                // The one bit of pruning we still do: drop `undefined` from the end of arrays.\r\n                // In case someone has already unset previous items, continue until we hit a\r\n                // non-undefined value.\r\n                if(Array.isArray(curCont) && +parts[i] === curCont.length - 1) {\r\n                    while(curCont.length && curCont[curCont.length - 1] === undefined) {\r\n                        curCont.pop();\r\n                    }\r\n                }\r\n            }\r\n        } else curCont[parts[i]] = val;\r\n    };\r\n}\r\n\r\nfunction joinPropStr(propStr, newPart) {\r\n    var toAdd = newPart;\r\n    if(isNumeric(newPart)) toAdd = '[' + newPart + ']';\r\n    else if(propStr) toAdd = '.' + newPart;\r\n\r\n    return propStr + toAdd;\r\n}\r\n\r\n// handle special -1 array index\r\nfunction setArrayAll(containerArray, innerParts, val, propStr) {\r\n    var arrayVal = isArrayOrTypedArray(val);\r\n    var allSet = true;\r\n    var thisVal = val;\r\n    var thisPropStr = propStr.replace('-1', 0);\r\n    var deleteThis = arrayVal ? false : isDeletable(val, thisPropStr);\r\n    var firstPart = innerParts[0];\r\n    var i;\r\n\r\n    for(i = 0; i < containerArray.length; i++) {\r\n        thisPropStr = propStr.replace('-1', i);\r\n        if(arrayVal) {\r\n            thisVal = val[i % val.length];\r\n            deleteThis = isDeletable(thisVal, thisPropStr);\r\n        }\r\n        if(deleteThis) allSet = false;\r\n        if(!checkNewContainer(containerArray, i, firstPart, deleteThis)) {\r\n            continue;\r\n        }\r\n        npSet(containerArray[i], innerParts, propStr.replace('-1', i))(thisVal);\r\n    }\r\n    return allSet;\r\n}\r\n\r\n/**\r\n * make new sub-container as needed.\r\n * returns false if there's no container and none is needed\r\n * because we're only deleting an attribute\r\n */\r\nfunction checkNewContainer(container, part, nextPart, toDelete) {\r\n    if(container[part] === undefined) {\r\n        if(toDelete) return false;\r\n\r\n        if(typeof nextPart === 'number') container[part] = [];\r\n        else container[part] = {};\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction badContainer(container, propStr, propParts) {\r\n    return {\r\n        set: function() { throw 'bad container'; },\r\n        get: function() {},\r\n        astr: propStr,\r\n        parts: propParts,\r\n        obj: container\r\n    };\r\n}\r\n"]},"metadata":{},"sourceType":"script"}
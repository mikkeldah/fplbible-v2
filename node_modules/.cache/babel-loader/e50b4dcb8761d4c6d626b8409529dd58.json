{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar timeFormatLocale = require('d3-time-format').timeFormatLocale;\n\nvar isNumeric = require('fast-isnumeric');\n\nvar Registry = require('../registry');\n\nvar PlotSchema = require('../plot_api/plot_schema');\n\nvar Template = require('../plot_api/plot_template');\n\nvar Lib = require('../lib');\n\nvar Color = require('../components/color');\n\nvar BADNUM = require('../constants/numerical').BADNUM;\n\nvar axisIDs = require('./cartesian/axis_ids');\n\nvar clearSelect = require('./cartesian/handle_outline').clearSelect;\n\nvar animationAttrs = require('./animation_attributes');\n\nvar frameAttrs = require('./frame_attributes');\n\nvar getModuleCalcData = require('../plots/get_data').getModuleCalcData;\n\nvar relinkPrivateKeys = Lib.relinkPrivateKeys;\nvar _ = Lib._;\nvar plots = module.exports = {}; // Expose registry methods on Plots for backward-compatibility\n\nLib.extendFlat(plots, Registry);\nplots.attributes = require('./attributes');\nplots.attributes.type.values = plots.allTypes;\nplots.fontAttrs = require('./font_attributes');\nplots.layoutAttributes = require('./layout_attributes'); // TODO make this a plot attribute?\n\nplots.fontWeight = 'normal';\nvar transformsRegistry = plots.transformsRegistry;\n\nvar commandModule = require('./command');\n\nplots.executeAPICommand = commandModule.executeAPICommand;\nplots.computeAPICommandBindings = commandModule.computeAPICommandBindings;\nplots.manageCommandObserver = commandModule.manageCommandObserver;\nplots.hasSimpleAPICommandBindings = commandModule.hasSimpleAPICommandBindings; // in some cases the browser doesn't seem to know how big\n// the text is at first, so it needs to draw it,\n// then wait a little, then draw it again\n\nplots.redrawText = function (gd) {\n  gd = Lib.getGraphDiv(gd);\n  return new Promise(function (resolve) {\n    setTimeout(function () {\n      if (!gd._fullLayout) return;\n      Registry.getComponentMethod('annotations', 'draw')(gd);\n      Registry.getComponentMethod('legend', 'draw')(gd);\n      Registry.getComponentMethod('colorbar', 'draw')(gd);\n      resolve(plots.previousPromises(gd));\n    }, 300);\n  });\n}; // resize plot about the container size\n\n\nplots.resize = function (gd) {\n  gd = Lib.getGraphDiv(gd);\n  var resolveLastResize;\n  var p = new Promise(function (resolve, reject) {\n    if (!gd || Lib.isHidden(gd)) {\n      reject(new Error('Resize must be passed a displayed plot div element.'));\n    }\n\n    if (gd._redrawTimer) clearTimeout(gd._redrawTimer);\n    if (gd._resolveResize) resolveLastResize = gd._resolveResize;\n    gd._resolveResize = resolve;\n    gd._redrawTimer = setTimeout(function () {\n      // return if there is nothing to resize or is hidden\n      if (!gd.layout || gd.layout.width && gd.layout.height || Lib.isHidden(gd)) {\n        resolve(gd);\n        return;\n      }\n\n      delete gd.layout.width;\n      delete gd.layout.height; // autosizing doesn't count as a change that needs saving\n\n      var oldchanged = gd.changed; // nor should it be included in the undo queue\n\n      gd.autoplay = true;\n      Registry.call('relayout', gd, {\n        autosize: true\n      }).then(function () {\n        gd.changed = oldchanged; // Only resolve if a new call hasn't been made!\n\n        if (gd._resolveResize === resolve) {\n          delete gd._resolveResize;\n          resolve(gd);\n        }\n      });\n    }, 100);\n  });\n  if (resolveLastResize) resolveLastResize(p);\n  return p;\n}; // for use in Lib.syncOrAsync, check if there are any\n// pending promises in this plot and wait for them\n\n\nplots.previousPromises = function (gd) {\n  if ((gd._promises || []).length) {\n    return Promise.all(gd._promises).then(function () {\n      gd._promises = [];\n    });\n  }\n};\n/**\r\n * Adds the 'Edit chart' link.\r\n * Note that now _doPlot calls this so it can regenerate whenever it replots\r\n *\r\n * Add source links to your graph inside the 'showSources' config argument.\r\n */\n\n\nplots.addLinks = function (gd) {\n  // Do not do anything if showLink and showSources are not set to true in config\n  if (!gd._context.showLink && !gd._context.showSources) return;\n  var fullLayout = gd._fullLayout;\n  var linkContainer = Lib.ensureSingle(fullLayout._paper, 'text', 'js-plot-link-container', function (s) {\n    s.style({\n      'font-family': '\"Open Sans\", Arial, sans-serif',\n      'font-size': '12px',\n      'fill': Color.defaultLine,\n      'pointer-events': 'all'\n    }).each(function () {\n      var links = d3.select(this);\n      links.append('tspan').classed('js-link-to-tool', true);\n      links.append('tspan').classed('js-link-spacer', true);\n      links.append('tspan').classed('js-sourcelinks', true);\n    });\n  }); // The text node inside svg\n\n  var text = linkContainer.node();\n  var attrs = {\n    y: fullLayout._paper.attr('height') - 9\n  }; // If text's width is bigger than the layout\n  // Check that text is a child node or document.body\n  // because otherwise IE/Edge might throw an exception\n  // when calling getComputedTextLength().\n  // Apparently offsetParent is null for invisibles.\n\n  if (document.body.contains(text) && text.getComputedTextLength() >= fullLayout.width - 20) {\n    // Align the text at the left\n    attrs['text-anchor'] = 'start';\n    attrs.x = 5;\n  } else {\n    // Align the text at the right\n    attrs['text-anchor'] = 'end';\n    attrs.x = fullLayout._paper.attr('width') - 7;\n  }\n\n  linkContainer.attr(attrs);\n  var toolspan = linkContainer.select('.js-link-to-tool');\n  var spacespan = linkContainer.select('.js-link-spacer');\n  var sourcespan = linkContainer.select('.js-sourcelinks');\n  if (gd._context.showSources) gd._context.showSources(gd); // 'view in plotly' link for embedded plots\n\n  if (gd._context.showLink) positionPlayWithData(gd, toolspan); // separator if we have both sources and tool link\n\n  spacespan.text(toolspan.text() && sourcespan.text() ? ' - ' : '');\n}; // note that now this function is only adding the brand in\n// iframes and 3rd-party apps\n\n\nfunction positionPlayWithData(gd, container) {\n  container.text('');\n  var link = container.append('a').attr({\n    'xlink:xlink:href': '#',\n    'class': 'link--impt link--embedview',\n    'font-weight': 'bold'\n  }).text(gd._context.linkText + ' ' + String.fromCharCode(187));\n\n  if (gd._context.sendData) {\n    link.on('click', function () {\n      plots.sendDataToCloud(gd);\n    });\n  } else {\n    var path = window.location.pathname.split('/');\n    var query = window.location.search;\n    link.attr({\n      'xlink:xlink:show': 'new',\n      'xlink:xlink:href': '/' + path[2].split('.')[0] + '/' + path[1] + query\n    });\n  }\n}\n\nplots.sendDataToCloud = function (gd) {\n  var baseUrl = (window.PLOTLYENV || {}).BASE_URL || gd._context.plotlyServerURL;\n  if (!baseUrl) return;\n  gd.emit('plotly_beforeexport');\n  var hiddenformDiv = d3.select(gd).append('div').attr('id', 'hiddenform').style('display', 'none');\n  var hiddenform = hiddenformDiv.append('form').attr({\n    action: baseUrl + '/external',\n    method: 'post',\n    target: '_blank'\n  });\n  var hiddenformInput = hiddenform.append('input').attr({\n    type: 'text',\n    name: 'data'\n  });\n  hiddenformInput.node().value = plots.graphJson(gd, false, 'keepdata');\n  hiddenform.node().submit();\n  hiddenformDiv.remove();\n  gd.emit('plotly_afterexport');\n  return false;\n};\n\nvar d3FormatKeys = ['days', 'shortDays', 'months', 'shortMonths', 'periods', 'dateTime', 'date', 'time', 'decimal', 'thousands', 'grouping', 'currency'];\nvar extraFormatKeys = ['year', 'month', 'dayMonth', 'dayMonthYear'];\n/*\r\n * Fill in default values\r\n * @param {DOM element} gd\r\n * @param {object} opts\r\n * @param {boolean} opts.skipUpdateCalc: normally if the existing gd.calcdata looks\r\n *   compatible with the new gd._fullData we finish by linking the new _fullData traces\r\n *   to the old gd.calcdata, so it's correctly set if we're not going to recalc. But also,\r\n *   if there are calcTransforms on the trace, we first remap data arrays from the old full\r\n *   trace into the new one. Use skipUpdateCalc to defer this (needed by Plotly.react)\r\n *\r\n * gd.data, gd.layout:\r\n *   are precisely what the user specified (except as modified by cleanData/cleanLayout),\r\n *   these fields shouldn't be modified (except for filling in some auto values)\r\n *   nor used directly after the supply defaults step.\r\n *\r\n * gd._fullData, gd._fullLayout:\r\n *   are complete descriptions of how to draw the plot,\r\n *   use these fields in all required computations.\r\n *\r\n * gd._fullLayout._modules\r\n *   is a list of all the trace modules required to draw the plot.\r\n *\r\n * gd._fullLayout._visibleModules\r\n *   subset of _modules, a list of modules corresponding to visible:true traces.\r\n *\r\n * gd._fullLayout._basePlotModules\r\n *   is a list of all the plot modules required to draw the plot.\r\n *\r\n * gd._fullLayout._transformModules\r\n *   is a list of all the transform modules invoked.\r\n *\r\n */\n\nplots.supplyDefaults = function (gd, opts) {\n  var skipUpdateCalc = opts && opts.skipUpdateCalc;\n  var oldFullLayout = gd._fullLayout || {};\n\n  if (oldFullLayout._skipDefaults) {\n    delete oldFullLayout._skipDefaults;\n    return;\n  }\n\n  var newFullLayout = gd._fullLayout = {};\n  var newLayout = gd.layout || {};\n  var oldFullData = gd._fullData || [];\n  var newFullData = gd._fullData = [];\n  var newData = gd.data || [];\n  var oldCalcdata = gd.calcdata || [];\n  var context = gd._context || {};\n  var i; // Create all the storage space for frames, but only if doesn't already exist\n\n  if (!gd._transitionData) plots.createTransitionData(gd); // So we only need to do this once (and since we have gd here)\n  // get the translated placeholder titles.\n  // These ones get used as default values so need to be known at supplyDefaults\n  // others keep their blank defaults but render the placeholder as desired later\n  // TODO: make these work the same way, only inserting the placeholder text at draw time?\n  // The challenge is that this has slightly different behavior right now in editable mode:\n  // using the placeholder as default makes this text permanently (but lightly) visible,\n  // but explicit '' for these titles gives you a placeholder that's hidden until you mouse\n  // over it - so you're not distracted by it if you really don't want a title, but if you do\n  // and you're new to plotly you may not be able to find it.\n  // When editable=false the two behave the same, no title is drawn.\n\n  newFullLayout._dfltTitle = {\n    plot: _(gd, 'Click to enter Plot title'),\n    x: _(gd, 'Click to enter X axis title'),\n    y: _(gd, 'Click to enter Y axis title'),\n    colorbar: _(gd, 'Click to enter Colorscale title'),\n    annotation: _(gd, 'new text')\n  };\n  newFullLayout._traceWord = _(gd, 'trace');\n  var formatObj = getFormatObj(gd, d3FormatKeys); // stash the token from context so mapbox subplots can use it as default\n\n  newFullLayout._mapboxAccessToken = context.mapboxAccessToken; // first fill in what we can of layout without looking at data\n  // because fullData needs a few things from layout\n\n  if (oldFullLayout._initialAutoSizeIsDone) {\n    // coerce the updated layout while preserving width and height\n    var oldWidth = oldFullLayout.width;\n    var oldHeight = oldFullLayout.height;\n    plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);\n    if (!newLayout.width) newFullLayout.width = oldWidth;\n    if (!newLayout.height) newFullLayout.height = oldHeight;\n    plots.sanitizeMargins(newFullLayout);\n  } else {\n    // coerce the updated layout and autosize if needed\n    plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);\n    var missingWidthOrHeight = !newLayout.width || !newLayout.height;\n    var autosize = newFullLayout.autosize;\n    var autosizable = context.autosizable;\n    var initialAutoSize = missingWidthOrHeight && (autosize || autosizable);\n    if (initialAutoSize) plots.plotAutoSize(gd, newLayout, newFullLayout);else if (missingWidthOrHeight) plots.sanitizeMargins(newFullLayout); // for backwards-compatibility with Plotly v1.x.x\n\n    if (!autosize && missingWidthOrHeight) {\n      newLayout.width = newFullLayout.width;\n      newLayout.height = newFullLayout.height;\n    }\n  }\n\n  newFullLayout._d3locale = getFormatter(formatObj, newFullLayout.separators);\n  newFullLayout._extraFormat = getFormatObj(gd, extraFormatKeys);\n  newFullLayout._initialAutoSizeIsDone = true; // keep track of how many traces are inputted\n\n  newFullLayout._dataLength = newData.length; // clear the lists of trace and baseplot modules, and subplots\n\n  newFullLayout._modules = [];\n  newFullLayout._visibleModules = [];\n  newFullLayout._basePlotModules = [];\n  var subplots = newFullLayout._subplots = emptySubplotLists(); // initialize axis and subplot hash objects for splom-generated grids\n\n  var splomAxes = newFullLayout._splomAxes = {\n    x: {},\n    y: {}\n  };\n  var splomSubplots = newFullLayout._splomSubplots = {}; // initialize splom grid defaults\n\n  newFullLayout._splomGridDflt = {}; // for stacked area traces to share config across traces\n\n  newFullLayout._scatterStackOpts = {}; // for the first scatter trace on each subplot (so it knows tonext->tozero)\n\n  newFullLayout._firstScatter = {}; // for grouped bar/box/violin trace to share config across traces\n\n  newFullLayout._alignmentOpts = {}; // track color axes referenced in the data\n\n  newFullLayout._colorAxes = {}; // for traces to request a default rangeslider on their x axes\n  // eg set `_requestRangeslider.x2 = true` for xaxis2\n\n  newFullLayout._requestRangeslider = {}; // pull uids from old data to use as new defaults\n\n  newFullLayout._traceUids = getTraceUids(oldFullData, newData); // then do the data\n\n  newFullLayout._globalTransforms = (gd._context || {}).globalTransforms;\n  plots.supplyDataDefaults(newData, newFullData, newLayout, newFullLayout); // redo grid size defaults with info about splom x/y axes,\n  // and fill in generated cartesian axes and subplots\n\n  var splomXa = Object.keys(splomAxes.x);\n  var splomYa = Object.keys(splomAxes.y);\n\n  if (splomXa.length > 1 && splomYa.length > 1) {\n    Registry.getComponentMethod('grid', 'sizeDefaults')(newLayout, newFullLayout);\n\n    for (i = 0; i < splomXa.length; i++) {\n      Lib.pushUnique(subplots.xaxis, splomXa[i]);\n    }\n\n    for (i = 0; i < splomYa.length; i++) {\n      Lib.pushUnique(subplots.yaxis, splomYa[i]);\n    }\n\n    for (var k in splomSubplots) {\n      Lib.pushUnique(subplots.cartesian, k);\n    }\n  } // attach helper method to check whether a plot type is present on graph\n\n\n  newFullLayout._has = plots._hasPlotType.bind(newFullLayout);\n\n  if (oldFullData.length === newFullData.length) {\n    for (i = 0; i < newFullData.length; i++) {\n      relinkPrivateKeys(newFullData[i], oldFullData[i]);\n    }\n  } // finally, fill in the pieces of layout that may need to look at data\n\n\n  plots.supplyLayoutModuleDefaults(newLayout, newFullLayout, newFullData, gd._transitionData); // Special cases that introduce interactions between traces.\n  // This is after relinkPrivateKeys so we can use those in crossTraceDefaults\n  // and after layout module defaults, so we can use eg barmode\n\n  var _modules = newFullLayout._visibleModules;\n  var crossTraceDefaultsFuncs = [];\n\n  for (i = 0; i < _modules.length; i++) {\n    var funci = _modules[i].crossTraceDefaults; // some trace types share crossTraceDefaults (ie histogram2d, histogram2dcontour)\n\n    if (funci) Lib.pushUnique(crossTraceDefaultsFuncs, funci);\n  }\n\n  for (i = 0; i < crossTraceDefaultsFuncs.length; i++) {\n    crossTraceDefaultsFuncs[i](newFullData, newFullLayout);\n  } // turn on flag to optimize large splom-only graphs\n  // mostly by omitting SVG layers during Cartesian.drawFramework\n\n\n  newFullLayout._hasOnlyLargeSploms = newFullLayout._basePlotModules.length === 1 && newFullLayout._basePlotModules[0].name === 'splom' && splomXa.length > 15 && splomYa.length > 15 && newFullLayout.shapes.length === 0 && newFullLayout.images.length === 0; // relink / initialize subplot axis objects\n\n  plots.linkSubplots(newFullData, newFullLayout, oldFullData, oldFullLayout); // clean subplots and other artifacts from previous plot calls\n\n  plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout);\n  var hadGL2D = !!(oldFullLayout._has && oldFullLayout._has('gl2d'));\n  var hasGL2D = !!(newFullLayout._has && newFullLayout._has('gl2d'));\n  var hadCartesian = !!(oldFullLayout._has && oldFullLayout._has('cartesian'));\n  var hasCartesian = !!(newFullLayout._has && newFullLayout._has('cartesian'));\n  var hadBgLayer = hadCartesian || hadGL2D;\n  var hasBgLayer = hasCartesian || hasGL2D;\n\n  if (hadBgLayer && !hasBgLayer) {\n    // remove bgLayer\n    oldFullLayout._bgLayer.remove();\n  } else if (hasBgLayer && !hadBgLayer) {\n    // create bgLayer\n    newFullLayout._shouldCreateBgLayer = true;\n  } // clear selection outline until we implement persistent selection,\n  // don't clear them though when drag handlers (e.g. listening to\n  // `plotly_selecting`) update the graph.\n  // we should try to come up with a better solution when implementing\n  // https://github.com/plotly/plotly.js/issues/1851\n\n\n  if (oldFullLayout._zoomlayer && !gd._dragging) {\n    clearSelect({\n      // mock old gd\n      _fullLayout: oldFullLayout\n    });\n  } // fill in meta helpers\n\n\n  fillMetaTextHelpers(newFullData, newFullLayout); // relink functions and _ attributes to promote consistency between plots\n\n  relinkPrivateKeys(newFullLayout, oldFullLayout); // colorscale crossTraceDefaults needs newFullLayout with relinked keys\n\n  Registry.getComponentMethod('colorscale', 'crossTraceDefaults')(newFullData, newFullLayout); // For persisting GUI-driven changes in layout\n  // _preGUI and _tracePreGUI were already copied over in relinkPrivateKeys\n\n  if (!newFullLayout._preGUI) newFullLayout._preGUI = {}; // track trace GUI changes by uid rather than by trace index\n\n  if (!newFullLayout._tracePreGUI) newFullLayout._tracePreGUI = {};\n  var tracePreGUI = newFullLayout._tracePreGUI;\n  var uids = {};\n  var uid;\n\n  for (uid in tracePreGUI) uids[uid] = 'old';\n\n  for (i = 0; i < newFullData.length; i++) {\n    uid = newFullData[i]._fullInput.uid;\n    if (!uids[uid]) tracePreGUI[uid] = {};\n    uids[uid] = 'new';\n  }\n\n  for (uid in uids) {\n    if (uids[uid] === 'old') delete tracePreGUI[uid];\n  } // set up containers for margin calculations\n\n\n  initMargins(newFullLayout); // collect and do some initial calculations for rangesliders\n\n  Registry.getComponentMethod('rangeslider', 'makeData')(newFullLayout); // update object references in calcdata\n\n  if (!skipUpdateCalc && oldCalcdata.length === newFullData.length) {\n    plots.supplyDefaultsUpdateCalc(oldCalcdata, newFullData);\n  }\n};\n\nplots.supplyDefaultsUpdateCalc = function (oldCalcdata, newFullData) {\n  for (var i = 0; i < newFullData.length; i++) {\n    var newTrace = newFullData[i];\n    var cd0 = (oldCalcdata[i] || [])[0];\n\n    if (cd0 && cd0.trace) {\n      var oldTrace = cd0.trace;\n\n      if (oldTrace._hasCalcTransform) {\n        var arrayAttrs = oldTrace._arrayAttrs;\n        var j, astr, oldArrayVal;\n\n        for (j = 0; j < arrayAttrs.length; j++) {\n          astr = arrayAttrs[j];\n          oldArrayVal = Lib.nestedProperty(oldTrace, astr).get().slice();\n          Lib.nestedProperty(newTrace, astr).set(oldArrayVal);\n        }\n      }\n\n      cd0.trace = newTrace;\n    }\n  }\n};\n/**\r\n * Create a list of uid strings satisfying (in this order of importance):\r\n * 1. all unique, all strings\r\n * 2. matches input uids if provided\r\n * 3. matches previous data uids\r\n */\n\n\nfunction getTraceUids(oldFullData, newData) {\n  var len = newData.length;\n  var oldFullInput = [];\n  var i, prevFullInput;\n\n  for (i = 0; i < oldFullData.length; i++) {\n    var thisFullInput = oldFullData[i]._fullInput;\n    if (thisFullInput !== prevFullInput) oldFullInput.push(thisFullInput);\n    prevFullInput = thisFullInput;\n  }\n\n  var oldLen = oldFullInput.length;\n  var out = new Array(len);\n  var seenUids = {};\n\n  function setUid(uid, i) {\n    out[i] = uid;\n    seenUids[uid] = 1;\n  }\n\n  function tryUid(uid, i) {\n    if (uid && typeof uid === 'string' && !seenUids[uid]) {\n      setUid(uid, i);\n      return true;\n    }\n  }\n\n  for (i = 0; i < len; i++) {\n    var newUid = newData[i].uid;\n    if (typeof newUid === 'number') newUid = String(newUid);\n    if (tryUid(newUid, i)) continue;\n    if (i < oldLen && tryUid(oldFullInput[i].uid, i)) continue;\n    setUid(Lib.randstr(seenUids), i);\n  }\n\n  return out;\n}\n/**\r\n * Make a container for collecting subplots we need to display.\r\n *\r\n * Finds all subplot types we need to enumerate once and caches it,\r\n * but makes a new output object each time.\r\n * Single-trace subplots (which have no `id`) such as pie, table, etc\r\n * do not need to be collected because we just draw all visible traces.\r\n */\n\n\nfunction emptySubplotLists() {\n  var collectableSubplotTypes = Registry.collectableSubplotTypes;\n  var out = {};\n  var i, j;\n\n  if (!collectableSubplotTypes) {\n    collectableSubplotTypes = [];\n    var subplotsRegistry = Registry.subplotsRegistry;\n\n    for (var subplotType in subplotsRegistry) {\n      var subplotModule = subplotsRegistry[subplotType];\n      var subplotAttr = subplotModule.attr;\n\n      if (subplotAttr) {\n        collectableSubplotTypes.push(subplotType); // special case, currently just for cartesian:\n        // we need to enumerate axes, not just subplots\n\n        if (Array.isArray(subplotAttr)) {\n          for (j = 0; j < subplotAttr.length; j++) {\n            Lib.pushUnique(collectableSubplotTypes, subplotAttr[j]);\n          }\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < collectableSubplotTypes.length; i++) {\n    out[collectableSubplotTypes[i]] = [];\n  }\n\n  return out;\n}\n/**\r\n * getFormatObj: use _context to get the format object from locale.\r\n * Used to get d3.locale argument object and extraFormat argument object\r\n *\r\n * Regarding d3.locale argument :\r\n * decimal and thousands can be overridden later by layout.separators\r\n * grouping and currency are not presently used by our automatic number\r\n * formatting system but can be used by custom formats.\r\n *\r\n * @returns {object} d3.locale format object\r\n */\n\n\nfunction getFormatObj(gd, formatKeys) {\n  var locale = gd._context.locale;\n  if (!locale) locale = 'en-US';\n  var formatDone = false;\n  var formatObj = {};\n\n  function includeFormat(newFormat) {\n    var formatFinished = true;\n\n    for (var i = 0; i < formatKeys.length; i++) {\n      var formatKey = formatKeys[i];\n\n      if (!formatObj[formatKey]) {\n        if (newFormat[formatKey]) {\n          formatObj[formatKey] = newFormat[formatKey];\n        } else formatFinished = false;\n      }\n    }\n\n    if (formatFinished) formatDone = true;\n  } // same as localize, look for format parts in each format spec in the chain\n\n\n  for (var i = 0; i < 2; i++) {\n    var locales = gd._context.locales;\n\n    for (var j = 0; j < 2; j++) {\n      var formatj = (locales[locale] || {}).format;\n\n      if (formatj) {\n        includeFormat(formatj);\n        if (formatDone) break;\n      }\n\n      locales = Registry.localeRegistry;\n    }\n\n    var baseLocale = locale.split('-')[0];\n    if (formatDone || baseLocale === locale) break;\n    locale = baseLocale;\n  } // lastly pick out defaults from english (non-US, as DMY is so much more common)\n\n\n  if (!formatDone) includeFormat(Registry.localeRegistry.en.format);\n  return formatObj;\n}\n/**\r\n * getFormatter: combine the final separators with the locale formatting object\r\n * we pulled earlier to generate number and time formatters\r\n * TODO: remove separators in v3, only use locale, so we don't need this step?\r\n *\r\n * @param {object} formatObj: d3.locale format object\r\n * @param {string} separators: length-2 string to override decimal and thousands\r\n *   separators in number formatting\r\n *\r\n * @returns {object} {numberFormat, timeFormat} d3 formatter factory functions\r\n *   for numbers and time\r\n */\n\n\nfunction getFormatter(formatObj, separators) {\n  formatObj.decimal = separators.charAt(0);\n  formatObj.thousands = separators.charAt(1);\n  return {\n    numberFormat: d3.locale(formatObj).numberFormat,\n    timeFormat: timeFormatLocale(formatObj).utcFormat\n  };\n}\n\nfunction fillMetaTextHelpers(newFullData, newFullLayout) {\n  var _meta;\n\n  var meta4data = [];\n\n  if (newFullLayout.meta) {\n    _meta = newFullLayout._meta = {\n      meta: newFullLayout.meta,\n      layout: {\n        meta: newFullLayout.meta\n      }\n    };\n  }\n\n  for (var i = 0; i < newFullData.length; i++) {\n    var trace = newFullData[i];\n\n    if (trace.meta) {\n      meta4data[trace.index] = trace._meta = {\n        meta: trace.meta\n      };\n    } else if (newFullLayout.meta) {\n      trace._meta = {\n        meta: newFullLayout.meta\n      };\n    }\n\n    if (newFullLayout.meta) {\n      trace._meta.layout = {\n        meta: newFullLayout.meta\n      };\n    }\n  }\n\n  if (meta4data.length) {\n    if (!_meta) {\n      _meta = newFullLayout._meta = {};\n    }\n\n    _meta.data = meta4data;\n  }\n} // Create storage for all of the data related to frames and transitions:\n\n\nplots.createTransitionData = function (gd) {\n  // Set up the default keyframe if it doesn't exist:\n  if (!gd._transitionData) {\n    gd._transitionData = {};\n  }\n\n  if (!gd._transitionData._frames) {\n    gd._transitionData._frames = [];\n  }\n\n  if (!gd._transitionData._frameHash) {\n    gd._transitionData._frameHash = {};\n  }\n\n  if (!gd._transitionData._counter) {\n    gd._transitionData._counter = 0;\n  }\n\n  if (!gd._transitionData._interruptCallbacks) {\n    gd._transitionData._interruptCallbacks = [];\n  }\n}; // helper function to be bound to fullLayout to check\n// whether a certain plot type is present on plot\n// or trace has a category\n\n\nplots._hasPlotType = function (category) {\n  var i; // check base plot modules\n\n  var basePlotModules = this._basePlotModules || [];\n\n  for (i = 0; i < basePlotModules.length; i++) {\n    if (basePlotModules[i].name === category) return true;\n  } // check trace modules (including non-visible:true)\n\n\n  var modules = this._modules || [];\n\n  for (i = 0; i < modules.length; i++) {\n    var name = modules[i].name;\n    if (name === category) return true; // N.B. this is modules[i] along with 'categories' as a hash object\n\n    var _module = Registry.modules[name];\n    if (_module && _module.categories[category]) return true;\n  }\n\n  return false;\n};\n\nplots.cleanPlot = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {\n  var i, j;\n  var basePlotModules = oldFullLayout._basePlotModules || [];\n\n  for (i = 0; i < basePlotModules.length; i++) {\n    var _module = basePlotModules[i];\n\n    if (_module.clean) {\n      _module.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);\n    }\n  }\n\n  var hadGl = oldFullLayout._has && oldFullLayout._has('gl');\n\n  var hasGl = newFullLayout._has && newFullLayout._has('gl');\n\n  if (hadGl && !hasGl) {\n    if (oldFullLayout._glcontainer !== undefined) {\n      oldFullLayout._glcontainer.selectAll('.gl-canvas').remove();\n\n      oldFullLayout._glcontainer.selectAll('.no-webgl').remove();\n\n      oldFullLayout._glcanvas = null;\n    }\n  }\n\n  var hasInfoLayer = !!oldFullLayout._infolayer;\n\n  oldLoop: for (i = 0; i < oldFullData.length; i++) {\n    var oldTrace = oldFullData[i];\n    var oldUid = oldTrace.uid;\n\n    for (j = 0; j < newFullData.length; j++) {\n      var newTrace = newFullData[j];\n      if (oldUid === newTrace.uid) continue oldLoop;\n    } // clean old colorbars\n\n\n    if (hasInfoLayer) {\n      oldFullLayout._infolayer.select('.cb' + oldUid).remove();\n    }\n  }\n};\n\nplots.linkSubplots = function (newFullData, newFullLayout, oldFullData, oldFullLayout) {\n  var i, j;\n  var oldSubplots = oldFullLayout._plots || {};\n  var newSubplots = newFullLayout._plots = {};\n  var newSubplotList = newFullLayout._subplots;\n  var mockGd = {\n    _fullData: newFullData,\n    _fullLayout: newFullLayout\n  };\n  var ids = newSubplotList.cartesian.concat(newSubplotList.gl2d || []);\n\n  for (i = 0; i < ids.length; i++) {\n    var id = ids[i];\n    var oldSubplot = oldSubplots[id];\n    var xaxis = axisIDs.getFromId(mockGd, id, 'x');\n    var yaxis = axisIDs.getFromId(mockGd, id, 'y');\n    var plotinfo; // link or create subplot object\n\n    if (oldSubplot) {\n      plotinfo = newSubplots[id] = oldSubplot;\n    } else {\n      plotinfo = newSubplots[id] = {};\n      plotinfo.id = id;\n    } // add these axis ids to each others' subplot lists\n\n\n    xaxis._counterAxes.push(yaxis._id);\n\n    yaxis._counterAxes.push(xaxis._id);\n\n    xaxis._subplotsWith.push(id);\n\n    yaxis._subplotsWith.push(id); // update x and y axis layout object refs\n\n\n    plotinfo.xaxis = xaxis;\n    plotinfo.yaxis = yaxis; // By default, we clip at the subplot level,\n    // but if one trace on a given subplot has *cliponaxis* set to false,\n    // we need to clip at the trace module layer level;\n    // find this out here, once of for all.\n\n    plotinfo._hasClipOnAxisFalse = false;\n\n    for (j = 0; j < newFullData.length; j++) {\n      var trace = newFullData[j];\n\n      if (trace.xaxis === plotinfo.xaxis._id && trace.yaxis === plotinfo.yaxis._id && trace.cliponaxis === false) {\n        plotinfo._hasClipOnAxisFalse = true;\n        break;\n      }\n    }\n  } // while we're at it, link overlaying axes to their main axes and\n  // anchored axes to the axes they're anchored to\n\n\n  var axList = axisIDs.list(mockGd, null, true);\n  var ax;\n\n  for (i = 0; i < axList.length; i++) {\n    ax = axList[i];\n    var mainAx = null;\n\n    if (ax.overlaying) {\n      mainAx = axisIDs.getFromId(mockGd, ax.overlaying); // you cannot overlay an axis that's already overlaying another\n\n      if (mainAx && mainAx.overlaying) {\n        ax.overlaying = false;\n        mainAx = null;\n      }\n    }\n\n    ax._mainAxis = mainAx || ax;\n    /*\r\n     * For now force overlays to overlay completely... so they\r\n     * can drag together correctly and share backgrounds.\r\n     * Later perhaps we make separate axis domain and\r\n     * tick/line domain or something, so they can still share\r\n     * the (possibly larger) dragger and background but don't\r\n     * have to both be drawn over that whole domain\r\n     */\n\n    if (mainAx) ax.domain = mainAx.domain.slice();\n    ax._anchorAxis = ax.anchor === 'free' ? null : axisIDs.getFromId(mockGd, ax.anchor);\n  } // finally, we can find the main subplot for each axis\n  // (on which the ticks & labels are drawn)\n\n\n  for (i = 0; i < axList.length; i++) {\n    ax = axList[i];\n\n    ax._counterAxes.sort(axisIDs.idSort);\n\n    ax._subplotsWith.sort(Lib.subplotSort);\n\n    ax._mainSubplot = findMainSubplot(ax, newFullLayout); // find \"full\" domain span of counter axes,\n    // this loop can be costly, so only compute it when required\n\n    if (ax._counterAxes.length && (ax.spikemode && ax.spikemode.indexOf('across') !== -1 || ax.automargin && ax.mirror && ax.anchor !== 'free' || Registry.getComponentMethod('rangeslider', 'isVisible')(ax))) {\n      var min = 1;\n      var max = 0;\n\n      for (j = 0; j < ax._counterAxes.length; j++) {\n        var ax2 = axisIDs.getFromId(mockGd, ax._counterAxes[j]);\n        min = Math.min(min, ax2.domain[0]);\n        max = Math.max(max, ax2.domain[1]);\n      }\n\n      if (min < max) {\n        ax._counterDomainMin = min;\n        ax._counterDomainMax = max;\n      }\n    }\n  }\n};\n\nfunction findMainSubplot(ax, fullLayout) {\n  var mockGd = {\n    _fullLayout: fullLayout\n  };\n  var isX = ax._id.charAt(0) === 'x';\n  var anchorAx = ax._mainAxis._anchorAxis;\n  var mainSubplotID = '';\n  var nextBestMainSubplotID = '';\n  var anchorID = ''; // First try the main ID with the anchor\n\n  if (anchorAx) {\n    anchorID = anchorAx._mainAxis._id;\n    mainSubplotID = isX ? ax._id + anchorID : anchorID + ax._id;\n  } // Then look for a subplot with the counteraxis overlaying the anchor\n  // If that fails just use the first subplot including this axis\n\n\n  if (!mainSubplotID || !fullLayout._plots[mainSubplotID]) {\n    mainSubplotID = '';\n    var counterIDs = ax._counterAxes;\n\n    for (var j = 0; j < counterIDs.length; j++) {\n      var counterPart = counterIDs[j];\n      var id = isX ? ax._id + counterPart : counterPart + ax._id;\n      if (!nextBestMainSubplotID) nextBestMainSubplotID = id;\n      var counterAx = axisIDs.getFromId(mockGd, counterPart);\n\n      if (anchorID && counterAx.overlaying === anchorID) {\n        mainSubplotID = id;\n        break;\n      }\n    }\n  }\n\n  return mainSubplotID || nextBestMainSubplotID;\n} // This function clears any trace attributes with valType: color and\n// no set dflt filed in the plot schema. This is needed because groupby (which\n// is the only transform for which this currently applies) supplies parent\n// trace defaults, then expanded trace defaults. The result is that `null`\n// colors are default-supplied and inherited as a color instead of a null.\n// The result is that expanded trace default colors have no effect, with\n// the final result that groups are indistinguishable. This function clears\n// those colors so that individual groupby groups get unique colors.\n\n\nplots.clearExpandedTraceDefaultColors = function (trace) {\n  var colorAttrs, path, i; // This uses weird closure state in order to satisfy the linter rule\n  // that we can't create functions in a loop.\n\n  function locateColorAttrs(attr, attrName, attrs, level) {\n    path[level] = attrName;\n    path.length = level + 1;\n\n    if (attr.valType === 'color' && attr.dflt === undefined) {\n      colorAttrs.push(path.join('.'));\n    }\n  }\n\n  path = []; // Get the cached colorAttrs:\n\n  colorAttrs = trace._module._colorAttrs; // Or else compute and cache the colorAttrs on the module:\n\n  if (!colorAttrs) {\n    trace._module._colorAttrs = colorAttrs = [];\n    PlotSchema.crawl(trace._module.attributes, locateColorAttrs);\n  }\n\n  for (i = 0; i < colorAttrs.length; i++) {\n    var origprop = Lib.nestedProperty(trace, '_input.' + colorAttrs[i]);\n\n    if (!origprop.get()) {\n      Lib.nestedProperty(trace, colorAttrs[i]).set(null);\n    }\n  }\n};\n\nplots.supplyDataDefaults = function (dataIn, dataOut, layout, fullLayout) {\n  var modules = fullLayout._modules;\n  var visibleModules = fullLayout._visibleModules;\n  var basePlotModules = fullLayout._basePlotModules;\n  var cnt = 0;\n  var colorCnt = 0;\n  var i, fullTrace, trace;\n  fullLayout._transformModules = [];\n\n  function pushModule(fullTrace) {\n    dataOut.push(fullTrace);\n    var _module = fullTrace._module;\n    if (!_module) return;\n    Lib.pushUnique(modules, _module);\n    if (fullTrace.visible === true) Lib.pushUnique(visibleModules, _module);\n    Lib.pushUnique(basePlotModules, fullTrace._module.basePlotModule);\n    cnt++; // TODO: do we really want color not to increment for explicitly invisible traces?\n    // This logic is weird, but matches previous behavior: traces that you explicitly\n    // set to visible:false do not increment the color, but traces WE determine to be\n    // empty or invalid (and thus set to visible:false) DO increment color.\n    // I kind of think we should just let all traces increment color, visible or not.\n    // see mock: axes-autotype-empty vs. a test of restyling visible: false that\n    // I can't find right now...\n\n    if (fullTrace._input.visible !== false) colorCnt++;\n  }\n\n  var carpetIndex = {};\n  var carpetDependents = [];\n  var dataTemplate = (layout.template || {}).data || {};\n  var templater = Template.traceTemplater(dataTemplate);\n\n  for (i = 0; i < dataIn.length; i++) {\n    trace = dataIn[i]; // reuse uid we may have pulled out of oldFullData\n    // Note: templater supplies trace type\n\n    fullTrace = templater.newTrace(trace);\n    fullTrace.uid = fullLayout._traceUids[i];\n    plots.supplyTraceDefaults(trace, fullTrace, colorCnt, fullLayout, i);\n    fullTrace.index = i;\n    fullTrace._input = trace;\n    fullTrace._expandedIndex = cnt;\n\n    if (fullTrace.transforms && fullTrace.transforms.length) {\n      var sdInvisible = trace.visible !== false && fullTrace.visible === false;\n      var expandedTraces = applyTransforms(fullTrace, dataOut, layout, fullLayout);\n\n      for (var j = 0; j < expandedTraces.length; j++) {\n        var expandedTrace = expandedTraces[j]; // No further templating during transforms.\n\n        var fullExpandedTrace = {\n          _template: fullTrace._template,\n          type: fullTrace.type,\n          // set uid using parent uid and expanded index\n          // to promote consistency between update calls\n          uid: fullTrace.uid + j\n        }; // If the first supplyDefaults created `visible: false`,\n        // clear it before running supplyDefaults a second time,\n        // because sometimes there are items we still want to coerce\n        // inside trace modules before determining that the trace is\n        // again `visible: false`, for example partial visibilities\n        // in `splom` traces.\n\n        if (sdInvisible && expandedTrace.visible === false) {\n          delete expandedTrace.visible;\n        }\n\n        plots.supplyTraceDefaults(expandedTrace, fullExpandedTrace, cnt, fullLayout, i); // relink private (i.e. underscore) keys expanded trace to full expanded trace so\n        // that transform supply-default methods can set _ keys for future use.\n\n        relinkPrivateKeys(fullExpandedTrace, expandedTrace); // add info about parent data trace\n\n        fullExpandedTrace.index = i;\n        fullExpandedTrace._input = trace;\n        fullExpandedTrace._fullInput = fullTrace; // add info about the expanded data\n\n        fullExpandedTrace._expandedIndex = cnt;\n        fullExpandedTrace._expandedInput = expandedTrace;\n        pushModule(fullExpandedTrace);\n      }\n    } else {\n      // add identify refs for consistency with transformed traces\n      fullTrace._fullInput = fullTrace;\n      fullTrace._expandedInput = fullTrace;\n      pushModule(fullTrace);\n    }\n\n    if (Registry.traceIs(fullTrace, 'carpetAxis')) {\n      carpetIndex[fullTrace.carpet] = fullTrace;\n    }\n\n    if (Registry.traceIs(fullTrace, 'carpetDependent')) {\n      carpetDependents.push(i);\n    }\n  }\n\n  for (i = 0; i < carpetDependents.length; i++) {\n    fullTrace = dataOut[carpetDependents[i]];\n    if (!fullTrace.visible) continue;\n    var carpetAxis = carpetIndex[fullTrace.carpet];\n    fullTrace._carpet = carpetAxis;\n\n    if (!carpetAxis || !carpetAxis.visible) {\n      fullTrace.visible = false;\n      continue;\n    }\n\n    fullTrace.xaxis = carpetAxis.xaxis;\n    fullTrace.yaxis = carpetAxis.yaxis;\n  }\n};\n\nplots.supplyAnimationDefaults = function (opts) {\n  opts = opts || {};\n  var i;\n  var optsOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(opts || {}, optsOut, animationAttrs, attr, dflt);\n  }\n\n  coerce('mode');\n  coerce('direction');\n  coerce('fromcurrent');\n\n  if (Array.isArray(opts.frame)) {\n    optsOut.frame = [];\n\n    for (i = 0; i < opts.frame.length; i++) {\n      optsOut.frame[i] = plots.supplyAnimationFrameDefaults(opts.frame[i] || {});\n    }\n  } else {\n    optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});\n  }\n\n  if (Array.isArray(opts.transition)) {\n    optsOut.transition = [];\n\n    for (i = 0; i < opts.transition.length; i++) {\n      optsOut.transition[i] = plots.supplyAnimationTransitionDefaults(opts.transition[i] || {});\n    }\n  } else {\n    optsOut.transition = plots.supplyAnimationTransitionDefaults(opts.transition || {});\n  }\n\n  return optsOut;\n};\n\nplots.supplyAnimationFrameDefaults = function (opts) {\n  var optsOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(opts || {}, optsOut, animationAttrs.frame, attr, dflt);\n  }\n\n  coerce('duration');\n  coerce('redraw');\n  return optsOut;\n};\n\nplots.supplyAnimationTransitionDefaults = function (opts) {\n  var optsOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(opts || {}, optsOut, animationAttrs.transition, attr, dflt);\n  }\n\n  coerce('duration');\n  coerce('easing');\n  return optsOut;\n};\n\nplots.supplyFrameDefaults = function (frameIn) {\n  var frameOut = {};\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(frameIn, frameOut, frameAttrs, attr, dflt);\n  }\n\n  coerce('group');\n  coerce('name');\n  coerce('traces');\n  coerce('baseframe');\n  coerce('data');\n  coerce('layout');\n  return frameOut;\n};\n\nplots.supplyTraceDefaults = function (traceIn, traceOut, colorIndex, layout, traceInIndex) {\n  var colorway = layout.colorway || Color.defaults;\n  var defaultColor = colorway[colorIndex % colorway.length];\n  var i;\n\n  function coerce(attr, dflt) {\n    return Lib.coerce(traceIn, traceOut, plots.attributes, attr, dflt);\n  }\n\n  var visible = coerce('visible');\n  coerce('type');\n  coerce('name', layout._traceWord + ' ' + traceInIndex);\n  coerce('uirevision', layout.uirevision); // we want even invisible traces to make their would-be subplots visible\n  // so coerce the subplot id(s) now no matter what\n\n  var _module = plots.getModule(traceOut);\n\n  traceOut._module = _module;\n\n  if (_module) {\n    var basePlotModule = _module.basePlotModule;\n    var subplotAttr = basePlotModule.attr;\n    var subplotAttrs = basePlotModule.attributes;\n\n    if (subplotAttr && subplotAttrs) {\n      var subplots = layout._subplots;\n      var subplotId = '';\n\n      if (visible || basePlotModule.name !== 'gl2d' // for now just drop empty gl2d subplots\n      // TODO - currently if we draw an empty gl2d subplot, it draws\n      // nothing then gets stuck and you can't get it back without newPlot\n      // sort this out in the regl refactor?\n      ) {\n          if (Array.isArray(subplotAttr)) {\n            for (i = 0; i < subplotAttr.length; i++) {\n              var attri = subplotAttr[i];\n              var vali = Lib.coerce(traceIn, traceOut, subplotAttrs, attri);\n              if (subplots[attri]) Lib.pushUnique(subplots[attri], vali);\n              subplotId += vali;\n            }\n          } else {\n            subplotId = Lib.coerce(traceIn, traceOut, subplotAttrs, subplotAttr);\n          }\n\n          if (subplots[basePlotModule.name]) {\n            Lib.pushUnique(subplots[basePlotModule.name], subplotId);\n          }\n        }\n    }\n  }\n\n  if (visible) {\n    coerce('customdata');\n    coerce('ids');\n    coerce('meta');\n\n    if (Registry.traceIs(traceOut, 'showLegend')) {\n      Lib.coerce(traceIn, traceOut, _module.attributes.showlegend ? _module.attributes : plots.attributes, 'showlegend');\n      coerce('legendgroup');\n      coerce('legendrank');\n      traceOut._dfltShowLegend = true;\n    } else {\n      traceOut._dfltShowLegend = false;\n    }\n\n    if (_module) {\n      _module.supplyDefaults(traceIn, traceOut, defaultColor, layout);\n    }\n\n    if (!Registry.traceIs(traceOut, 'noOpacity')) {\n      coerce('opacity');\n    }\n\n    if (Registry.traceIs(traceOut, 'notLegendIsolatable')) {\n      // This clears out the legendonly state for traces like carpet that\n      // cannot be isolated in the legend\n      traceOut.visible = !!traceOut.visible;\n    }\n\n    if (!Registry.traceIs(traceOut, 'noHover')) {\n      if (!traceOut.hovertemplate) Lib.coerceHoverinfo(traceIn, traceOut, layout); // parcats support hover, but not hoverlabel stylings (yet)\n\n      if (traceOut.type !== 'parcats') {\n        Registry.getComponentMethod('fx', 'supplyDefaults')(traceIn, traceOut, defaultColor, layout);\n      }\n    }\n\n    if (_module && _module.selectPoints) {\n      coerce('selectedpoints');\n    }\n\n    plots.supplyTransformDefaults(traceIn, traceOut, layout);\n  }\n\n  return traceOut;\n};\n/**\r\n * hasMakesDataTransform: does this trace have a transform that makes its own\r\n * data, either by grabbing it from somewhere else or by creating it from input\r\n * parameters? If so, we should still keep going with supplyDefaults\r\n * even if the trace is invisible, which may just be because it has no data yet.\r\n */\n\n\nfunction hasMakesDataTransform(trace) {\n  var transforms = trace.transforms;\n\n  if (Array.isArray(transforms) && transforms.length) {\n    for (var i = 0; i < transforms.length; i++) {\n      var ti = transforms[i];\n\n      var _module = ti._module || transformsRegistry[ti.type];\n\n      if (_module && _module.makesData) return true;\n    }\n  }\n\n  return false;\n}\n\nplots.hasMakesDataTransform = hasMakesDataTransform;\n\nplots.supplyTransformDefaults = function (traceIn, traceOut, layout) {\n  // For now we only allow transforms on 1D traces, ie those that specify a _length.\n  // If we were to implement 2D transforms, we'd need to have each transform\n  // describe its own applicability and disable itself when it doesn't apply.\n  // Also allow transforms that make their own data, but not in globalTransforms\n  if (!(traceOut._length || hasMakesDataTransform(traceIn))) return;\n  var globalTransforms = layout._globalTransforms || [];\n  var transformModules = layout._transformModules || [];\n  if (!Array.isArray(traceIn.transforms) && globalTransforms.length === 0) return;\n  var containerIn = traceIn.transforms || [];\n  var transformList = globalTransforms.concat(containerIn);\n  var containerOut = traceOut.transforms = [];\n\n  for (var i = 0; i < transformList.length; i++) {\n    var transformIn = transformList[i];\n    var type = transformIn.type;\n    var _module = transformsRegistry[type];\n    var transformOut;\n    /*\r\n     * Supply defaults may run twice. First pass runs all supply defaults steps\r\n     * and adds the _module to any output transforms.\r\n     * If transforms exist another pass is run so that any generated traces also\r\n     * go through supply defaults. This has the effect of rerunning\r\n     * supplyTransformDefaults. If the transform does not have a `transform`\r\n     * function it could not have generated any new traces and the second stage\r\n     * is unnecessary. We detect this case with the following variables.\r\n     */\n\n    var isFirstStage = !(transformIn._module && transformIn._module === _module);\n    var doLaterStages = _module && typeof _module.transform === 'function';\n    if (!_module) Lib.warn('Unrecognized transform type ' + type + '.');\n\n    if (_module && _module.supplyDefaults && (isFirstStage || doLaterStages)) {\n      transformOut = _module.supplyDefaults(transformIn, traceOut, layout, traceIn);\n      transformOut.type = type;\n      transformOut._module = _module;\n      Lib.pushUnique(transformModules, _module);\n    } else {\n      transformOut = Lib.extendFlat({}, transformIn);\n    }\n\n    containerOut.push(transformOut);\n  }\n};\n\nfunction applyTransforms(fullTrace, fullData, layout, fullLayout) {\n  var container = fullTrace.transforms;\n  var dataOut = [fullTrace];\n\n  for (var i = 0; i < container.length; i++) {\n    var transform = container[i];\n    var _module = transformsRegistry[transform.type];\n\n    if (_module && _module.transform) {\n      dataOut = _module.transform(dataOut, {\n        transform: transform,\n        fullTrace: fullTrace,\n        fullData: fullData,\n        layout: layout,\n        fullLayout: fullLayout,\n        transformIndex: i\n      });\n    }\n  }\n\n  return dataOut;\n}\n\nplots.supplyLayoutGlobalDefaults = function (layoutIn, layoutOut, formatObj) {\n  function coerce(attr, dflt) {\n    return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);\n  }\n\n  var template = layoutIn.template;\n\n  if (Lib.isPlainObject(template)) {\n    layoutOut.template = template;\n    layoutOut._template = template.layout;\n    layoutOut._dataTemplate = template.data;\n  }\n\n  coerce('autotypenumbers');\n  var globalFont = Lib.coerceFont(coerce, 'font');\n  coerce('title.text', layoutOut._dfltTitle.plot);\n  Lib.coerceFont(coerce, 'title.font', {\n    family: globalFont.family,\n    size: Math.round(globalFont.size * 1.4),\n    color: globalFont.color\n  });\n  coerce('title.xref');\n  coerce('title.yref');\n  coerce('title.x');\n  coerce('title.y');\n  coerce('title.xanchor');\n  coerce('title.yanchor');\n  coerce('title.pad.t');\n  coerce('title.pad.r');\n  coerce('title.pad.b');\n  coerce('title.pad.l');\n  var uniformtextMode = coerce('uniformtext.mode');\n\n  if (uniformtextMode) {\n    coerce('uniformtext.minsize');\n  } // Make sure that autosize is defaulted to *true*\n  // on layouts with no set width and height for backward compatibly,\n  // in particular https://plotly.com/javascript/responsive-fluid-layout/\n  //\n  // Before https://github.com/plotly/plotly.js/pull/635 ,\n  // layouts with no set width and height were set temporary set to 'initial'\n  // to pass through the autosize routine\n  //\n  // This behavior is subject to change in v3.\n\n\n  coerce('autosize', !(layoutIn.width && layoutIn.height));\n  coerce('width');\n  coerce('height');\n  coerce('margin.l');\n  coerce('margin.r');\n  coerce('margin.t');\n  coerce('margin.b');\n  coerce('margin.pad');\n  coerce('margin.autoexpand');\n  if (layoutIn.width && layoutIn.height) plots.sanitizeMargins(layoutOut);\n  Registry.getComponentMethod('grid', 'sizeDefaults')(layoutIn, layoutOut);\n  coerce('paper_bgcolor');\n  coerce('separators', formatObj.decimal + formatObj.thousands);\n  coerce('hidesources');\n  coerce('colorway');\n  coerce('datarevision');\n  var uirevision = coerce('uirevision');\n  coerce('editrevision', uirevision);\n  coerce('selectionrevision', uirevision);\n  Registry.getComponentMethod('modebar', 'supplyLayoutDefaults')(layoutIn, layoutOut);\n  Registry.getComponentMethod('shapes', 'supplyDrawNewShapeDefaults')(layoutIn, layoutOut, coerce);\n  coerce('meta'); // do not include defaults in fullLayout when users do not set transition\n\n  if (Lib.isPlainObject(layoutIn.transition)) {\n    coerce('transition.duration');\n    coerce('transition.easing');\n    coerce('transition.ordering');\n  }\n\n  Registry.getComponentMethod('calendars', 'handleDefaults')(layoutIn, layoutOut, 'calendar');\n  Registry.getComponentMethod('fx', 'supplyLayoutGlobalDefaults')(layoutIn, layoutOut, coerce);\n};\n\nfunction getComputedSize(attr) {\n  return typeof attr === 'string' && attr.substr(attr.length - 2) === 'px' && parseFloat(attr);\n}\n\nplots.plotAutoSize = function plotAutoSize(gd, layout, fullLayout) {\n  var context = gd._context || {};\n  var frameMargins = context.frameMargins;\n  var newWidth;\n  var newHeight;\n  var isPlotDiv = Lib.isPlotDiv(gd);\n  if (isPlotDiv) gd.emit('plotly_autosize'); // embedded in an iframe - just take the full iframe size\n  // if we get to this point, with no aspect ratio restrictions\n\n  if (context.fillFrame) {\n    newWidth = window.innerWidth;\n    newHeight = window.innerHeight; // somehow we get a few extra px height sometimes...\n    // just hide it\n\n    document.body.style.overflow = 'hidden';\n  } else {\n    // plotly.js - let the developers do what they want, either\n    // provide height and width for the container div,\n    // specify size in layout, or take the defaults,\n    // but don't enforce any ratio restrictions\n    var computedStyle = isPlotDiv ? window.getComputedStyle(gd) : {};\n    newWidth = getComputedSize(computedStyle.width) || getComputedSize(computedStyle.maxWidth) || fullLayout.width;\n    newHeight = getComputedSize(computedStyle.height) || getComputedSize(computedStyle.maxHeight) || fullLayout.height;\n\n    if (isNumeric(frameMargins) && frameMargins > 0) {\n      var factor = 1 - 2 * frameMargins;\n      newWidth = Math.round(factor * newWidth);\n      newHeight = Math.round(factor * newHeight);\n    }\n  }\n\n  var minWidth = plots.layoutAttributes.width.min;\n  var minHeight = plots.layoutAttributes.height.min;\n  if (newWidth < minWidth) newWidth = minWidth;\n  if (newHeight < minHeight) newHeight = minHeight;\n  var widthHasChanged = !layout.width && Math.abs(fullLayout.width - newWidth) > 1;\n  var heightHasChanged = !layout.height && Math.abs(fullLayout.height - newHeight) > 1;\n\n  if (heightHasChanged || widthHasChanged) {\n    if (widthHasChanged) fullLayout.width = newWidth;\n    if (heightHasChanged) fullLayout.height = newHeight;\n  } // cache initial autosize value, used in relayout when\n  // width or height values are set to null\n\n\n  if (!gd._initialAutoSize) {\n    gd._initialAutoSize = {\n      width: newWidth,\n      height: newHeight\n    };\n  }\n\n  plots.sanitizeMargins(fullLayout);\n};\n\nplots.supplyLayoutModuleDefaults = function (layoutIn, layoutOut, fullData, transitionData) {\n  var componentsRegistry = Registry.componentsRegistry;\n  var basePlotModules = layoutOut._basePlotModules;\n\n  var component, i, _module;\n\n  var Cartesian = Registry.subplotsRegistry.cartesian; // check if any components need to add more base plot modules\n  // that weren't captured by traces\n\n  for (component in componentsRegistry) {\n    _module = componentsRegistry[component];\n\n    if (_module.includeBasePlot) {\n      _module.includeBasePlot(layoutIn, layoutOut);\n    }\n  } // make sure we *at least* have some cartesian axes\n\n\n  if (!basePlotModules.length) {\n    basePlotModules.push(Cartesian);\n  } // ensure all cartesian axes have at least one subplot\n\n\n  if (layoutOut._has('cartesian')) {\n    Registry.getComponentMethod('grid', 'contentDefaults')(layoutIn, layoutOut);\n    Cartesian.finalizeSubplots(layoutIn, layoutOut);\n  } // sort subplot lists\n\n\n  for (var subplotType in layoutOut._subplots) {\n    layoutOut._subplots[subplotType].sort(Lib.subplotSort);\n  } // base plot module layout defaults\n\n\n  for (i = 0; i < basePlotModules.length; i++) {\n    _module = basePlotModules[i]; // e.g. pie does not have a layout-defaults step\n\n    if (_module.supplyLayoutDefaults) {\n      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n    }\n  } // trace module layout defaults\n  // use _modules rather than _visibleModules so that even\n  // legendonly traces can include settings - eg barmode, which affects\n  // legend.traceorder default value.\n\n\n  var modules = layoutOut._modules;\n\n  for (i = 0; i < modules.length; i++) {\n    _module = modules[i];\n\n    if (_module.supplyLayoutDefaults) {\n      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n    }\n  } // transform module layout defaults\n\n\n  var transformModules = layoutOut._transformModules;\n\n  for (i = 0; i < transformModules.length; i++) {\n    _module = transformModules[i];\n\n    if (_module.supplyLayoutDefaults) {\n      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData, transitionData);\n    }\n  }\n\n  for (component in componentsRegistry) {\n    _module = componentsRegistry[component];\n\n    if (_module.supplyLayoutDefaults) {\n      _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\n    }\n  }\n}; // Remove all plotly attributes from a div so it can be replotted fresh\n// TODO: these really need to be encapsulated into a much smaller set...\n\n\nplots.purge = function (gd) {\n  // note: we DO NOT remove _context because it doesn't change when we insert\n  // a new plot, and may have been set outside of our scope.\n  var fullLayout = gd._fullLayout || {};\n\n  if (fullLayout._glcontainer !== undefined) {\n    fullLayout._glcontainer.selectAll('.gl-canvas').remove();\n\n    fullLayout._glcontainer.remove();\n\n    fullLayout._glcanvas = null;\n  } // remove modebar\n\n\n  if (fullLayout._modeBar) fullLayout._modeBar.destroy();\n\n  if (gd._transitionData) {\n    // Ensure any dangling callbacks are simply dropped if the plot is purged.\n    // This is more or less only actually important for testing.\n    if (gd._transitionData._interruptCallbacks) {\n      gd._transitionData._interruptCallbacks.length = 0;\n    }\n\n    if (gd._transitionData._animationRaf) {\n      window.cancelAnimationFrame(gd._transitionData._animationRaf);\n    }\n  } // remove any planned throttles\n\n\n  Lib.clearThrottle(); // remove responsive handler\n\n  Lib.clearResponsive(gd); // data and layout\n\n  delete gd.data;\n  delete gd.layout;\n  delete gd._fullData;\n  delete gd._fullLayout;\n  delete gd.calcdata;\n  delete gd.empty;\n  delete gd.fid;\n  delete gd.undoqueue; // action queue\n\n  delete gd.undonum;\n  delete gd.autoplay; // are we doing an action that doesn't go in undo queue?\n\n  delete gd.changed; // these get recreated on _doPlot anyway, but just to be safe\n  // (and to have a record of them...)\n\n  delete gd._promises;\n  delete gd._redrawTimer;\n  delete gd._hmlumcount;\n  delete gd._hmpixcount;\n  delete gd._transitionData;\n  delete gd._transitioning;\n  delete gd._initialAutoSize;\n  delete gd._transitioningWithDuration; // created during certain events, that *should* clean them up\n  // themselves, but may not if there was an error\n\n  delete gd._dragging;\n  delete gd._dragged;\n  delete gd._dragdata;\n  delete gd._hoverdata;\n  delete gd._snapshotInProgress;\n  delete gd._editing;\n  delete gd._mouseDownTime;\n  delete gd._legendMouseDownTime; // remove all event listeners\n\n  if (gd.removeAllListeners) gd.removeAllListeners();\n};\n\nplots.style = function (gd) {\n  var _modules = gd._fullLayout._visibleModules;\n  var styleModules = [];\n  var i; // some trace modules reuse the same style method,\n  // make sure to not unnecessary call them multiple times.\n\n  for (i = 0; i < _modules.length; i++) {\n    var _module = _modules[i];\n\n    if (_module.style) {\n      Lib.pushUnique(styleModules, _module.style);\n    }\n  }\n\n  for (i = 0; i < styleModules.length; i++) {\n    styleModules[i](gd);\n  }\n};\n\nplots.sanitizeMargins = function (fullLayout) {\n  // polar doesn't do margins...\n  if (!fullLayout || !fullLayout.margin) return;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  var margin = fullLayout.margin;\n  var plotWidth = width - (margin.l + margin.r);\n  var plotHeight = height - (margin.t + margin.b);\n  var correction; // if margin.l + margin.r = 0 then plotWidth > 0\n  // as width >= 10 by supplyDefaults\n  // similarly for margin.t + margin.b\n\n  if (plotWidth < 0) {\n    correction = (width - 1) / (margin.l + margin.r);\n    margin.l = Math.floor(correction * margin.l);\n    margin.r = Math.floor(correction * margin.r);\n  }\n\n  if (plotHeight < 0) {\n    correction = (height - 1) / (margin.t + margin.b);\n    margin.t = Math.floor(correction * margin.t);\n    margin.b = Math.floor(correction * margin.b);\n  }\n};\n\nplots.clearAutoMarginIds = function (gd) {\n  gd._fullLayout._pushmarginIds = {};\n};\n\nplots.allowAutoMargin = function (gd, id) {\n  gd._fullLayout._pushmarginIds[id] = 1;\n};\n\nfunction initMargins(fullLayout) {\n  var margin = fullLayout.margin;\n\n  if (!fullLayout._size) {\n    var gs = fullLayout._size = {\n      l: Math.round(margin.l),\n      r: Math.round(margin.r),\n      t: Math.round(margin.t),\n      b: Math.round(margin.b),\n      p: Math.round(margin.pad)\n    };\n    gs.w = Math.round(fullLayout.width) - gs.l - gs.r;\n    gs.h = Math.round(fullLayout.height) - gs.t - gs.b;\n  }\n\n  if (!fullLayout._pushmargin) fullLayout._pushmargin = {};\n  if (!fullLayout._pushmarginIds) fullLayout._pushmarginIds = {};\n} // non-negotiable - this is the smallest height we will allow users to specify via explicit margins\n\n\nvar MIN_SPECIFIED_WIDTH = 2;\nvar MIN_SPECIFIED_HEIGHT = 2; // could be exposed as an option - the smallest we will allow automargin to shrink a larger plot\n\nvar MIN_REDUCED_WIDTH = 64;\nvar MIN_REDUCED_HEIGHT = 64;\n/**\r\n * autoMargin: called by components that may need to expand the margins to\r\n * be rendered on-plot.\r\n *\r\n * @param {DOM element} gd\r\n * @param {string} id - an identifier unique (within this plot) to this object,\r\n *     so we can remove a previous margin expansion from the same object.\r\n * @param {object} o - the margin requirements of this object, or omit to delete\r\n *     this entry (like if it's hidden). Keys are:\r\n *     x, y: plot fraction of the anchor point.\r\n *     xl, xr, yt, yb: if the object has an extent defined in plot fraction,\r\n *         you can specify both edges as plot fractions in each dimension\r\n *     l, r, t, b: the pixels to pad past the plot fraction x[l|r] and y[t|b]\r\n *     pad: extra pixels to add in all directions, default 12 (why?)\r\n */\n\nplots.autoMargin = function (gd, id, o) {\n  var fullLayout = gd._fullLayout;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  var margin = fullLayout.margin;\n  var minFinalWidth = Lib.constrain(width - margin.l - margin.r, MIN_SPECIFIED_WIDTH, MIN_REDUCED_WIDTH);\n  var minFinalHeight = Lib.constrain(height - margin.t - margin.b, MIN_SPECIFIED_HEIGHT, MIN_REDUCED_HEIGHT);\n  var maxSpaceW = Math.max(0, width - minFinalWidth);\n  var maxSpaceH = Math.max(0, height - minFinalHeight);\n  var pushMargin = fullLayout._pushmargin;\n  var pushMarginIds = fullLayout._pushmarginIds;\n\n  if (margin.autoexpand !== false) {\n    if (!o) {\n      delete pushMargin[id];\n      delete pushMarginIds[id];\n    } else {\n      var pad = o.pad;\n\n      if (pad === undefined) {\n        // if no explicit pad is given, use 12px unless there's a\n        // specified margin that's smaller than that\n        pad = Math.min(12, margin.l, margin.r, margin.t, margin.b);\n      } // if the item is too big, just give it enough automargin to\n      // make sure you can still grab it and bring it back\n\n\n      if (maxSpaceW) {\n        var rW = (o.l + o.r) / maxSpaceW;\n\n        if (rW > 1) {\n          o.l /= rW;\n          o.r /= rW;\n        }\n      }\n\n      if (maxSpaceH) {\n        var rH = (o.t + o.b) / maxSpaceH;\n\n        if (rH > 1) {\n          o.t /= rH;\n          o.b /= rH;\n        }\n      }\n\n      var xl = o.xl !== undefined ? o.xl : o.x;\n      var xr = o.xr !== undefined ? o.xr : o.x;\n      var yt = o.yt !== undefined ? o.yt : o.y;\n      var yb = o.yb !== undefined ? o.yb : o.y;\n      pushMargin[id] = {\n        l: {\n          val: xl,\n          size: o.l + pad\n        },\n        r: {\n          val: xr,\n          size: o.r + pad\n        },\n        b: {\n          val: yb,\n          size: o.b + pad\n        },\n        t: {\n          val: yt,\n          size: o.t + pad\n        }\n      };\n      pushMarginIds[id] = 1;\n    }\n\n    if (!fullLayout._replotting) {\n      return plots.doAutoMargin(gd);\n    }\n  }\n};\n\nplots.doAutoMargin = function (gd) {\n  var fullLayout = gd._fullLayout;\n  var width = fullLayout.width;\n  var height = fullLayout.height;\n  if (!fullLayout._size) fullLayout._size = {};\n  initMargins(fullLayout);\n  var gs = fullLayout._size;\n  var margin = fullLayout.margin;\n  var oldMargins = Lib.extendFlat({}, gs); // adjust margins for outside components\n  // fullLayout.margin is the requested margin,\n  // fullLayout._size has margins and plotsize after adjustment\n\n  var ml = margin.l;\n  var mr = margin.r;\n  var mt = margin.t;\n  var mb = margin.b;\n  var pushMargin = fullLayout._pushmargin;\n  var pushMarginIds = fullLayout._pushmarginIds;\n\n  if (fullLayout.margin.autoexpand !== false) {\n    for (var k in pushMargin) {\n      if (!pushMarginIds[k]) delete pushMargin[k];\n    } // fill in the requested margins\n\n\n    pushMargin.base = {\n      l: {\n        val: 0,\n        size: ml\n      },\n      r: {\n        val: 1,\n        size: mr\n      },\n      t: {\n        val: 1,\n        size: mt\n      },\n      b: {\n        val: 0,\n        size: mb\n      }\n    }; // now cycle through all the combinations of l and r\n    // (and t and b) to find the required margins\n\n    for (var k1 in pushMargin) {\n      var pushleft = pushMargin[k1].l || {};\n      var pushbottom = pushMargin[k1].b || {};\n      var fl = pushleft.val;\n      var pl = pushleft.size;\n      var fb = pushbottom.val;\n      var pb = pushbottom.size;\n\n      for (var k2 in pushMargin) {\n        if (isNumeric(pl) && pushMargin[k2].r) {\n          var fr = pushMargin[k2].r.val;\n          var pr = pushMargin[k2].r.size;\n\n          if (fr > fl) {\n            var newL = (pl * fr + (pr - width) * fl) / (fr - fl);\n            var newR = (pr * (1 - fl) + (pl - width) * (1 - fr)) / (fr - fl);\n\n            if (newL + newR > ml + mr) {\n              ml = newL;\n              mr = newR;\n            }\n          }\n        }\n\n        if (isNumeric(pb) && pushMargin[k2].t) {\n          var ft = pushMargin[k2].t.val;\n          var pt = pushMargin[k2].t.size;\n\n          if (ft > fb) {\n            var newB = (pb * ft + (pt - height) * fb) / (ft - fb);\n            var newT = (pt * (1 - fb) + (pb - height) * (1 - ft)) / (ft - fb);\n\n            if (newB + newT > mb + mt) {\n              mb = newB;\n              mt = newT;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  var minFinalWidth = Lib.constrain(width - margin.l - margin.r, MIN_SPECIFIED_WIDTH, MIN_REDUCED_WIDTH);\n  var minFinalHeight = Lib.constrain(height - margin.t - margin.b, MIN_SPECIFIED_HEIGHT, MIN_REDUCED_HEIGHT);\n  var maxSpaceW = Math.max(0, width - minFinalWidth);\n  var maxSpaceH = Math.max(0, height - minFinalHeight);\n\n  if (maxSpaceW) {\n    var rW = (ml + mr) / maxSpaceW;\n\n    if (rW > 1) {\n      ml /= rW;\n      mr /= rW;\n    }\n  }\n\n  if (maxSpaceH) {\n    var rH = (mb + mt) / maxSpaceH;\n\n    if (rH > 1) {\n      mb /= rH;\n      mt /= rH;\n    }\n  }\n\n  gs.l = Math.round(ml);\n  gs.r = Math.round(mr);\n  gs.t = Math.round(mt);\n  gs.b = Math.round(mb);\n  gs.p = Math.round(margin.pad);\n  gs.w = Math.round(width) - gs.l - gs.r;\n  gs.h = Math.round(height) - gs.t - gs.b; // if things changed and we're not already redrawing, trigger a redraw\n\n  if (!fullLayout._replotting && plots.didMarginChange(oldMargins, gs)) {\n    if ('_redrawFromAutoMarginCount' in fullLayout) {\n      fullLayout._redrawFromAutoMarginCount++;\n    } else {\n      fullLayout._redrawFromAutoMarginCount = 1;\n    } // Always allow at least one redraw and give each margin-push\n    // call 3 loops to converge. Of course, for most cases this way too many,\n    // but let's keep things on the safe side until we fix our\n    // auto-margin pipeline problems:\n    // https://github.com/plotly/plotly.js/issues/2704\n\n\n    var maxNumberOfRedraws = 3 * (1 + Object.keys(pushMarginIds).length);\n\n    if (fullLayout._redrawFromAutoMarginCount < maxNumberOfRedraws) {\n      return Registry.call('_doPlot', gd);\n    } else {\n      fullLayout._size = oldMargins;\n      Lib.warn('Too many auto-margin redraws.');\n    }\n  }\n\n  refineTicks(gd);\n};\n\nfunction refineTicks(gd) {\n  var axList = axisIDs.list(gd, '', true);\n  ['_adjustTickLabelsOverflow', '_hideCounterAxisInsideTickLabels'].forEach(function (k) {\n    for (var i = 0; i < axList.length; i++) {\n      var hideFn = axList[i][k];\n      if (hideFn) hideFn();\n    }\n  });\n}\n\nvar marginKeys = ['l', 'r', 't', 'b', 'p', 'w', 'h'];\n\nplots.didMarginChange = function (margin0, margin1) {\n  for (var i = 0; i < marginKeys.length; i++) {\n    var k = marginKeys[i];\n    var m0 = margin0[k];\n    var m1 = margin1[k]; // use 1px tolerance in case we old/new differ only\n    // by rounding errors, which can lead to infinite loops\n\n    if (!isNumeric(m0) || Math.abs(m1 - m0) > 1) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\r\n * JSONify the graph data and layout\r\n *\r\n * This function needs to recurse because some src can be inside\r\n * sub-objects.\r\n *\r\n * It also strips out functions and private (starts with _) elements.\r\n * Therefore, we can add temporary things to data and layout that don't\r\n * get saved.\r\n *\r\n * @param gd The graphDiv\r\n * @param {Boolean} dataonly If true, don't return layout.\r\n * @param {'keepref'|'keepdata'|'keepall'} [mode='keepref'] Filter what's kept\r\n *      keepref: remove data for which there's a src present\r\n *          eg if there's xsrc present (and xsrc is well-formed,\r\n *          ie has : and some chars before it), strip out x\r\n *      keepdata: remove all src tags, don't remove the data itself\r\n *      keepall: keep data and src\r\n * @param {String} output If you specify 'object', the result will not be stringified\r\n * @param {Boolean} useDefaults If truthy, use _fullLayout and _fullData\r\n * @param {Boolean} includeConfig If truthy, include _context\r\n * @returns {Object|String}\r\n */\n\n\nplots.graphJson = function (gd, dataonly, mode, output, useDefaults, includeConfig) {\n  // if the defaults aren't supplied yet, we need to do that...\n  if (useDefaults && dataonly && !gd._fullData || useDefaults && !dataonly && !gd._fullLayout) {\n    plots.supplyDefaults(gd);\n  }\n\n  var data = useDefaults ? gd._fullData : gd.data;\n  var layout = useDefaults ? gd._fullLayout : gd.layout;\n  var frames = (gd._transitionData || {})._frames;\n\n  function stripObj(d, keepFunction) {\n    if (typeof d === 'function') {\n      return keepFunction ? '_function_' : null;\n    }\n\n    if (Lib.isPlainObject(d)) {\n      var o = {};\n      var src;\n      Object.keys(d).sort().forEach(function (v) {\n        // remove private elements and functions\n        // _ is for private, [ is a mistake ie [object Object]\n        if (['_', '['].indexOf(v.charAt(0)) !== -1) return; // if a function, add if necessary then move on\n\n        if (typeof d[v] === 'function') {\n          if (keepFunction) o[v] = '_function';\n          return;\n        } // look for src/data matches and remove the appropriate one\n\n\n        if (mode === 'keepdata') {\n          // keepdata: remove all ...src tags\n          if (v.substr(v.length - 3) === 'src') {\n            return;\n          }\n        } else if (mode === 'keepstream') {\n          // keep sourced data if it's being streamed.\n          // similar to keepref, but if the 'stream' object exists\n          // in a trace, we will keep the data array.\n          src = d[v + 'src'];\n\n          if (typeof src === 'string' && src.indexOf(':') > 0) {\n            if (!Lib.isPlainObject(d.stream)) {\n              return;\n            }\n          }\n        } else if (mode !== 'keepall') {\n          // keepref: remove sourced data but only\n          // if the source tag is well-formed\n          src = d[v + 'src'];\n\n          if (typeof src === 'string' && src.indexOf(':') > 0) {\n            return;\n          }\n        } // OK, we're including this... recurse into it\n\n\n        o[v] = stripObj(d[v], keepFunction);\n      });\n      return o;\n    }\n\n    if (Array.isArray(d)) {\n      return d.map(function (x) {\n        return stripObj(x, keepFunction);\n      });\n    }\n\n    if (Lib.isTypedArray(d)) {\n      return Lib.simpleMap(d, Lib.identity);\n    } // convert native dates to date strings...\n    // mostly for external users exporting to plotly\n\n\n    if (Lib.isJSDate(d)) return Lib.ms2DateTimeLocal(+d);\n    return d;\n  }\n\n  var obj = {\n    data: (data || []).map(function (v) {\n      var d = stripObj(v); // fit has some little arrays in it that don't contain data,\n      // just fit params and meta\n\n      if (dataonly) {\n        delete d.fit;\n      }\n\n      return d;\n    })\n  };\n\n  if (!dataonly) {\n    obj.layout = stripObj(layout);\n\n    if (useDefaults) {\n      var gs = layout._size;\n      obj.layout.computed = {\n        margin: {\n          b: gs.b,\n          l: gs.l,\n          r: gs.r,\n          t: gs.t\n        }\n      };\n    }\n  }\n\n  if (frames) obj.frames = stripObj(frames);\n  if (includeConfig) obj.config = stripObj(gd._context, true);\n  return output === 'object' ? obj : JSON.stringify(obj);\n};\n/**\r\n * Modify a keyframe using a list of operations:\r\n *\r\n * @param {array of objects} operations\r\n *      Sequence of operations to be performed on the keyframes\r\n */\n\n\nplots.modifyFrames = function (gd, operations) {\n  var i, op, frame;\n  var _frames = gd._transitionData._frames;\n  var _frameHash = gd._transitionData._frameHash;\n\n  for (i = 0; i < operations.length; i++) {\n    op = operations[i];\n\n    switch (op.type) {\n      // No reason this couldn't exist, but is currently unused/untested:\n\n      /* case 'rename':\r\n          frame = _frames[op.index];\r\n          delete _frameHash[frame.name];\r\n          _frameHash[op.name] = frame;\r\n          frame.name = op.name;\r\n          break;*/\n      case 'replace':\n        frame = op.value;\n        var oldName = (_frames[op.index] || {}).name;\n        var newName = frame.name;\n        _frames[op.index] = _frameHash[newName] = frame;\n\n        if (newName !== oldName) {\n          // If name has changed in addition to replacement, then update\n          // the lookup table:\n          delete _frameHash[oldName];\n          _frameHash[newName] = frame;\n        }\n\n        break;\n\n      case 'insert':\n        frame = op.value;\n        _frameHash[frame.name] = frame;\n\n        _frames.splice(op.index, 0, frame);\n\n        break;\n\n      case 'delete':\n        frame = _frames[op.index];\n        delete _frameHash[frame.name];\n\n        _frames.splice(op.index, 1);\n\n        break;\n    }\n  }\n\n  return Promise.resolve();\n};\n/*\r\n * Compute a keyframe. Merge a keyframe into its base frame(s) and\r\n * expand properties.\r\n *\r\n * @param {object} frameLookup\r\n *      An object containing frames keyed by name (i.e. gd._transitionData._frameHash)\r\n * @param {string} frame\r\n *      The name of the keyframe to be computed\r\n *\r\n * Returns: a new object with the merged content\r\n */\n\n\nplots.computeFrame = function (gd, frameName) {\n  var frameLookup = gd._transitionData._frameHash;\n  var i, traceIndices, traceIndex, destIndex; // Null or undefined will fail on .toString(). We'll allow numbers since we\n  // make it clear frames must be given string names, but we'll allow numbers\n  // here since they're otherwise fine for looking up frames as long as they're\n  // properly cast to strings. We really just want to ensure here that this\n  // 1) doesn't fail, and\n  // 2) doens't give an incorrect answer (which String(frameName) would)\n\n  if (!frameName) {\n    throw new Error('computeFrame must be given a string frame name');\n  }\n\n  var framePtr = frameLookup[frameName.toString()]; // Return false if the name is invalid:\n\n  if (!framePtr) {\n    return false;\n  }\n\n  var frameStack = [framePtr];\n  var frameNameStack = [framePtr.name]; // Follow frame pointers:\n\n  while (framePtr.baseframe && (framePtr = frameLookup[framePtr.baseframe.toString()])) {\n    // Avoid infinite loops:\n    if (frameNameStack.indexOf(framePtr.name) !== -1) break;\n    frameStack.push(framePtr);\n    frameNameStack.push(framePtr.name);\n  } // A new object for the merged result:\n\n\n  var result = {}; // Merge, starting with the last and ending with the desired frame:\n\n  while (framePtr = frameStack.pop()) {\n    if (framePtr.layout) {\n      result.layout = plots.extendLayout(result.layout, framePtr.layout);\n    }\n\n    if (framePtr.data) {\n      if (!result.data) {\n        result.data = [];\n      }\n\n      traceIndices = framePtr.traces;\n\n      if (!traceIndices) {\n        // If not defined, assume serial order starting at zero\n        traceIndices = [];\n\n        for (i = 0; i < framePtr.data.length; i++) {\n          traceIndices[i] = i;\n        }\n      }\n\n      if (!result.traces) {\n        result.traces = [];\n      }\n\n      for (i = 0; i < framePtr.data.length; i++) {\n        // Loop through this frames data, find out where it should go,\n        // and merge it!\n        traceIndex = traceIndices[i];\n\n        if (traceIndex === undefined || traceIndex === null) {\n          continue;\n        }\n\n        destIndex = result.traces.indexOf(traceIndex);\n\n        if (destIndex === -1) {\n          destIndex = result.data.length;\n          result.traces[destIndex] = traceIndex;\n        }\n\n        result.data[destIndex] = plots.extendTrace(result.data[destIndex], framePtr.data[i]);\n      }\n    }\n  }\n\n  return result;\n};\n/*\r\n * Recompute the lookup table that maps frame name -> frame object. addFrames/\r\n * deleteFrames already manages this data one at a time, so the only time this\r\n * is necessary is if you poke around manually in `gd._transitionData._frames`\r\n * and create and haven't updated the lookup table.\r\n */\n\n\nplots.recomputeFrameHash = function (gd) {\n  var hash = gd._transitionData._frameHash = {};\n  var frames = gd._transitionData._frames;\n\n  for (var i = 0; i < frames.length; i++) {\n    var frame = frames[i];\n\n    if (frame && frame.name) {\n      hash[frame.name] = frame;\n    }\n  }\n};\n/**\r\n * Extend an object, treating container arrays very differently by extracting\r\n * their contents and merging them separately.\r\n *\r\n * This exists so that we can extendDeepNoArrays and avoid stepping into data\r\n * arrays without knowledge of the plot schema, but so that we may also manually\r\n * recurse into known container arrays, such as transforms.\r\n *\r\n * See extendTrace and extendLayout below for usage.\r\n */\n\n\nplots.extendObjectWithContainers = function (dest, src, containerPaths) {\n  var containerProp, containerVal, i, j, srcProp, destProp, srcContainer, destContainer;\n  var copy = Lib.extendDeepNoArrays({}, src || {});\n  var expandedObj = Lib.expandObjectPaths(copy);\n  var containerObj = {}; // Step through and extract any container properties. Otherwise extendDeepNoArrays\n  // will clobber any existing properties with an empty array and then supplyDefaults\n  // will reset everything to defaults.\n\n  if (containerPaths && containerPaths.length) {\n    for (i = 0; i < containerPaths.length; i++) {\n      containerProp = Lib.nestedProperty(expandedObj, containerPaths[i]);\n      containerVal = containerProp.get();\n\n      if (containerVal === undefined) {\n        Lib.nestedProperty(containerObj, containerPaths[i]).set(null);\n      } else {\n        containerProp.set(null);\n        Lib.nestedProperty(containerObj, containerPaths[i]).set(containerVal);\n      }\n    }\n  }\n\n  dest = Lib.extendDeepNoArrays(dest || {}, expandedObj);\n\n  if (containerPaths && containerPaths.length) {\n    for (i = 0; i < containerPaths.length; i++) {\n      srcProp = Lib.nestedProperty(containerObj, containerPaths[i]);\n      srcContainer = srcProp.get();\n      if (!srcContainer) continue;\n      destProp = Lib.nestedProperty(dest, containerPaths[i]);\n      destContainer = destProp.get();\n\n      if (!Array.isArray(destContainer)) {\n        destContainer = [];\n        destProp.set(destContainer);\n      }\n\n      for (j = 0; j < srcContainer.length; j++) {\n        var srcObj = srcContainer[j];\n        if (srcObj === null) destContainer[j] = null;else {\n          destContainer[j] = plots.extendObjectWithContainers(destContainer[j], srcObj);\n        }\n      }\n\n      destProp.set(destContainer);\n    }\n  }\n\n  return dest;\n};\n\nplots.dataArrayContainers = ['transforms', 'dimensions'];\nplots.layoutArrayContainers = Registry.layoutArrayContainers;\n/*\r\n * Extend a trace definition. This method:\r\n *\r\n *  1. directly transfers any array references\r\n *  2. manually recurses into container arrays like transforms\r\n *\r\n * The result is the original object reference with the new contents merged in.\r\n */\n\nplots.extendTrace = function (destTrace, srcTrace) {\n  return plots.extendObjectWithContainers(destTrace, srcTrace, plots.dataArrayContainers);\n};\n/*\r\n * Extend a layout definition. This method:\r\n *\r\n *  1. directly transfers any array references (not critically important for\r\n *     layout since there aren't really data arrays)\r\n *  2. manually recurses into container arrays like annotations\r\n *\r\n * The result is the original object reference with the new contents merged in.\r\n */\n\n\nplots.extendLayout = function (destLayout, srcLayout) {\n  return plots.extendObjectWithContainers(destLayout, srcLayout, plots.layoutArrayContainers);\n};\n/**\r\n * Transition to a set of new data and layout properties from Plotly.animate\r\n *\r\n * @param {DOM element} gd\r\n * @param {Object[]} data\r\n *      an array of data objects following the normal Plotly data definition format\r\n * @param {Object} layout\r\n *      a layout object, following normal Plotly layout format\r\n * @param {Number[]} traces\r\n *      indices of the corresponding traces specified in `data`\r\n * @param {Object} frameOpts\r\n *      options for the frame (i.e. whether to redraw post-transition)\r\n * @param {Object} transitionOpts\r\n *      options for the transition\r\n */\n\n\nplots.transition = function (gd, data, layout, traces, frameOpts, transitionOpts) {\n  var opts = {\n    redraw: frameOpts.redraw\n  };\n  var transitionedTraces = {};\n  var axEdits = [];\n\n  opts.prepareFn = function () {\n    var dataLength = Array.isArray(data) ? data.length : 0;\n    var traceIndices = traces.slice(0, dataLength);\n\n    for (var i = 0; i < traceIndices.length; i++) {\n      var traceIdx = traceIndices[i];\n      var trace = gd._fullData[traceIdx];\n      var _module = trace._module; // There's nothing to do if this module is not defined:\n\n      if (!_module) continue; // Don't register the trace as transitioned if it doesn't know what to do.\n      // If it *is* registered, it will receive a callback that it's responsible\n      // for calling in order to register the transition as having completed.\n\n      if (_module.animatable) {\n        var n = _module.basePlotModule.name;\n        if (!transitionedTraces[n]) transitionedTraces[n] = [];\n        transitionedTraces[n].push(traceIdx);\n      }\n\n      gd.data[traceIndices[i]] = plots.extendTrace(gd.data[traceIndices[i]], data[i]);\n    } // Follow the same procedure. Clone it so we don't mangle the input, then\n    // expand any object paths so we can merge deep into gd.layout:\n\n\n    var layoutUpdate = Lib.expandObjectPaths(Lib.extendDeepNoArrays({}, layout)); // Before merging though, we need to modify the incoming layout. We only\n    // know how to *transition* layout ranges, so it's imperative that a new\n    // range not be sent to the layout before the transition has started. So\n    // we must remove the things we can transition:\n\n    var axisAttrRe = /^[xy]axis[0-9]*$/;\n\n    for (var attr in layoutUpdate) {\n      if (!axisAttrRe.test(attr)) continue;\n      delete layoutUpdate[attr].range;\n    }\n\n    plots.extendLayout(gd.layout, layoutUpdate); // Supply defaults after applying the incoming properties. Note that any attempt\n    // to simplify this step and reduce the amount of work resulted in the reconstruction\n    // of essentially the whole supplyDefaults step, so that it seems sensible to just use\n    // supplyDefaults even though it's heavier than would otherwise be desired for\n    // transitions:\n    // first delete calcdata so supplyDefaults knows a calc step is coming\n\n    delete gd.calcdata;\n    plots.supplyDefaults(gd);\n    plots.doCalcdata(gd);\n    var newLayout = Lib.expandObjectPaths(layout);\n\n    if (newLayout) {\n      var subplots = gd._fullLayout._plots;\n\n      for (var k in subplots) {\n        var plotinfo = subplots[k];\n        var xa = plotinfo.xaxis;\n        var ya = plotinfo.yaxis;\n        var xr0 = xa.range.slice();\n        var yr0 = ya.range.slice();\n        var xr1 = null;\n        var yr1 = null;\n        var editX = null;\n        var editY = null;\n\n        if (Array.isArray(newLayout[xa._name + '.range'])) {\n          xr1 = newLayout[xa._name + '.range'].slice();\n        } else if (Array.isArray((newLayout[xa._name] || {}).range)) {\n          xr1 = newLayout[xa._name].range.slice();\n        }\n\n        if (Array.isArray(newLayout[ya._name + '.range'])) {\n          yr1 = newLayout[ya._name + '.range'].slice();\n        } else if (Array.isArray((newLayout[ya._name] || {}).range)) {\n          yr1 = newLayout[ya._name].range.slice();\n        }\n\n        if (xr0 && xr1 && (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1]))) {\n          editX = {\n            xr0: xr0,\n            xr1: xr1\n          };\n        }\n\n        if (yr0 && yr1 && (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1]))) {\n          editY = {\n            yr0: yr0,\n            yr1: yr1\n          };\n        }\n\n        if (editX || editY) {\n          axEdits.push(Lib.extendFlat({\n            plotinfo: plotinfo\n          }, editX, editY));\n        }\n      }\n    }\n\n    return Promise.resolve();\n  };\n\n  opts.runFn = function (makeCallback) {\n    var traceTransitionOpts;\n    var basePlotModules = gd._fullLayout._basePlotModules;\n    var hasAxisTransition = axEdits.length;\n    var i;\n\n    if (layout) {\n      for (i = 0; i < basePlotModules.length; i++) {\n        if (basePlotModules[i].transitionAxes) {\n          basePlotModules[i].transitionAxes(gd, axEdits, transitionOpts, makeCallback);\n        }\n      }\n    } // Here handle the exception that we refuse to animate scales and axes at the same\n    // time. In other words, if there's an axis transition, then set the data transition\n    // to instantaneous.\n\n\n    if (hasAxisTransition) {\n      traceTransitionOpts = Lib.extendFlat({}, transitionOpts);\n      traceTransitionOpts.duration = 0; // This means do not transition cartesian traces,\n      // this happens on layout-only (e.g. axis range) animations\n\n      delete transitionedTraces.cartesian;\n    } else {\n      traceTransitionOpts = transitionOpts;\n    } // Note that we pass a callback to *create* the callback that must be invoked on completion.\n    // This is since not all traces know about transitions, so it greatly simplifies matters if\n    // the trace is responsible for creating a callback, if needed, and then executing it when\n    // the time is right.\n\n\n    for (var n in transitionedTraces) {\n      var traceIndices = transitionedTraces[n];\n      var _module = gd._fullData[traceIndices[0]]._module;\n\n      _module.basePlotModule.plot(gd, traceIndices, traceTransitionOpts, makeCallback);\n    }\n  };\n\n  return _transition(gd, transitionOpts, opts);\n};\n/**\r\n * Transition to a set of new data and layout properties from Plotly.react\r\n *\r\n * @param {DOM element} gd\r\n * @param {object} restyleFlags\r\n * - anim {'all'|'some'}\r\n * @param {object} relayoutFlags\r\n * - anim {'all'|'some'}\r\n * @param {object} oldFullLayout : old (pre Plotly.react) fullLayout\r\n */\n\n\nplots.transitionFromReact = function (gd, restyleFlags, relayoutFlags, oldFullLayout) {\n  var fullLayout = gd._fullLayout;\n  var transitionOpts = fullLayout.transition;\n  var opts = {};\n  var axEdits = [];\n\n  opts.prepareFn = function () {\n    var subplots = fullLayout._plots; // no need to redraw at end of transition,\n    // if all changes are animatable\n\n    opts.redraw = false;\n    if (restyleFlags.anim === 'some') opts.redraw = true;\n    if (relayoutFlags.anim === 'some') opts.redraw = true;\n\n    for (var k in subplots) {\n      var plotinfo = subplots[k];\n      var xa = plotinfo.xaxis;\n      var ya = plotinfo.yaxis;\n\n      var xr0 = oldFullLayout[xa._name].range.slice();\n\n      var yr0 = oldFullLayout[ya._name].range.slice();\n\n      var xr1 = xa.range.slice();\n      var yr1 = ya.range.slice();\n      xa.setScale();\n      ya.setScale();\n      var editX = null;\n      var editY = null;\n\n      if (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1])) {\n        editX = {\n          xr0: xr0,\n          xr1: xr1\n        };\n      }\n\n      if (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1])) {\n        editY = {\n          yr0: yr0,\n          yr1: yr1\n        };\n      }\n\n      if (editX || editY) {\n        axEdits.push(Lib.extendFlat({\n          plotinfo: plotinfo\n        }, editX, editY));\n      }\n    }\n\n    return Promise.resolve();\n  };\n\n  opts.runFn = function (makeCallback) {\n    var fullData = gd._fullData;\n    var fullLayout = gd._fullLayout;\n    var basePlotModules = fullLayout._basePlotModules;\n    var axisTransitionOpts;\n    var traceTransitionOpts;\n    var transitionedTraces;\n    var allTraceIndices = [];\n\n    for (var i = 0; i < fullData.length; i++) {\n      allTraceIndices.push(i);\n    }\n\n    function transitionAxes() {\n      if (!gd._fullLayout) return;\n\n      for (var j = 0; j < basePlotModules.length; j++) {\n        if (basePlotModules[j].transitionAxes) {\n          basePlotModules[j].transitionAxes(gd, axEdits, axisTransitionOpts, makeCallback);\n        }\n      }\n    }\n\n    function transitionTraces() {\n      if (!gd._fullLayout) return;\n\n      for (var j = 0; j < basePlotModules.length; j++) {\n        basePlotModules[j].plot(gd, transitionedTraces, traceTransitionOpts, makeCallback);\n      }\n    }\n\n    if (axEdits.length && restyleFlags.anim) {\n      if (transitionOpts.ordering === 'traces first') {\n        axisTransitionOpts = Lib.extendFlat({}, transitionOpts, {\n          duration: 0\n        });\n        transitionedTraces = allTraceIndices;\n        traceTransitionOpts = transitionOpts;\n        setTimeout(transitionAxes, transitionOpts.duration);\n        transitionTraces();\n      } else {\n        axisTransitionOpts = transitionOpts;\n        transitionedTraces = null;\n        traceTransitionOpts = Lib.extendFlat({}, transitionOpts, {\n          duration: 0\n        });\n        setTimeout(transitionTraces, axisTransitionOpts.duration);\n        transitionAxes();\n      }\n    } else if (axEdits.length) {\n      axisTransitionOpts = transitionOpts;\n      transitionAxes();\n    } else if (restyleFlags.anim) {\n      transitionedTraces = allTraceIndices;\n      traceTransitionOpts = transitionOpts;\n      transitionTraces();\n    }\n  };\n\n  return _transition(gd, transitionOpts, opts);\n};\n/**\r\n * trace/layout transition wrapper that works\r\n * for transitions initiated by Plotly.animate and Plotly.react.\r\n *\r\n * @param {DOM element} gd\r\n * @param {object} transitionOpts\r\n * @param {object} opts\r\n * - redraw {boolean}\r\n * - prepareFn {function} *should return a Promise*\r\n * - runFn {function} ran inside executeTransitions\r\n */\n\n\nfunction _transition(gd, transitionOpts, opts) {\n  var aborted = false;\n\n  function executeCallbacks(list) {\n    var p = Promise.resolve();\n    if (!list) return p;\n\n    while (list.length) {\n      p = p.then(list.shift());\n    }\n\n    return p;\n  }\n\n  function flushCallbacks(list) {\n    if (!list) return;\n\n    while (list.length) {\n      list.shift();\n    }\n  }\n\n  function executeTransitions() {\n    gd.emit('plotly_transitioning', []);\n    return new Promise(function (resolve) {\n      // This flag is used to disabled things like autorange:\n      gd._transitioning = true; // When instantaneous updates are coming through quickly, it's too much to simply disable\n      // all interaction, so store this flag so we can disambiguate whether mouse interactions\n      // should be fully disabled or not:\n\n      if (transitionOpts.duration > 0) {\n        gd._transitioningWithDuration = true;\n      } // If another transition is triggered, this callback will be executed simply because it's\n      // in the interruptCallbacks queue. If this transition completes, it will instead flush\n      // that queue and forget about this callback.\n\n\n      gd._transitionData._interruptCallbacks.push(function () {\n        aborted = true;\n      });\n\n      if (opts.redraw) {\n        gd._transitionData._interruptCallbacks.push(function () {\n          return Registry.call('redraw', gd);\n        });\n      } // Emit this and make sure it happens last:\n\n\n      gd._transitionData._interruptCallbacks.push(function () {\n        gd.emit('plotly_transitioninterrupted', []);\n      }); // Construct callbacks that are executed on transition end. This ensures the d3 transitions\n      // are *complete* before anything else is done.\n\n\n      var numCallbacks = 0;\n      var numCompleted = 0;\n\n      function makeCallback() {\n        numCallbacks++;\n        return function () {\n          numCompleted++; // When all are complete, perform a redraw:\n\n          if (!aborted && numCompleted === numCallbacks) {\n            completeTransition(resolve);\n          }\n        };\n      }\n\n      opts.runFn(makeCallback); // If nothing else creates a callback, then this will trigger the completion in the next tick:\n\n      setTimeout(makeCallback());\n    });\n  }\n\n  function completeTransition(callback) {\n    // This a simple workaround for tests which purge the graph before animations\n    // have completed. That's not a very common case, so this is the simplest\n    // fix.\n    if (!gd._transitionData) return;\n    flushCallbacks(gd._transitionData._interruptCallbacks);\n    return Promise.resolve().then(function () {\n      if (opts.redraw) {\n        return Registry.call('redraw', gd);\n      }\n    }).then(function () {\n      // Set transitioning false again once the redraw has occurred. This is used, for example,\n      // to prevent the trailing redraw from autoranging:\n      gd._transitioning = false;\n      gd._transitioningWithDuration = false;\n      gd.emit('plotly_transitioned', []);\n    }).then(callback);\n  }\n\n  function interruptPreviousTransitions() {\n    // Fail-safe against purged plot:\n    if (!gd._transitionData) return; // If a transition is interrupted, set this to false. At the moment, the only thing that would\n    // interrupt a transition is another transition, so that it will momentarily be set to true\n    // again, but this determines whether autorange or dragbox work, so it's for the sake of\n    // cleanliness:\n\n    gd._transitioning = false;\n    return executeCallbacks(gd._transitionData._interruptCallbacks);\n  }\n\n  var seq = [plots.previousPromises, interruptPreviousTransitions, opts.prepareFn, plots.rehover, executeTransitions];\n  var transitionStarting = Lib.syncOrAsync(seq, gd);\n\n  if (!transitionStarting || !transitionStarting.then) {\n    transitionStarting = Promise.resolve();\n  }\n\n  return transitionStarting.then(function () {\n    return gd;\n  });\n}\n\nplots.doCalcdata = function (gd, traces) {\n  var axList = axisIDs.list(gd);\n  var fullData = gd._fullData;\n  var fullLayout = gd._fullLayout;\n\n  var trace, _module, i, j; // XXX: Is this correct? Needs a closer look so that *some* traces can be recomputed without\n  // *all* needing doCalcdata:\n\n\n  var calcdata = new Array(fullData.length);\n  var oldCalcdata = (gd.calcdata || []).slice();\n  gd.calcdata = calcdata; // extra helper variables\n  // how many box/violins plots do we have (in case they're grouped)\n\n  fullLayout._numBoxes = 0;\n  fullLayout._numViolins = 0; // initialize violin per-scale-group stats container\n\n  fullLayout._violinScaleGroupStats = {}; // for calculating avg luminosity of heatmaps\n\n  gd._hmpixcount = 0;\n  gd._hmlumcount = 0; // for sharing colors across pies / sunbursts / treemap / icicle / funnelarea (and for legend)\n\n  fullLayout._piecolormap = {};\n  fullLayout._sunburstcolormap = {};\n  fullLayout._treemapcolormap = {};\n  fullLayout._iciclecolormap = {};\n  fullLayout._funnelareacolormap = {}; // If traces were specified and this trace was not included,\n  // then transfer it over from the old calcdata:\n\n  for (i = 0; i < fullData.length; i++) {\n    if (Array.isArray(traces) && traces.indexOf(i) === -1) {\n      calcdata[i] = oldCalcdata[i];\n      continue;\n    }\n  }\n\n  for (i = 0; i < fullData.length; i++) {\n    trace = fullData[i];\n    trace._arrayAttrs = PlotSchema.findArrayAttributes(trace); // keep track of trace extremes (for autorange) in here\n\n    trace._extremes = {};\n  } // add polar axes to axis list\n\n\n  var polarIds = fullLayout._subplots.polar || [];\n\n  for (i = 0; i < polarIds.length; i++) {\n    axList.push(fullLayout[polarIds[i]].radialaxis, fullLayout[polarIds[i]].angularaxis);\n  } // clear relinked cmin/cmax values in shared axes to start aggregation from scratch\n\n\n  for (var k in fullLayout._colorAxes) {\n    var cOpts = fullLayout[k];\n\n    if (cOpts.cauto !== false) {\n      delete cOpts.cmin;\n      delete cOpts.cmax;\n    }\n  }\n\n  var hasCalcTransform = false;\n\n  function transformCalci(i) {\n    trace = fullData[i];\n    _module = trace._module;\n\n    if (trace.visible === true && trace.transforms) {\n      // we need one round of trace module calc before\n      // the calc transform to 'fill in' the categories list\n      // used for example in the data-to-coordinate method\n      if (_module && _module.calc) {\n        var cdi = _module.calc(gd, trace); // must clear scene 'batches', so that 2nd\n        // _module.calc call starts from scratch\n\n\n        if (cdi[0] && cdi[0].t && cdi[0].t._scene) {\n          delete cdi[0].t._scene.dirty;\n        }\n      }\n\n      for (j = 0; j < trace.transforms.length; j++) {\n        var transform = trace.transforms[j];\n        _module = transformsRegistry[transform.type];\n\n        if (_module && _module.calcTransform) {\n          trace._hasCalcTransform = true;\n          hasCalcTransform = true;\n\n          _module.calcTransform(gd, trace, transform);\n        }\n      }\n    }\n  }\n\n  function calci(i, isContainer) {\n    trace = fullData[i];\n    _module = trace._module;\n    if (!!_module.isContainer !== isContainer) return;\n    var cd = [];\n\n    if (trace.visible === true && trace._length !== 0) {\n      // clear existing ref in case it got relinked\n      delete trace._indexToPoints; // keep ref of index-to-points map object of the *last* enabled transform,\n      // this index-to-points map object is required to determine the calcdata indices\n      // that correspond to input indices (e.g. from 'selectedpoints')\n\n      var transforms = trace.transforms || [];\n\n      for (j = transforms.length - 1; j >= 0; j--) {\n        if (transforms[j].enabled) {\n          trace._indexToPoints = transforms[j]._indexToPoints;\n          break;\n        }\n      }\n\n      if (_module && _module.calc) {\n        cd = _module.calc(gd, trace);\n      }\n    } // Make sure there is a first point.\n    //\n    // This ensures there is a calcdata item for every trace,\n    // even if cartesian logic doesn't handle it (for things like legends).\n\n\n    if (!Array.isArray(cd) || !cd[0]) {\n      cd = [{\n        x: BADNUM,\n        y: BADNUM\n      }];\n    } // add the trace-wide properties to the first point,\n    // per point properties to every point\n    // t is the holder for trace-wide properties\n\n\n    if (!cd[0].t) cd[0].t = {};\n    cd[0].trace = trace;\n    calcdata[i] = cd;\n  }\n\n  setupAxisCategories(axList, fullData, fullLayout); // 'transform' loop - must calc container traces first\n  // so that if their dependent traces can get transform properly\n\n  for (i = 0; i < fullData.length; i++) calci(i, true);\n\n  for (i = 0; i < fullData.length; i++) transformCalci(i); // clear stuff that should recomputed in 'regular' loop\n\n\n  if (hasCalcTransform) setupAxisCategories(axList, fullData, fullLayout); // 'regular' loop - make sure container traces (eg carpet) calc before\n  // contained traces (eg contourcarpet)\n\n  for (i = 0; i < fullData.length; i++) calci(i, true);\n\n  for (i = 0; i < fullData.length; i++) calci(i, false);\n\n  doCrossTraceCalc(gd); // Sort axis categories per value if specified\n\n  var sorted = sortAxisCategoriesByValue(axList, gd);\n\n  if (sorted.length) {\n    // how many box/violins plots do we have (in case they're grouped)\n    fullLayout._numBoxes = 0;\n    fullLayout._numViolins = 0; // If a sort operation was performed, run calc() again\n\n    for (i = 0; i < sorted.length; i++) calci(sorted[i], true);\n\n    for (i = 0; i < sorted.length; i++) calci(sorted[i], false);\n\n    doCrossTraceCalc(gd);\n  }\n\n  Registry.getComponentMethod('fx', 'calc')(gd);\n  Registry.getComponentMethod('errorbars', 'calc')(gd);\n};\n\nvar sortAxisCategoriesByValueRegex = /(total|sum|min|max|mean|median) (ascending|descending)/;\n\nfunction sortAxisCategoriesByValue(axList, gd) {\n  var affectedTraces = [];\n  var i, j, k, l, o;\n\n  function zMapCategory(type, ax, value) {\n    var axLetter = ax._id.charAt(0);\n\n    if (type === 'histogram2dcontour') {\n      var counterAxLetter = ax._counterAxes[0];\n      var counterAx = axisIDs.getFromId(gd, counterAxLetter);\n      var xCategorical = axLetter === 'x' || counterAxLetter === 'x' && counterAx.type === 'category';\n      var yCategorical = axLetter === 'y' || counterAxLetter === 'y' && counterAx.type === 'category';\n      return function (o, l) {\n        if (o === 0 || l === 0) return -1; // Skip first row and column\n\n        if (xCategorical && o === value[l].length - 1) return -1;\n        if (yCategorical && l === value.length - 1) return -1;\n        return (axLetter === 'y' ? l : o) - 1;\n      };\n    } else {\n      return function (o, l) {\n        return axLetter === 'y' ? l : o;\n      };\n    }\n  }\n\n  var aggFn = {\n    'min': function (values) {\n      return Lib.aggNums(Math.min, null, values);\n    },\n    'max': function (values) {\n      return Lib.aggNums(Math.max, null, values);\n    },\n    'sum': function (values) {\n      return Lib.aggNums(function (a, b) {\n        return a + b;\n      }, null, values);\n    },\n    'total': function (values) {\n      return Lib.aggNums(function (a, b) {\n        return a + b;\n      }, null, values);\n    },\n    'mean': function (values) {\n      return Lib.mean(values);\n    },\n    'median': function (values) {\n      return Lib.median(values);\n    }\n  };\n\n  for (i = 0; i < axList.length; i++) {\n    var ax = axList[i];\n    if (ax.type !== 'category') continue; // Order by value\n\n    var match = ax.categoryorder.match(sortAxisCategoriesByValueRegex);\n\n    if (match) {\n      var aggregator = match[1];\n      var order = match[2];\n\n      var axLetter = ax._id.charAt(0);\n\n      var isX = axLetter === 'x'; // Store values associated with each category\n\n      var categoriesValue = [];\n\n      for (j = 0; j < ax._categories.length; j++) {\n        categoriesValue.push([ax._categories[j], []]);\n      } // Collect values across traces\n\n\n      for (j = 0; j < ax._traceIndices.length; j++) {\n        var traceIndex = ax._traceIndices[j];\n        var fullTrace = gd._fullData[traceIndex]; // Skip over invisible traces\n\n        if (fullTrace.visible !== true) continue;\n        var type = fullTrace.type;\n\n        if (Registry.traceIs(fullTrace, 'histogram')) {\n          delete fullTrace._xautoBinFinished;\n          delete fullTrace._yautoBinFinished;\n        }\n\n        var isSplom = type === 'splom';\n        var isScattergl = type === 'scattergl';\n        var cd = gd.calcdata[traceIndex];\n\n        for (k = 0; k < cd.length; k++) {\n          var cdi = cd[k];\n          var catIndex, value;\n\n          if (isSplom) {\n            // If `splom`, collect values across dimensions\n            // Find which dimension the current axis is representing\n            var currentDimensionIndex = fullTrace._axesDim[ax._id]; // Apply logic to associated x axis if it's defined\n\n            if (!isX) {\n              var associatedXAxisID = fullTrace._diag[currentDimensionIndex][0];\n              if (associatedXAxisID) ax = gd._fullLayout[axisIDs.id2name(associatedXAxisID)];\n            }\n\n            var categories = cdi.trace.dimensions[currentDimensionIndex].values;\n\n            for (l = 0; l < categories.length; l++) {\n              catIndex = ax._categoriesMap[categories[l]]; // Collect associated values at index `l` over all other dimensions\n\n              for (o = 0; o < cdi.trace.dimensions.length; o++) {\n                if (o === currentDimensionIndex) continue;\n                var dimension = cdi.trace.dimensions[o];\n                categoriesValue[catIndex][1].push(dimension.values[l]);\n              }\n            }\n          } else if (isScattergl) {\n            // If `scattergl`, collect all values stashed under cdi.t\n            for (l = 0; l < cdi.t.x.length; l++) {\n              if (isX) {\n                catIndex = cdi.t.x[l];\n                value = cdi.t.y[l];\n              } else {\n                catIndex = cdi.t.y[l];\n                value = cdi.t.x[l];\n              }\n\n              categoriesValue[catIndex][1].push(value);\n            } // must clear scene 'batches', so that 2nd\n            // _module.calc call starts from scratch\n\n\n            if (cdi.t && cdi.t._scene) {\n              delete cdi.t._scene.dirty;\n            }\n          } else if (cdi.hasOwnProperty('z')) {\n            // If 2dMap, collect values in `z`\n            value = cdi.z;\n            var mapping = zMapCategory(fullTrace.type, ax, value);\n\n            for (l = 0; l < value.length; l++) {\n              for (o = 0; o < value[l].length; o++) {\n                catIndex = mapping(o, l);\n                if (catIndex + 1) categoriesValue[catIndex][1].push(value[l][o]);\n              }\n            }\n          } else {\n            // For all other 2d cartesian traces\n            catIndex = cdi.p;\n            if (catIndex === undefined) catIndex = cdi[axLetter];\n            value = cdi.s;\n            if (value === undefined) value = cdi.v;\n            if (value === undefined) value = isX ? cdi.y : cdi.x;\n\n            if (!Array.isArray(value)) {\n              if (value === undefined) value = [];else value = [value];\n            }\n\n            for (l = 0; l < value.length; l++) {\n              categoriesValue[catIndex][1].push(value[l]);\n            }\n          }\n        }\n      }\n\n      ax._categoriesValue = categoriesValue;\n      var categoriesAggregatedValue = [];\n\n      for (j = 0; j < categoriesValue.length; j++) {\n        categoriesAggregatedValue.push([categoriesValue[j][0], aggFn[aggregator](categoriesValue[j][1])]);\n      } // Sort by aggregated value\n\n\n      categoriesAggregatedValue.sort(function (a, b) {\n        return a[1] - b[1];\n      });\n      ax._categoriesAggregatedValue = categoriesAggregatedValue; // Set new category order\n\n      ax._initialCategories = categoriesAggregatedValue.map(function (c) {\n        return c[0];\n      }); // Reverse if descending\n\n      if (order === 'descending') {\n        ax._initialCategories.reverse();\n      } // Sort all matching axes\n\n\n      affectedTraces = affectedTraces.concat(ax.sortByInitialCategories());\n    }\n  }\n\n  return affectedTraces;\n}\n\nfunction setupAxisCategories(axList, fullData, fullLayout) {\n  var axLookup = {};\n\n  function setupOne(ax) {\n    ax.clearCalc();\n\n    if (ax.type === 'multicategory') {\n      ax.setupMultiCategory(fullData);\n    }\n\n    axLookup[ax._id] = 1;\n  }\n\n  Lib.simpleMap(axList, setupOne); // look into match groups for 'missing' axes\n\n  var matchGroups = fullLayout._axisMatchGroups || [];\n\n  for (var i = 0; i < matchGroups.length; i++) {\n    for (var axId in matchGroups[i]) {\n      if (!axLookup[axId]) {\n        setupOne(fullLayout[axisIDs.id2name(axId)]);\n      }\n    }\n  }\n}\n\nfunction doCrossTraceCalc(gd) {\n  var fullLayout = gd._fullLayout;\n  var modules = fullLayout._visibleModules;\n  var hash = {};\n  var i, j, k; // position and range calculations for traces that\n  // depend on each other ie bars (stacked or grouped)\n  // and boxes (grouped) push each other out of the way\n\n  for (j = 0; j < modules.length; j++) {\n    var _module = modules[j];\n    var fn = _module.crossTraceCalc;\n\n    if (fn) {\n      var spType = _module.basePlotModule.name;\n\n      if (hash[spType]) {\n        Lib.pushUnique(hash[spType], fn);\n      } else {\n        hash[spType] = [fn];\n      }\n    }\n  }\n\n  for (k in hash) {\n    var methods = hash[k];\n    var subplots = fullLayout._subplots[k];\n\n    if (Array.isArray(subplots)) {\n      for (i = 0; i < subplots.length; i++) {\n        var sp = subplots[i];\n        var spInfo = k === 'cartesian' ? fullLayout._plots[sp] : fullLayout[sp];\n\n        for (j = 0; j < methods.length; j++) {\n          methods[j](gd, spInfo, sp);\n        }\n      }\n    } else {\n      for (j = 0; j < methods.length; j++) {\n        methods[j](gd);\n      }\n    }\n  }\n}\n\nplots.rehover = function (gd) {\n  if (gd._fullLayout._rehover) {\n    gd._fullLayout._rehover();\n  }\n};\n\nplots.redrag = function (gd) {\n  if (gd._fullLayout._redrag) {\n    gd._fullLayout._redrag();\n  }\n};\n\nplots.generalUpdatePerTraceModule = function (gd, subplot, subplotCalcData, subplotLayout) {\n  var traceHashOld = subplot.traceHash;\n  var traceHash = {};\n  var i; // build up moduleName -> calcData hash\n\n  for (i = 0; i < subplotCalcData.length; i++) {\n    var calcTraces = subplotCalcData[i];\n    var trace = calcTraces[0].trace; // skip over visible === false traces\n    // as they don't have `_module` ref\n\n    if (trace.visible) {\n      traceHash[trace.type] = traceHash[trace.type] || [];\n      traceHash[trace.type].push(calcTraces);\n    }\n  } // when a trace gets deleted, make sure that its module's\n  // plot method is called so that it is properly\n  // removed from the DOM.\n\n\n  for (var moduleNameOld in traceHashOld) {\n    if (!traceHash[moduleNameOld]) {\n      var fakeCalcTrace = traceHashOld[moduleNameOld][0];\n      var fakeTrace = fakeCalcTrace[0].trace;\n      fakeTrace.visible = false;\n      traceHash[moduleNameOld] = [fakeCalcTrace];\n    }\n  } // call module plot method\n\n\n  for (var moduleName in traceHash) {\n    var moduleCalcData = traceHash[moduleName];\n    var _module = moduleCalcData[0][0].trace._module;\n\n    _module.plot(gd, subplot, Lib.filterVisible(moduleCalcData), subplotLayout);\n  } // update moduleName -> calcData hash\n\n\n  subplot.traceHash = traceHash;\n};\n\nplots.plotBasePlot = function (desiredType, gd, traces, transitionOpts, makeOnCompleteCallback) {\n  var _module = Registry.getModule(desiredType);\n\n  var cdmodule = getModuleCalcData(gd.calcdata, _module)[0];\n\n  _module.plot(gd, cdmodule, transitionOpts, makeOnCompleteCallback);\n};\n\nplots.cleanBasePlot = function (desiredType, newFullData, newFullLayout, oldFullData, oldFullLayout) {\n  var had = oldFullLayout._has && oldFullLayout._has(desiredType);\n\n  var has = newFullLayout._has && newFullLayout._has(desiredType);\n\n  if (had && !has) {\n    oldFullLayout['_' + desiredType + 'layer'].selectAll('g.trace').remove();\n  }\n};","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/plots/plots.js"],"names":["d3","require","timeFormatLocale","isNumeric","Registry","PlotSchema","Template","Lib","Color","BADNUM","axisIDs","clearSelect","animationAttrs","frameAttrs","getModuleCalcData","relinkPrivateKeys","_","plots","module","exports","extendFlat","attributes","type","values","allTypes","fontAttrs","layoutAttributes","fontWeight","transformsRegistry","commandModule","executeAPICommand","computeAPICommandBindings","manageCommandObserver","hasSimpleAPICommandBindings","redrawText","gd","getGraphDiv","Promise","resolve","setTimeout","_fullLayout","getComponentMethod","previousPromises","resize","resolveLastResize","p","reject","isHidden","Error","_redrawTimer","clearTimeout","_resolveResize","layout","width","height","oldchanged","changed","autoplay","call","autosize","then","_promises","length","all","addLinks","_context","showLink","showSources","fullLayout","linkContainer","ensureSingle","_paper","s","style","defaultLine","each","links","select","append","classed","text","node","attrs","y","attr","document","body","contains","getComputedTextLength","x","toolspan","spacespan","sourcespan","positionPlayWithData","container","link","linkText","String","fromCharCode","sendData","on","sendDataToCloud","path","window","location","pathname","split","query","search","baseUrl","PLOTLYENV","BASE_URL","plotlyServerURL","emit","hiddenformDiv","hiddenform","action","method","target","hiddenformInput","name","value","graphJson","submit","remove","d3FormatKeys","extraFormatKeys","supplyDefaults","opts","skipUpdateCalc","oldFullLayout","_skipDefaults","newFullLayout","newLayout","oldFullData","_fullData","newFullData","newData","data","oldCalcdata","calcdata","context","i","_transitionData","createTransitionData","_dfltTitle","plot","colorbar","annotation","_traceWord","formatObj","getFormatObj","_mapboxAccessToken","mapboxAccessToken","_initialAutoSizeIsDone","oldWidth","oldHeight","supplyLayoutGlobalDefaults","sanitizeMargins","missingWidthOrHeight","autosizable","initialAutoSize","plotAutoSize","_d3locale","getFormatter","separators","_extraFormat","_dataLength","_modules","_visibleModules","_basePlotModules","subplots","_subplots","emptySubplotLists","splomAxes","_splomAxes","splomSubplots","_splomSubplots","_splomGridDflt","_scatterStackOpts","_firstScatter","_alignmentOpts","_colorAxes","_requestRangeslider","_traceUids","getTraceUids","_globalTransforms","globalTransforms","supplyDataDefaults","splomXa","Object","keys","splomYa","pushUnique","xaxis","yaxis","k","cartesian","_has","_hasPlotType","bind","supplyLayoutModuleDefaults","crossTraceDefaultsFuncs","funci","crossTraceDefaults","_hasOnlyLargeSploms","shapes","images","linkSubplots","cleanPlot","hadGL2D","hasGL2D","hadCartesian","hasCartesian","hadBgLayer","hasBgLayer","_bgLayer","_shouldCreateBgLayer","_zoomlayer","_dragging","fillMetaTextHelpers","_preGUI","_tracePreGUI","tracePreGUI","uids","uid","_fullInput","initMargins","supplyDefaultsUpdateCalc","newTrace","cd0","trace","oldTrace","_hasCalcTransform","arrayAttrs","_arrayAttrs","j","astr","oldArrayVal","nestedProperty","get","slice","set","len","oldFullInput","prevFullInput","thisFullInput","push","oldLen","out","Array","seenUids","setUid","tryUid","newUid","randstr","collectableSubplotTypes","subplotsRegistry","subplotType","subplotModule","subplotAttr","isArray","formatKeys","locale","formatDone","includeFormat","newFormat","formatFinished","formatKey","locales","formatj","format","localeRegistry","baseLocale","en","decimal","charAt","thousands","numberFormat","timeFormat","utcFormat","_meta","meta4data","meta","index","_frames","_frameHash","_counter","_interruptCallbacks","category","basePlotModules","modules","_module","categories","clean","hadGl","hasGl","_glcontainer","undefined","selectAll","_glcanvas","hasInfoLayer","_infolayer","oldLoop","oldUid","oldSubplots","_plots","newSubplots","newSubplotList","mockGd","ids","concat","gl2d","id","oldSubplot","getFromId","plotinfo","_counterAxes","_id","_subplotsWith","_hasClipOnAxisFalse","cliponaxis","axList","list","ax","mainAx","overlaying","_mainAxis","domain","_anchorAxis","anchor","sort","idSort","subplotSort","_mainSubplot","findMainSubplot","spikemode","indexOf","automargin","mirror","min","max","ax2","Math","_counterDomainMin","_counterDomainMax","isX","anchorAx","mainSubplotID","nextBestMainSubplotID","anchorID","counterIDs","counterPart","counterAx","clearExpandedTraceDefaultColors","colorAttrs","locateColorAttrs","attrName","level","valType","dflt","join","_colorAttrs","crawl","origprop","dataIn","dataOut","visibleModules","cnt","colorCnt","fullTrace","_transformModules","pushModule","visible","basePlotModule","_input","carpetIndex","carpetDependents","dataTemplate","template","templater","traceTemplater","supplyTraceDefaults","_expandedIndex","transforms","sdInvisible","expandedTraces","applyTransforms","expandedTrace","fullExpandedTrace","_template","_expandedInput","traceIs","carpet","carpetAxis","_carpet","supplyAnimationDefaults","optsOut","coerce","frame","supplyAnimationFrameDefaults","transition","supplyAnimationTransitionDefaults","supplyFrameDefaults","frameIn","frameOut","traceIn","traceOut","colorIndex","traceInIndex","colorway","defaults","defaultColor","uirevision","getModule","subplotAttrs","subplotId","attri","vali","showlegend","_dfltShowLegend","hovertemplate","coerceHoverinfo","selectPoints","supplyTransformDefaults","hasMakesDataTransform","ti","makesData","_length","transformModules","containerIn","transformList","containerOut","transformIn","transformOut","isFirstStage","doLaterStages","transform","warn","fullData","transformIndex","layoutIn","layoutOut","isPlainObject","_dataTemplate","globalFont","coerceFont","family","size","round","color","uniformtextMode","getComputedSize","substr","parseFloat","frameMargins","newWidth","newHeight","isPlotDiv","fillFrame","innerWidth","innerHeight","overflow","computedStyle","getComputedStyle","maxWidth","maxHeight","factor","minWidth","minHeight","widthHasChanged","abs","heightHasChanged","_initialAutoSize","transitionData","componentsRegistry","component","Cartesian","includeBasePlot","finalizeSubplots","supplyLayoutDefaults","purge","_modeBar","destroy","_animationRaf","cancelAnimationFrame","clearThrottle","clearResponsive","empty","fid","undoqueue","undonum","_hmlumcount","_hmpixcount","_transitioning","_transitioningWithDuration","_dragged","_dragdata","_hoverdata","_snapshotInProgress","_editing","_mouseDownTime","_legendMouseDownTime","removeAllListeners","styleModules","margin","plotWidth","l","r","plotHeight","t","b","correction","floor","clearAutoMarginIds","_pushmarginIds","allowAutoMargin","_size","gs","pad","w","h","_pushmargin","MIN_SPECIFIED_WIDTH","MIN_SPECIFIED_HEIGHT","MIN_REDUCED_WIDTH","MIN_REDUCED_HEIGHT","autoMargin","o","minFinalWidth","constrain","minFinalHeight","maxSpaceW","maxSpaceH","pushMargin","pushMarginIds","autoexpand","rW","rH","xl","xr","yt","yb","val","_replotting","doAutoMargin","oldMargins","ml","mr","mt","mb","base","k1","pushleft","pushbottom","fl","pl","fb","pb","k2","fr","pr","newL","newR","ft","pt","newB","newT","didMarginChange","_redrawFromAutoMarginCount","maxNumberOfRedraws","refineTicks","forEach","hideFn","marginKeys","margin0","margin1","m0","m1","dataonly","mode","output","useDefaults","includeConfig","frames","stripObj","d","keepFunction","src","v","stream","map","isTypedArray","simpleMap","identity","isJSDate","ms2DateTimeLocal","obj","fit","computed","config","JSON","stringify","modifyFrames","operations","op","oldName","newName","splice","computeFrame","frameName","frameLookup","traceIndices","traceIndex","destIndex","framePtr","toString","frameStack","frameNameStack","baseframe","result","pop","extendLayout","traces","extendTrace","recomputeFrameHash","hash","extendObjectWithContainers","dest","containerPaths","containerProp","containerVal","srcProp","destProp","srcContainer","destContainer","copy","extendDeepNoArrays","expandedObj","expandObjectPaths","containerObj","srcObj","dataArrayContainers","layoutArrayContainers","destTrace","srcTrace","destLayout","srcLayout","frameOpts","transitionOpts","redraw","transitionedTraces","axEdits","prepareFn","dataLength","traceIdx","animatable","n","layoutUpdate","axisAttrRe","test","range","doCalcdata","xa","ya","xr0","yr0","xr1","yr1","editX","editY","_name","r2l","runFn","makeCallback","traceTransitionOpts","hasAxisTransition","transitionAxes","duration","_transition","transitionFromReact","restyleFlags","relayoutFlags","anim","setScale","axisTransitionOpts","allTraceIndices","transitionTraces","ordering","aborted","executeCallbacks","shift","flushCallbacks","executeTransitions","numCallbacks","numCompleted","completeTransition","callback","interruptPreviousTransitions","seq","rehover","transitionStarting","syncOrAsync","_numBoxes","_numViolins","_violinScaleGroupStats","_piecolormap","_sunburstcolormap","_treemapcolormap","_iciclecolormap","_funnelareacolormap","findArrayAttributes","_extremes","polarIds","polar","radialaxis","angularaxis","cOpts","cauto","cmin","cmax","hasCalcTransform","transformCalci","calc","cdi","_scene","dirty","calcTransform","calci","isContainer","cd","_indexToPoints","enabled","setupAxisCategories","doCrossTraceCalc","sorted","sortAxisCategoriesByValue","sortAxisCategoriesByValueRegex","affectedTraces","zMapCategory","axLetter","counterAxLetter","xCategorical","yCategorical","aggFn","aggNums","a","mean","median","match","categoryorder","aggregator","order","categoriesValue","_categories","_traceIndices","_xautoBinFinished","_yautoBinFinished","isSplom","isScattergl","catIndex","currentDimensionIndex","_axesDim","associatedXAxisID","_diag","id2name","dimensions","_categoriesMap","dimension","hasOwnProperty","z","mapping","_categoriesValue","categoriesAggregatedValue","_categoriesAggregatedValue","_initialCategories","c","reverse","sortByInitialCategories","axLookup","setupOne","clearCalc","setupMultiCategory","matchGroups","_axisMatchGroups","axId","fn","crossTraceCalc","spType","methods","sp","spInfo","_rehover","redrag","_redrag","generalUpdatePerTraceModule","subplot","subplotCalcData","subplotLayout","traceHashOld","traceHash","calcTraces","moduleNameOld","fakeCalcTrace","fakeTrace","moduleName","moduleCalcData","filterVisible","plotBasePlot","desiredType","makeOnCompleteCallback","cdmodule","cleanBasePlot","had","has"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar d3 = require('@plotly/d3');\r\nvar timeFormatLocale = require('d3-time-format').timeFormatLocale;\r\nvar isNumeric = require('fast-isnumeric');\r\n\r\nvar Registry = require('../registry');\r\nvar PlotSchema = require('../plot_api/plot_schema');\r\nvar Template = require('../plot_api/plot_template');\r\nvar Lib = require('../lib');\r\nvar Color = require('../components/color');\r\nvar BADNUM = require('../constants/numerical').BADNUM;\r\n\r\nvar axisIDs = require('./cartesian/axis_ids');\r\nvar clearSelect = require('./cartesian/handle_outline').clearSelect;\r\n\r\nvar animationAttrs = require('./animation_attributes');\r\nvar frameAttrs = require('./frame_attributes');\r\n\r\nvar getModuleCalcData = require('../plots/get_data').getModuleCalcData;\r\n\r\nvar relinkPrivateKeys = Lib.relinkPrivateKeys;\r\nvar _ = Lib._;\r\n\r\nvar plots = module.exports = {};\r\n\r\n// Expose registry methods on Plots for backward-compatibility\r\nLib.extendFlat(plots, Registry);\r\n\r\nplots.attributes = require('./attributes');\r\nplots.attributes.type.values = plots.allTypes;\r\nplots.fontAttrs = require('./font_attributes');\r\nplots.layoutAttributes = require('./layout_attributes');\r\n\r\n// TODO make this a plot attribute?\r\nplots.fontWeight = 'normal';\r\n\r\nvar transformsRegistry = plots.transformsRegistry;\r\n\r\nvar commandModule = require('./command');\r\nplots.executeAPICommand = commandModule.executeAPICommand;\r\nplots.computeAPICommandBindings = commandModule.computeAPICommandBindings;\r\nplots.manageCommandObserver = commandModule.manageCommandObserver;\r\nplots.hasSimpleAPICommandBindings = commandModule.hasSimpleAPICommandBindings;\r\n\r\n// in some cases the browser doesn't seem to know how big\r\n// the text is at first, so it needs to draw it,\r\n// then wait a little, then draw it again\r\nplots.redrawText = function(gd) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    return new Promise(function(resolve) {\r\n        setTimeout(function() {\r\n            if(!gd._fullLayout) return;\r\n            Registry.getComponentMethod('annotations', 'draw')(gd);\r\n            Registry.getComponentMethod('legend', 'draw')(gd);\r\n            Registry.getComponentMethod('colorbar', 'draw')(gd);\r\n            resolve(plots.previousPromises(gd));\r\n        }, 300);\r\n    });\r\n};\r\n\r\n// resize plot about the container size\r\nplots.resize = function(gd) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    var resolveLastResize;\r\n    var p = new Promise(function(resolve, reject) {\r\n        if(!gd || Lib.isHidden(gd)) {\r\n            reject(new Error('Resize must be passed a displayed plot div element.'));\r\n        }\r\n\r\n        if(gd._redrawTimer) clearTimeout(gd._redrawTimer);\r\n        if(gd._resolveResize) resolveLastResize = gd._resolveResize;\r\n        gd._resolveResize = resolve;\r\n\r\n        gd._redrawTimer = setTimeout(function() {\r\n            // return if there is nothing to resize or is hidden\r\n            if(!gd.layout || (gd.layout.width && gd.layout.height) || Lib.isHidden(gd)) {\r\n                resolve(gd);\r\n                return;\r\n            }\r\n\r\n            delete gd.layout.width;\r\n            delete gd.layout.height;\r\n\r\n            // autosizing doesn't count as a change that needs saving\r\n            var oldchanged = gd.changed;\r\n\r\n            // nor should it be included in the undo queue\r\n            gd.autoplay = true;\r\n\r\n            Registry.call('relayout', gd, {autosize: true}).then(function() {\r\n                gd.changed = oldchanged;\r\n                // Only resolve if a new call hasn't been made!\r\n                if(gd._resolveResize === resolve) {\r\n                    delete gd._resolveResize;\r\n                    resolve(gd);\r\n                }\r\n            });\r\n        }, 100);\r\n    });\r\n\r\n    if(resolveLastResize) resolveLastResize(p);\r\n    return p;\r\n};\r\n\r\n\r\n// for use in Lib.syncOrAsync, check if there are any\r\n// pending promises in this plot and wait for them\r\nplots.previousPromises = function(gd) {\r\n    if((gd._promises || []).length) {\r\n        return Promise.all(gd._promises)\r\n            .then(function() { gd._promises = []; });\r\n    }\r\n};\r\n\r\n/**\r\n * Adds the 'Edit chart' link.\r\n * Note that now _doPlot calls this so it can regenerate whenever it replots\r\n *\r\n * Add source links to your graph inside the 'showSources' config argument.\r\n */\r\nplots.addLinks = function(gd) {\r\n    // Do not do anything if showLink and showSources are not set to true in config\r\n    if(!gd._context.showLink && !gd._context.showSources) return;\r\n\r\n    var fullLayout = gd._fullLayout;\r\n\r\n    var linkContainer = Lib.ensureSingle(fullLayout._paper, 'text', 'js-plot-link-container', function(s) {\r\n        s.style({\r\n            'font-family': '\"Open Sans\", Arial, sans-serif',\r\n            'font-size': '12px',\r\n            'fill': Color.defaultLine,\r\n            'pointer-events': 'all'\r\n        })\r\n        .each(function() {\r\n            var links = d3.select(this);\r\n            links.append('tspan').classed('js-link-to-tool', true);\r\n            links.append('tspan').classed('js-link-spacer', true);\r\n            links.append('tspan').classed('js-sourcelinks', true);\r\n        });\r\n    });\r\n\r\n    // The text node inside svg\r\n    var text = linkContainer.node();\r\n    var attrs = {y: fullLayout._paper.attr('height') - 9};\r\n\r\n    // If text's width is bigger than the layout\r\n    // Check that text is a child node or document.body\r\n    // because otherwise IE/Edge might throw an exception\r\n    // when calling getComputedTextLength().\r\n    // Apparently offsetParent is null for invisibles.\r\n    if(document.body.contains(text) && text.getComputedTextLength() >= (fullLayout.width - 20)) {\r\n        // Align the text at the left\r\n        attrs['text-anchor'] = 'start';\r\n        attrs.x = 5;\r\n    } else {\r\n        // Align the text at the right\r\n        attrs['text-anchor'] = 'end';\r\n        attrs.x = fullLayout._paper.attr('width') - 7;\r\n    }\r\n\r\n    linkContainer.attr(attrs);\r\n\r\n    var toolspan = linkContainer.select('.js-link-to-tool');\r\n    var spacespan = linkContainer.select('.js-link-spacer');\r\n    var sourcespan = linkContainer.select('.js-sourcelinks');\r\n\r\n    if(gd._context.showSources) gd._context.showSources(gd);\r\n\r\n    // 'view in plotly' link for embedded plots\r\n    if(gd._context.showLink) positionPlayWithData(gd, toolspan);\r\n\r\n    // separator if we have both sources and tool link\r\n    spacespan.text((toolspan.text() && sourcespan.text()) ? ' - ' : '');\r\n};\r\n\r\n// note that now this function is only adding the brand in\r\n// iframes and 3rd-party apps\r\nfunction positionPlayWithData(gd, container) {\r\n    container.text('');\r\n    var link = container.append('a')\r\n        .attr({\r\n            'xlink:xlink:href': '#',\r\n            'class': 'link--impt link--embedview',\r\n            'font-weight': 'bold'\r\n        })\r\n        .text(gd._context.linkText + ' ' + String.fromCharCode(187));\r\n\r\n    if(gd._context.sendData) {\r\n        link.on('click', function() {\r\n            plots.sendDataToCloud(gd);\r\n        });\r\n    } else {\r\n        var path = window.location.pathname.split('/');\r\n        var query = window.location.search;\r\n        link.attr({\r\n            'xlink:xlink:show': 'new',\r\n            'xlink:xlink:href': '/' + path[2].split('.')[0] + '/' + path[1] + query\r\n        });\r\n    }\r\n}\r\n\r\nplots.sendDataToCloud = function(gd) {\r\n    var baseUrl = (window.PLOTLYENV || {}).BASE_URL || gd._context.plotlyServerURL;\r\n    if(!baseUrl) return;\r\n\r\n    gd.emit('plotly_beforeexport');\r\n\r\n    var hiddenformDiv = d3.select(gd)\r\n        .append('div')\r\n        .attr('id', 'hiddenform')\r\n        .style('display', 'none');\r\n\r\n    var hiddenform = hiddenformDiv\r\n        .append('form')\r\n        .attr({\r\n            action: baseUrl + '/external',\r\n            method: 'post',\r\n            target: '_blank'\r\n        });\r\n\r\n    var hiddenformInput = hiddenform\r\n        .append('input')\r\n        .attr({\r\n            type: 'text',\r\n            name: 'data'\r\n        });\r\n\r\n    hiddenformInput.node().value = plots.graphJson(gd, false, 'keepdata');\r\n    hiddenform.node().submit();\r\n    hiddenformDiv.remove();\r\n\r\n    gd.emit('plotly_afterexport');\r\n    return false;\r\n};\r\n\r\nvar d3FormatKeys = [\r\n    'days', 'shortDays', 'months', 'shortMonths', 'periods',\r\n    'dateTime', 'date', 'time',\r\n    'decimal', 'thousands', 'grouping', 'currency'\r\n];\r\n\r\nvar extraFormatKeys = [\r\n    'year', 'month', 'dayMonth', 'dayMonthYear'\r\n];\r\n\r\n/*\r\n * Fill in default values\r\n * @param {DOM element} gd\r\n * @param {object} opts\r\n * @param {boolean} opts.skipUpdateCalc: normally if the existing gd.calcdata looks\r\n *   compatible with the new gd._fullData we finish by linking the new _fullData traces\r\n *   to the old gd.calcdata, so it's correctly set if we're not going to recalc. But also,\r\n *   if there are calcTransforms on the trace, we first remap data arrays from the old full\r\n *   trace into the new one. Use skipUpdateCalc to defer this (needed by Plotly.react)\r\n *\r\n * gd.data, gd.layout:\r\n *   are precisely what the user specified (except as modified by cleanData/cleanLayout),\r\n *   these fields shouldn't be modified (except for filling in some auto values)\r\n *   nor used directly after the supply defaults step.\r\n *\r\n * gd._fullData, gd._fullLayout:\r\n *   are complete descriptions of how to draw the plot,\r\n *   use these fields in all required computations.\r\n *\r\n * gd._fullLayout._modules\r\n *   is a list of all the trace modules required to draw the plot.\r\n *\r\n * gd._fullLayout._visibleModules\r\n *   subset of _modules, a list of modules corresponding to visible:true traces.\r\n *\r\n * gd._fullLayout._basePlotModules\r\n *   is a list of all the plot modules required to draw the plot.\r\n *\r\n * gd._fullLayout._transformModules\r\n *   is a list of all the transform modules invoked.\r\n *\r\n */\r\nplots.supplyDefaults = function(gd, opts) {\r\n    var skipUpdateCalc = opts && opts.skipUpdateCalc;\r\n    var oldFullLayout = gd._fullLayout || {};\r\n\r\n    if(oldFullLayout._skipDefaults) {\r\n        delete oldFullLayout._skipDefaults;\r\n        return;\r\n    }\r\n\r\n    var newFullLayout = gd._fullLayout = {};\r\n    var newLayout = gd.layout || {};\r\n\r\n    var oldFullData = gd._fullData || [];\r\n    var newFullData = gd._fullData = [];\r\n    var newData = gd.data || [];\r\n\r\n    var oldCalcdata = gd.calcdata || [];\r\n\r\n    var context = gd._context || {};\r\n\r\n    var i;\r\n\r\n    // Create all the storage space for frames, but only if doesn't already exist\r\n    if(!gd._transitionData) plots.createTransitionData(gd);\r\n\r\n    // So we only need to do this once (and since we have gd here)\r\n    // get the translated placeholder titles.\r\n    // These ones get used as default values so need to be known at supplyDefaults\r\n    // others keep their blank defaults but render the placeholder as desired later\r\n    // TODO: make these work the same way, only inserting the placeholder text at draw time?\r\n    // The challenge is that this has slightly different behavior right now in editable mode:\r\n    // using the placeholder as default makes this text permanently (but lightly) visible,\r\n    // but explicit '' for these titles gives you a placeholder that's hidden until you mouse\r\n    // over it - so you're not distracted by it if you really don't want a title, but if you do\r\n    // and you're new to plotly you may not be able to find it.\r\n    // When editable=false the two behave the same, no title is drawn.\r\n    newFullLayout._dfltTitle = {\r\n        plot: _(gd, 'Click to enter Plot title'),\r\n        x: _(gd, 'Click to enter X axis title'),\r\n        y: _(gd, 'Click to enter Y axis title'),\r\n        colorbar: _(gd, 'Click to enter Colorscale title'),\r\n        annotation: _(gd, 'new text')\r\n    };\r\n    newFullLayout._traceWord = _(gd, 'trace');\r\n\r\n    var formatObj = getFormatObj(gd, d3FormatKeys);\r\n\r\n    // stash the token from context so mapbox subplots can use it as default\r\n    newFullLayout._mapboxAccessToken = context.mapboxAccessToken;\r\n\r\n    // first fill in what we can of layout without looking at data\r\n    // because fullData needs a few things from layout\r\n    if(oldFullLayout._initialAutoSizeIsDone) {\r\n        // coerce the updated layout while preserving width and height\r\n        var oldWidth = oldFullLayout.width;\r\n        var oldHeight = oldFullLayout.height;\r\n\r\n        plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);\r\n\r\n        if(!newLayout.width) newFullLayout.width = oldWidth;\r\n        if(!newLayout.height) newFullLayout.height = oldHeight;\r\n        plots.sanitizeMargins(newFullLayout);\r\n    } else {\r\n        // coerce the updated layout and autosize if needed\r\n        plots.supplyLayoutGlobalDefaults(newLayout, newFullLayout, formatObj);\r\n\r\n        var missingWidthOrHeight = (!newLayout.width || !newLayout.height);\r\n        var autosize = newFullLayout.autosize;\r\n        var autosizable = context.autosizable;\r\n        var initialAutoSize = missingWidthOrHeight && (autosize || autosizable);\r\n\r\n        if(initialAutoSize) plots.plotAutoSize(gd, newLayout, newFullLayout);\r\n        else if(missingWidthOrHeight) plots.sanitizeMargins(newFullLayout);\r\n\r\n        // for backwards-compatibility with Plotly v1.x.x\r\n        if(!autosize && missingWidthOrHeight) {\r\n            newLayout.width = newFullLayout.width;\r\n            newLayout.height = newFullLayout.height;\r\n        }\r\n    }\r\n\r\n    newFullLayout._d3locale = getFormatter(formatObj, newFullLayout.separators);\r\n    newFullLayout._extraFormat = getFormatObj(gd, extraFormatKeys);\r\n\r\n    newFullLayout._initialAutoSizeIsDone = true;\r\n\r\n    // keep track of how many traces are inputted\r\n    newFullLayout._dataLength = newData.length;\r\n\r\n    // clear the lists of trace and baseplot modules, and subplots\r\n    newFullLayout._modules = [];\r\n    newFullLayout._visibleModules = [];\r\n    newFullLayout._basePlotModules = [];\r\n    var subplots = newFullLayout._subplots = emptySubplotLists();\r\n\r\n    // initialize axis and subplot hash objects for splom-generated grids\r\n    var splomAxes = newFullLayout._splomAxes = {x: {}, y: {}};\r\n    var splomSubplots = newFullLayout._splomSubplots = {};\r\n    // initialize splom grid defaults\r\n    newFullLayout._splomGridDflt = {};\r\n\r\n    // for stacked area traces to share config across traces\r\n    newFullLayout._scatterStackOpts = {};\r\n    // for the first scatter trace on each subplot (so it knows tonext->tozero)\r\n    newFullLayout._firstScatter = {};\r\n    // for grouped bar/box/violin trace to share config across traces\r\n    newFullLayout._alignmentOpts = {};\r\n    // track color axes referenced in the data\r\n    newFullLayout._colorAxes = {};\r\n\r\n    // for traces to request a default rangeslider on their x axes\r\n    // eg set `_requestRangeslider.x2 = true` for xaxis2\r\n    newFullLayout._requestRangeslider = {};\r\n\r\n    // pull uids from old data to use as new defaults\r\n    newFullLayout._traceUids = getTraceUids(oldFullData, newData);\r\n\r\n    // then do the data\r\n    newFullLayout._globalTransforms = (gd._context || {}).globalTransforms;\r\n    plots.supplyDataDefaults(newData, newFullData, newLayout, newFullLayout);\r\n\r\n    // redo grid size defaults with info about splom x/y axes,\r\n    // and fill in generated cartesian axes and subplots\r\n    var splomXa = Object.keys(splomAxes.x);\r\n    var splomYa = Object.keys(splomAxes.y);\r\n    if(splomXa.length > 1 && splomYa.length > 1) {\r\n        Registry.getComponentMethod('grid', 'sizeDefaults')(newLayout, newFullLayout);\r\n\r\n        for(i = 0; i < splomXa.length; i++) {\r\n            Lib.pushUnique(subplots.xaxis, splomXa[i]);\r\n        }\r\n        for(i = 0; i < splomYa.length; i++) {\r\n            Lib.pushUnique(subplots.yaxis, splomYa[i]);\r\n        }\r\n        for(var k in splomSubplots) {\r\n            Lib.pushUnique(subplots.cartesian, k);\r\n        }\r\n    }\r\n\r\n    // attach helper method to check whether a plot type is present on graph\r\n    newFullLayout._has = plots._hasPlotType.bind(newFullLayout);\r\n\r\n    if(oldFullData.length === newFullData.length) {\r\n        for(i = 0; i < newFullData.length; i++) {\r\n            relinkPrivateKeys(newFullData[i], oldFullData[i]);\r\n        }\r\n    }\r\n\r\n    // finally, fill in the pieces of layout that may need to look at data\r\n    plots.supplyLayoutModuleDefaults(newLayout, newFullLayout, newFullData, gd._transitionData);\r\n\r\n    // Special cases that introduce interactions between traces.\r\n    // This is after relinkPrivateKeys so we can use those in crossTraceDefaults\r\n    // and after layout module defaults, so we can use eg barmode\r\n    var _modules = newFullLayout._visibleModules;\r\n    var crossTraceDefaultsFuncs = [];\r\n    for(i = 0; i < _modules.length; i++) {\r\n        var funci = _modules[i].crossTraceDefaults;\r\n        // some trace types share crossTraceDefaults (ie histogram2d, histogram2dcontour)\r\n        if(funci) Lib.pushUnique(crossTraceDefaultsFuncs, funci);\r\n    }\r\n    for(i = 0; i < crossTraceDefaultsFuncs.length; i++) {\r\n        crossTraceDefaultsFuncs[i](newFullData, newFullLayout);\r\n    }\r\n\r\n    // turn on flag to optimize large splom-only graphs\r\n    // mostly by omitting SVG layers during Cartesian.drawFramework\r\n    newFullLayout._hasOnlyLargeSploms = (\r\n        newFullLayout._basePlotModules.length === 1 &&\r\n        newFullLayout._basePlotModules[0].name === 'splom' &&\r\n        splomXa.length > 15 &&\r\n        splomYa.length > 15 &&\r\n        newFullLayout.shapes.length === 0 &&\r\n        newFullLayout.images.length === 0\r\n    );\r\n\r\n    // relink / initialize subplot axis objects\r\n    plots.linkSubplots(newFullData, newFullLayout, oldFullData, oldFullLayout);\r\n\r\n    // clean subplots and other artifacts from previous plot calls\r\n    plots.cleanPlot(newFullData, newFullLayout, oldFullData, oldFullLayout);\r\n\r\n    var hadGL2D = !!(oldFullLayout._has && oldFullLayout._has('gl2d'));\r\n    var hasGL2D = !!(newFullLayout._has && newFullLayout._has('gl2d'));\r\n    var hadCartesian = !!(oldFullLayout._has && oldFullLayout._has('cartesian'));\r\n    var hasCartesian = !!(newFullLayout._has && newFullLayout._has('cartesian'));\r\n    var hadBgLayer = hadCartesian || hadGL2D;\r\n    var hasBgLayer = hasCartesian || hasGL2D;\r\n    if(hadBgLayer && !hasBgLayer) {\r\n        // remove bgLayer\r\n        oldFullLayout._bgLayer.remove();\r\n    } else if(hasBgLayer && !hadBgLayer) {\r\n        // create bgLayer\r\n        newFullLayout._shouldCreateBgLayer = true;\r\n    }\r\n\r\n    // clear selection outline until we implement persistent selection,\r\n    // don't clear them though when drag handlers (e.g. listening to\r\n    // `plotly_selecting`) update the graph.\r\n    // we should try to come up with a better solution when implementing\r\n    // https://github.com/plotly/plotly.js/issues/1851\r\n    if(oldFullLayout._zoomlayer && !gd._dragging) {\r\n        clearSelect({ // mock old gd\r\n            _fullLayout: oldFullLayout\r\n        });\r\n    }\r\n\r\n\r\n    // fill in meta helpers\r\n    fillMetaTextHelpers(newFullData, newFullLayout);\r\n\r\n    // relink functions and _ attributes to promote consistency between plots\r\n    relinkPrivateKeys(newFullLayout, oldFullLayout);\r\n\r\n    // colorscale crossTraceDefaults needs newFullLayout with relinked keys\r\n    Registry.getComponentMethod('colorscale', 'crossTraceDefaults')(newFullData, newFullLayout);\r\n\r\n    // For persisting GUI-driven changes in layout\r\n    // _preGUI and _tracePreGUI were already copied over in relinkPrivateKeys\r\n    if(!newFullLayout._preGUI) newFullLayout._preGUI = {};\r\n    // track trace GUI changes by uid rather than by trace index\r\n    if(!newFullLayout._tracePreGUI) newFullLayout._tracePreGUI = {};\r\n    var tracePreGUI = newFullLayout._tracePreGUI;\r\n    var uids = {};\r\n    var uid;\r\n    for(uid in tracePreGUI) uids[uid] = 'old';\r\n    for(i = 0; i < newFullData.length; i++) {\r\n        uid = newFullData[i]._fullInput.uid;\r\n        if(!uids[uid]) tracePreGUI[uid] = {};\r\n        uids[uid] = 'new';\r\n    }\r\n    for(uid in uids) {\r\n        if(uids[uid] === 'old') delete tracePreGUI[uid];\r\n    }\r\n\r\n    // set up containers for margin calculations\r\n    initMargins(newFullLayout);\r\n\r\n    // collect and do some initial calculations for rangesliders\r\n    Registry.getComponentMethod('rangeslider', 'makeData')(newFullLayout);\r\n\r\n    // update object references in calcdata\r\n    if(!skipUpdateCalc && oldCalcdata.length === newFullData.length) {\r\n        plots.supplyDefaultsUpdateCalc(oldCalcdata, newFullData);\r\n    }\r\n};\r\n\r\nplots.supplyDefaultsUpdateCalc = function(oldCalcdata, newFullData) {\r\n    for(var i = 0; i < newFullData.length; i++) {\r\n        var newTrace = newFullData[i];\r\n        var cd0 = (oldCalcdata[i] || [])[0];\r\n        if(cd0 && cd0.trace) {\r\n            var oldTrace = cd0.trace;\r\n            if(oldTrace._hasCalcTransform) {\r\n                var arrayAttrs = oldTrace._arrayAttrs;\r\n                var j, astr, oldArrayVal;\r\n\r\n                for(j = 0; j < arrayAttrs.length; j++) {\r\n                    astr = arrayAttrs[j];\r\n                    oldArrayVal = Lib.nestedProperty(oldTrace, astr).get().slice();\r\n                    Lib.nestedProperty(newTrace, astr).set(oldArrayVal);\r\n                }\r\n            }\r\n            cd0.trace = newTrace;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Create a list of uid strings satisfying (in this order of importance):\r\n * 1. all unique, all strings\r\n * 2. matches input uids if provided\r\n * 3. matches previous data uids\r\n */\r\nfunction getTraceUids(oldFullData, newData) {\r\n    var len = newData.length;\r\n    var oldFullInput = [];\r\n    var i, prevFullInput;\r\n    for(i = 0; i < oldFullData.length; i++) {\r\n        var thisFullInput = oldFullData[i]._fullInput;\r\n        if(thisFullInput !== prevFullInput) oldFullInput.push(thisFullInput);\r\n        prevFullInput = thisFullInput;\r\n    }\r\n    var oldLen = oldFullInput.length;\r\n    var out = new Array(len);\r\n    var seenUids = {};\r\n\r\n    function setUid(uid, i) {\r\n        out[i] = uid;\r\n        seenUids[uid] = 1;\r\n    }\r\n\r\n    function tryUid(uid, i) {\r\n        if(uid && typeof uid === 'string' && !seenUids[uid]) {\r\n            setUid(uid, i);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    for(i = 0; i < len; i++) {\r\n        var newUid = newData[i].uid;\r\n        if(typeof newUid === 'number') newUid = String(newUid);\r\n\r\n        if(tryUid(newUid, i)) continue;\r\n        if(i < oldLen && tryUid(oldFullInput[i].uid, i)) continue;\r\n        setUid(Lib.randstr(seenUids), i);\r\n    }\r\n\r\n    return out;\r\n}\r\n\r\n/**\r\n * Make a container for collecting subplots we need to display.\r\n *\r\n * Finds all subplot types we need to enumerate once and caches it,\r\n * but makes a new output object each time.\r\n * Single-trace subplots (which have no `id`) such as pie, table, etc\r\n * do not need to be collected because we just draw all visible traces.\r\n */\r\nfunction emptySubplotLists() {\r\n    var collectableSubplotTypes = Registry.collectableSubplotTypes;\r\n    var out = {};\r\n    var i, j;\r\n\r\n    if(!collectableSubplotTypes) {\r\n        collectableSubplotTypes = [];\r\n\r\n        var subplotsRegistry = Registry.subplotsRegistry;\r\n\r\n        for(var subplotType in subplotsRegistry) {\r\n            var subplotModule = subplotsRegistry[subplotType];\r\n            var subplotAttr = subplotModule.attr;\r\n\r\n            if(subplotAttr) {\r\n                collectableSubplotTypes.push(subplotType);\r\n\r\n                // special case, currently just for cartesian:\r\n                // we need to enumerate axes, not just subplots\r\n                if(Array.isArray(subplotAttr)) {\r\n                    for(j = 0; j < subplotAttr.length; j++) {\r\n                        Lib.pushUnique(collectableSubplotTypes, subplotAttr[j]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    for(i = 0; i < collectableSubplotTypes.length; i++) {\r\n        out[collectableSubplotTypes[i]] = [];\r\n    }\r\n    return out;\r\n}\r\n\r\n/**\r\n * getFormatObj: use _context to get the format object from locale.\r\n * Used to get d3.locale argument object and extraFormat argument object\r\n *\r\n * Regarding d3.locale argument :\r\n * decimal and thousands can be overridden later by layout.separators\r\n * grouping and currency are not presently used by our automatic number\r\n * formatting system but can be used by custom formats.\r\n *\r\n * @returns {object} d3.locale format object\r\n */\r\nfunction getFormatObj(gd, formatKeys) {\r\n    var locale = gd._context.locale;\r\n    if(!locale) locale = 'en-US';\r\n\r\n    var formatDone = false;\r\n    var formatObj = {};\r\n\r\n    function includeFormat(newFormat) {\r\n        var formatFinished = true;\r\n        for(var i = 0; i < formatKeys.length; i++) {\r\n            var formatKey = formatKeys[i];\r\n            if(!formatObj[formatKey]) {\r\n                if(newFormat[formatKey]) {\r\n                    formatObj[formatKey] = newFormat[formatKey];\r\n                } else formatFinished = false;\r\n            }\r\n        }\r\n        if(formatFinished) formatDone = true;\r\n    }\r\n\r\n    // same as localize, look for format parts in each format spec in the chain\r\n    for(var i = 0; i < 2; i++) {\r\n        var locales = gd._context.locales;\r\n        for(var j = 0; j < 2; j++) {\r\n            var formatj = (locales[locale] || {}).format;\r\n            if(formatj) {\r\n                includeFormat(formatj);\r\n                if(formatDone) break;\r\n            }\r\n            locales = Registry.localeRegistry;\r\n        }\r\n\r\n        var baseLocale = locale.split('-')[0];\r\n        if(formatDone || baseLocale === locale) break;\r\n        locale = baseLocale;\r\n    }\r\n\r\n    // lastly pick out defaults from english (non-US, as DMY is so much more common)\r\n    if(!formatDone) includeFormat(Registry.localeRegistry.en.format);\r\n\r\n    return formatObj;\r\n}\r\n\r\n/**\r\n * getFormatter: combine the final separators with the locale formatting object\r\n * we pulled earlier to generate number and time formatters\r\n * TODO: remove separators in v3, only use locale, so we don't need this step?\r\n *\r\n * @param {object} formatObj: d3.locale format object\r\n * @param {string} separators: length-2 string to override decimal and thousands\r\n *   separators in number formatting\r\n *\r\n * @returns {object} {numberFormat, timeFormat} d3 formatter factory functions\r\n *   for numbers and time\r\n */\r\nfunction getFormatter(formatObj, separators) {\r\n    formatObj.decimal = separators.charAt(0);\r\n    formatObj.thousands = separators.charAt(1);\r\n\r\n    return {\r\n        numberFormat: d3.locale(formatObj).numberFormat,\r\n        timeFormat: timeFormatLocale(formatObj).utcFormat\r\n    };\r\n}\r\n\r\nfunction fillMetaTextHelpers(newFullData, newFullLayout) {\r\n    var _meta;\r\n    var meta4data = [];\r\n\r\n    if(newFullLayout.meta) {\r\n        _meta = newFullLayout._meta = {\r\n            meta: newFullLayout.meta,\r\n            layout: {meta: newFullLayout.meta}\r\n        };\r\n    }\r\n\r\n    for(var i = 0; i < newFullData.length; i++) {\r\n        var trace = newFullData[i];\r\n\r\n        if(trace.meta) {\r\n            meta4data[trace.index] = trace._meta = {meta: trace.meta};\r\n        } else if(newFullLayout.meta) {\r\n            trace._meta = {meta: newFullLayout.meta};\r\n        }\r\n        if(newFullLayout.meta) {\r\n            trace._meta.layout = {meta: newFullLayout.meta};\r\n        }\r\n    }\r\n\r\n    if(meta4data.length) {\r\n        if(!_meta) {\r\n            _meta = newFullLayout._meta = {};\r\n        }\r\n        _meta.data = meta4data;\r\n    }\r\n}\r\n\r\n// Create storage for all of the data related to frames and transitions:\r\nplots.createTransitionData = function(gd) {\r\n    // Set up the default keyframe if it doesn't exist:\r\n    if(!gd._transitionData) {\r\n        gd._transitionData = {};\r\n    }\r\n\r\n    if(!gd._transitionData._frames) {\r\n        gd._transitionData._frames = [];\r\n    }\r\n\r\n    if(!gd._transitionData._frameHash) {\r\n        gd._transitionData._frameHash = {};\r\n    }\r\n\r\n    if(!gd._transitionData._counter) {\r\n        gd._transitionData._counter = 0;\r\n    }\r\n\r\n    if(!gd._transitionData._interruptCallbacks) {\r\n        gd._transitionData._interruptCallbacks = [];\r\n    }\r\n};\r\n\r\n// helper function to be bound to fullLayout to check\r\n// whether a certain plot type is present on plot\r\n// or trace has a category\r\nplots._hasPlotType = function(category) {\r\n    var i;\r\n\r\n    // check base plot modules\r\n    var basePlotModules = this._basePlotModules || [];\r\n    for(i = 0; i < basePlotModules.length; i++) {\r\n        if(basePlotModules[i].name === category) return true;\r\n    }\r\n\r\n    // check trace modules (including non-visible:true)\r\n    var modules = this._modules || [];\r\n    for(i = 0; i < modules.length; i++) {\r\n        var name = modules[i].name;\r\n        if(name === category) return true;\r\n        // N.B. this is modules[i] along with 'categories' as a hash object\r\n        var _module = Registry.modules[name];\r\n        if(_module && _module.categories[category]) return true;\r\n    }\r\n\r\n    return false;\r\n};\r\n\r\nplots.cleanPlot = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {\r\n    var i, j;\r\n\r\n    var basePlotModules = oldFullLayout._basePlotModules || [];\r\n    for(i = 0; i < basePlotModules.length; i++) {\r\n        var _module = basePlotModules[i];\r\n\r\n        if(_module.clean) {\r\n            _module.clean(newFullData, newFullLayout, oldFullData, oldFullLayout);\r\n        }\r\n    }\r\n\r\n    var hadGl = oldFullLayout._has && oldFullLayout._has('gl');\r\n    var hasGl = newFullLayout._has && newFullLayout._has('gl');\r\n\r\n    if(hadGl && !hasGl) {\r\n        if(oldFullLayout._glcontainer !== undefined) {\r\n            oldFullLayout._glcontainer.selectAll('.gl-canvas').remove();\r\n            oldFullLayout._glcontainer.selectAll('.no-webgl').remove();\r\n            oldFullLayout._glcanvas = null;\r\n        }\r\n    }\r\n\r\n    var hasInfoLayer = !!oldFullLayout._infolayer;\r\n\r\n    oldLoop:\r\n    for(i = 0; i < oldFullData.length; i++) {\r\n        var oldTrace = oldFullData[i];\r\n        var oldUid = oldTrace.uid;\r\n\r\n        for(j = 0; j < newFullData.length; j++) {\r\n            var newTrace = newFullData[j];\r\n\r\n            if(oldUid === newTrace.uid) continue oldLoop;\r\n        }\r\n\r\n        // clean old colorbars\r\n        if(hasInfoLayer) {\r\n            oldFullLayout._infolayer.select('.cb' + oldUid).remove();\r\n        }\r\n    }\r\n};\r\n\r\nplots.linkSubplots = function(newFullData, newFullLayout, oldFullData, oldFullLayout) {\r\n    var i, j;\r\n\r\n    var oldSubplots = oldFullLayout._plots || {};\r\n    var newSubplots = newFullLayout._plots = {};\r\n    var newSubplotList = newFullLayout._subplots;\r\n\r\n    var mockGd = {\r\n        _fullData: newFullData,\r\n        _fullLayout: newFullLayout\r\n    };\r\n\r\n    var ids = newSubplotList.cartesian.concat(newSubplotList.gl2d || []);\r\n\r\n    for(i = 0; i < ids.length; i++) {\r\n        var id = ids[i];\r\n        var oldSubplot = oldSubplots[id];\r\n        var xaxis = axisIDs.getFromId(mockGd, id, 'x');\r\n        var yaxis = axisIDs.getFromId(mockGd, id, 'y');\r\n        var plotinfo;\r\n\r\n        // link or create subplot object\r\n        if(oldSubplot) {\r\n            plotinfo = newSubplots[id] = oldSubplot;\r\n        } else {\r\n            plotinfo = newSubplots[id] = {};\r\n            plotinfo.id = id;\r\n        }\r\n\r\n        // add these axis ids to each others' subplot lists\r\n        xaxis._counterAxes.push(yaxis._id);\r\n        yaxis._counterAxes.push(xaxis._id);\r\n        xaxis._subplotsWith.push(id);\r\n        yaxis._subplotsWith.push(id);\r\n\r\n        // update x and y axis layout object refs\r\n        plotinfo.xaxis = xaxis;\r\n        plotinfo.yaxis = yaxis;\r\n\r\n        // By default, we clip at the subplot level,\r\n        // but if one trace on a given subplot has *cliponaxis* set to false,\r\n        // we need to clip at the trace module layer level;\r\n        // find this out here, once of for all.\r\n        plotinfo._hasClipOnAxisFalse = false;\r\n\r\n        for(j = 0; j < newFullData.length; j++) {\r\n            var trace = newFullData[j];\r\n\r\n            if(\r\n                trace.xaxis === plotinfo.xaxis._id &&\r\n                trace.yaxis === plotinfo.yaxis._id &&\r\n                trace.cliponaxis === false\r\n            ) {\r\n                plotinfo._hasClipOnAxisFalse = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // while we're at it, link overlaying axes to their main axes and\r\n    // anchored axes to the axes they're anchored to\r\n    var axList = axisIDs.list(mockGd, null, true);\r\n    var ax;\r\n    for(i = 0; i < axList.length; i++) {\r\n        ax = axList[i];\r\n        var mainAx = null;\r\n\r\n        if(ax.overlaying) {\r\n            mainAx = axisIDs.getFromId(mockGd, ax.overlaying);\r\n\r\n            // you cannot overlay an axis that's already overlaying another\r\n            if(mainAx && mainAx.overlaying) {\r\n                ax.overlaying = false;\r\n                mainAx = null;\r\n            }\r\n        }\r\n        ax._mainAxis = mainAx || ax;\r\n\r\n        /*\r\n         * For now force overlays to overlay completely... so they\r\n         * can drag together correctly and share backgrounds.\r\n         * Later perhaps we make separate axis domain and\r\n         * tick/line domain or something, so they can still share\r\n         * the (possibly larger) dragger and background but don't\r\n         * have to both be drawn over that whole domain\r\n         */\r\n        if(mainAx) ax.domain = mainAx.domain.slice();\r\n\r\n        ax._anchorAxis = ax.anchor === 'free' ?\r\n            null :\r\n            axisIDs.getFromId(mockGd, ax.anchor);\r\n    }\r\n\r\n    // finally, we can find the main subplot for each axis\r\n    // (on which the ticks & labels are drawn)\r\n    for(i = 0; i < axList.length; i++) {\r\n        ax = axList[i];\r\n        ax._counterAxes.sort(axisIDs.idSort);\r\n        ax._subplotsWith.sort(Lib.subplotSort);\r\n        ax._mainSubplot = findMainSubplot(ax, newFullLayout);\r\n\r\n        // find \"full\" domain span of counter axes,\r\n        // this loop can be costly, so only compute it when required\r\n        if(ax._counterAxes.length && (\r\n            (ax.spikemode && ax.spikemode.indexOf('across') !== -1) ||\r\n            (ax.automargin && ax.mirror && ax.anchor !== 'free') ||\r\n            Registry.getComponentMethod('rangeslider', 'isVisible')(ax)\r\n        )) {\r\n            var min = 1;\r\n            var max = 0;\r\n            for(j = 0; j < ax._counterAxes.length; j++) {\r\n                var ax2 = axisIDs.getFromId(mockGd, ax._counterAxes[j]);\r\n                min = Math.min(min, ax2.domain[0]);\r\n                max = Math.max(max, ax2.domain[1]);\r\n            }\r\n            if(min < max) {\r\n                ax._counterDomainMin = min;\r\n                ax._counterDomainMax = max;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\nfunction findMainSubplot(ax, fullLayout) {\r\n    var mockGd = {_fullLayout: fullLayout};\r\n\r\n    var isX = ax._id.charAt(0) === 'x';\r\n    var anchorAx = ax._mainAxis._anchorAxis;\r\n    var mainSubplotID = '';\r\n    var nextBestMainSubplotID = '';\r\n    var anchorID = '';\r\n\r\n    // First try the main ID with the anchor\r\n    if(anchorAx) {\r\n        anchorID = anchorAx._mainAxis._id;\r\n        mainSubplotID = isX ? (ax._id + anchorID) : (anchorID + ax._id);\r\n    }\r\n\r\n    // Then look for a subplot with the counteraxis overlaying the anchor\r\n    // If that fails just use the first subplot including this axis\r\n    if(!mainSubplotID || !fullLayout._plots[mainSubplotID]) {\r\n        mainSubplotID = '';\r\n\r\n        var counterIDs = ax._counterAxes;\r\n        for(var j = 0; j < counterIDs.length; j++) {\r\n            var counterPart = counterIDs[j];\r\n            var id = isX ? (ax._id + counterPart) : (counterPart + ax._id);\r\n            if(!nextBestMainSubplotID) nextBestMainSubplotID = id;\r\n            var counterAx = axisIDs.getFromId(mockGd, counterPart);\r\n            if(anchorID && counterAx.overlaying === anchorID) {\r\n                mainSubplotID = id;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    return mainSubplotID || nextBestMainSubplotID;\r\n}\r\n\r\n// This function clears any trace attributes with valType: color and\r\n// no set dflt filed in the plot schema. This is needed because groupby (which\r\n// is the only transform for which this currently applies) supplies parent\r\n// trace defaults, then expanded trace defaults. The result is that `null`\r\n// colors are default-supplied and inherited as a color instead of a null.\r\n// The result is that expanded trace default colors have no effect, with\r\n// the final result that groups are indistinguishable. This function clears\r\n// those colors so that individual groupby groups get unique colors.\r\nplots.clearExpandedTraceDefaultColors = function(trace) {\r\n    var colorAttrs, path, i;\r\n\r\n    // This uses weird closure state in order to satisfy the linter rule\r\n    // that we can't create functions in a loop.\r\n    function locateColorAttrs(attr, attrName, attrs, level) {\r\n        path[level] = attrName;\r\n        path.length = level + 1;\r\n        if(attr.valType === 'color' && attr.dflt === undefined) {\r\n            colorAttrs.push(path.join('.'));\r\n        }\r\n    }\r\n\r\n    path = [];\r\n\r\n    // Get the cached colorAttrs:\r\n    colorAttrs = trace._module._colorAttrs;\r\n\r\n    // Or else compute and cache the colorAttrs on the module:\r\n    if(!colorAttrs) {\r\n        trace._module._colorAttrs = colorAttrs = [];\r\n        PlotSchema.crawl(\r\n            trace._module.attributes,\r\n            locateColorAttrs\r\n        );\r\n    }\r\n\r\n    for(i = 0; i < colorAttrs.length; i++) {\r\n        var origprop = Lib.nestedProperty(trace, '_input.' + colorAttrs[i]);\r\n\r\n        if(!origprop.get()) {\r\n            Lib.nestedProperty(trace, colorAttrs[i]).set(null);\r\n        }\r\n    }\r\n};\r\n\r\n\r\nplots.supplyDataDefaults = function(dataIn, dataOut, layout, fullLayout) {\r\n    var modules = fullLayout._modules;\r\n    var visibleModules = fullLayout._visibleModules;\r\n    var basePlotModules = fullLayout._basePlotModules;\r\n    var cnt = 0;\r\n    var colorCnt = 0;\r\n\r\n    var i, fullTrace, trace;\r\n\r\n    fullLayout._transformModules = [];\r\n\r\n    function pushModule(fullTrace) {\r\n        dataOut.push(fullTrace);\r\n\r\n        var _module = fullTrace._module;\r\n        if(!_module) return;\r\n\r\n        Lib.pushUnique(modules, _module);\r\n        if(fullTrace.visible === true) Lib.pushUnique(visibleModules, _module);\r\n        Lib.pushUnique(basePlotModules, fullTrace._module.basePlotModule);\r\n        cnt++;\r\n\r\n        // TODO: do we really want color not to increment for explicitly invisible traces?\r\n        // This logic is weird, but matches previous behavior: traces that you explicitly\r\n        // set to visible:false do not increment the color, but traces WE determine to be\r\n        // empty or invalid (and thus set to visible:false) DO increment color.\r\n        // I kind of think we should just let all traces increment color, visible or not.\r\n        // see mock: axes-autotype-empty vs. a test of restyling visible: false that\r\n        // I can't find right now...\r\n        if(fullTrace._input.visible !== false) colorCnt++;\r\n    }\r\n\r\n    var carpetIndex = {};\r\n    var carpetDependents = [];\r\n    var dataTemplate = (layout.template || {}).data || {};\r\n    var templater = Template.traceTemplater(dataTemplate);\r\n\r\n    for(i = 0; i < dataIn.length; i++) {\r\n        trace = dataIn[i];\r\n\r\n        // reuse uid we may have pulled out of oldFullData\r\n        // Note: templater supplies trace type\r\n        fullTrace = templater.newTrace(trace);\r\n        fullTrace.uid = fullLayout._traceUids[i];\r\n        plots.supplyTraceDefaults(trace, fullTrace, colorCnt, fullLayout, i);\r\n\r\n        fullTrace.index = i;\r\n        fullTrace._input = trace;\r\n        fullTrace._expandedIndex = cnt;\r\n\r\n        if(fullTrace.transforms && fullTrace.transforms.length) {\r\n            var sdInvisible = trace.visible !== false && fullTrace.visible === false;\r\n\r\n            var expandedTraces = applyTransforms(fullTrace, dataOut, layout, fullLayout);\r\n\r\n            for(var j = 0; j < expandedTraces.length; j++) {\r\n                var expandedTrace = expandedTraces[j];\r\n\r\n                // No further templating during transforms.\r\n                var fullExpandedTrace = {\r\n                    _template: fullTrace._template,\r\n                    type: fullTrace.type,\r\n                    // set uid using parent uid and expanded index\r\n                    // to promote consistency between update calls\r\n                    uid: fullTrace.uid + j\r\n                };\r\n\r\n                // If the first supplyDefaults created `visible: false`,\r\n                // clear it before running supplyDefaults a second time,\r\n                // because sometimes there are items we still want to coerce\r\n                // inside trace modules before determining that the trace is\r\n                // again `visible: false`, for example partial visibilities\r\n                // in `splom` traces.\r\n                if(sdInvisible && expandedTrace.visible === false) {\r\n                    delete expandedTrace.visible;\r\n                }\r\n\r\n                plots.supplyTraceDefaults(expandedTrace, fullExpandedTrace, cnt, fullLayout, i);\r\n\r\n                // relink private (i.e. underscore) keys expanded trace to full expanded trace so\r\n                // that transform supply-default methods can set _ keys for future use.\r\n                relinkPrivateKeys(fullExpandedTrace, expandedTrace);\r\n\r\n                // add info about parent data trace\r\n                fullExpandedTrace.index = i;\r\n                fullExpandedTrace._input = trace;\r\n                fullExpandedTrace._fullInput = fullTrace;\r\n\r\n                // add info about the expanded data\r\n                fullExpandedTrace._expandedIndex = cnt;\r\n                fullExpandedTrace._expandedInput = expandedTrace;\r\n\r\n                pushModule(fullExpandedTrace);\r\n            }\r\n        } else {\r\n            // add identify refs for consistency with transformed traces\r\n            fullTrace._fullInput = fullTrace;\r\n            fullTrace._expandedInput = fullTrace;\r\n\r\n            pushModule(fullTrace);\r\n        }\r\n\r\n        if(Registry.traceIs(fullTrace, 'carpetAxis')) {\r\n            carpetIndex[fullTrace.carpet] = fullTrace;\r\n        }\r\n\r\n        if(Registry.traceIs(fullTrace, 'carpetDependent')) {\r\n            carpetDependents.push(i);\r\n        }\r\n    }\r\n\r\n    for(i = 0; i < carpetDependents.length; i++) {\r\n        fullTrace = dataOut[carpetDependents[i]];\r\n\r\n        if(!fullTrace.visible) continue;\r\n\r\n        var carpetAxis = carpetIndex[fullTrace.carpet];\r\n        fullTrace._carpet = carpetAxis;\r\n\r\n        if(!carpetAxis || !carpetAxis.visible) {\r\n            fullTrace.visible = false;\r\n            continue;\r\n        }\r\n\r\n        fullTrace.xaxis = carpetAxis.xaxis;\r\n        fullTrace.yaxis = carpetAxis.yaxis;\r\n    }\r\n};\r\n\r\nplots.supplyAnimationDefaults = function(opts) {\r\n    opts = opts || {};\r\n    var i;\r\n    var optsOut = {};\r\n\r\n    function coerce(attr, dflt) {\r\n        return Lib.coerce(opts || {}, optsOut, animationAttrs, attr, dflt);\r\n    }\r\n\r\n    coerce('mode');\r\n    coerce('direction');\r\n    coerce('fromcurrent');\r\n\r\n    if(Array.isArray(opts.frame)) {\r\n        optsOut.frame = [];\r\n        for(i = 0; i < opts.frame.length; i++) {\r\n            optsOut.frame[i] = plots.supplyAnimationFrameDefaults(opts.frame[i] || {});\r\n        }\r\n    } else {\r\n        optsOut.frame = plots.supplyAnimationFrameDefaults(opts.frame || {});\r\n    }\r\n\r\n    if(Array.isArray(opts.transition)) {\r\n        optsOut.transition = [];\r\n        for(i = 0; i < opts.transition.length; i++) {\r\n            optsOut.transition[i] = plots.supplyAnimationTransitionDefaults(opts.transition[i] || {});\r\n        }\r\n    } else {\r\n        optsOut.transition = plots.supplyAnimationTransitionDefaults(opts.transition || {});\r\n    }\r\n\r\n    return optsOut;\r\n};\r\n\r\nplots.supplyAnimationFrameDefaults = function(opts) {\r\n    var optsOut = {};\r\n\r\n    function coerce(attr, dflt) {\r\n        return Lib.coerce(opts || {}, optsOut, animationAttrs.frame, attr, dflt);\r\n    }\r\n\r\n    coerce('duration');\r\n    coerce('redraw');\r\n\r\n    return optsOut;\r\n};\r\n\r\nplots.supplyAnimationTransitionDefaults = function(opts) {\r\n    var optsOut = {};\r\n\r\n    function coerce(attr, dflt) {\r\n        return Lib.coerce(opts || {}, optsOut, animationAttrs.transition, attr, dflt);\r\n    }\r\n\r\n    coerce('duration');\r\n    coerce('easing');\r\n\r\n    return optsOut;\r\n};\r\n\r\nplots.supplyFrameDefaults = function(frameIn) {\r\n    var frameOut = {};\r\n\r\n    function coerce(attr, dflt) {\r\n        return Lib.coerce(frameIn, frameOut, frameAttrs, attr, dflt);\r\n    }\r\n\r\n    coerce('group');\r\n    coerce('name');\r\n    coerce('traces');\r\n    coerce('baseframe');\r\n    coerce('data');\r\n    coerce('layout');\r\n\r\n    return frameOut;\r\n};\r\n\r\nplots.supplyTraceDefaults = function(traceIn, traceOut, colorIndex, layout, traceInIndex) {\r\n    var colorway = layout.colorway || Color.defaults;\r\n    var defaultColor = colorway[colorIndex % colorway.length];\r\n\r\n    var i;\r\n\r\n    function coerce(attr, dflt) {\r\n        return Lib.coerce(traceIn, traceOut, plots.attributes, attr, dflt);\r\n    }\r\n\r\n    var visible = coerce('visible');\r\n\r\n    coerce('type');\r\n    coerce('name', layout._traceWord + ' ' + traceInIndex);\r\n\r\n    coerce('uirevision', layout.uirevision);\r\n\r\n    // we want even invisible traces to make their would-be subplots visible\r\n    // so coerce the subplot id(s) now no matter what\r\n    var _module = plots.getModule(traceOut);\r\n\r\n    traceOut._module = _module;\r\n    if(_module) {\r\n        var basePlotModule = _module.basePlotModule;\r\n        var subplotAttr = basePlotModule.attr;\r\n        var subplotAttrs = basePlotModule.attributes;\r\n        if(subplotAttr && subplotAttrs) {\r\n            var subplots = layout._subplots;\r\n            var subplotId = '';\r\n\r\n            if(\r\n                visible ||\r\n                basePlotModule.name !== 'gl2d' // for now just drop empty gl2d subplots\r\n                // TODO - currently if we draw an empty gl2d subplot, it draws\r\n                // nothing then gets stuck and you can't get it back without newPlot\r\n                // sort this out in the regl refactor?\r\n            ) {\r\n                if(Array.isArray(subplotAttr)) {\r\n                    for(i = 0; i < subplotAttr.length; i++) {\r\n                        var attri = subplotAttr[i];\r\n                        var vali = Lib.coerce(traceIn, traceOut, subplotAttrs, attri);\r\n\r\n                        if(subplots[attri]) Lib.pushUnique(subplots[attri], vali);\r\n                        subplotId += vali;\r\n                    }\r\n                } else {\r\n                    subplotId = Lib.coerce(traceIn, traceOut, subplotAttrs, subplotAttr);\r\n                }\r\n\r\n                if(subplots[basePlotModule.name]) {\r\n                    Lib.pushUnique(subplots[basePlotModule.name], subplotId);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if(visible) {\r\n        coerce('customdata');\r\n        coerce('ids');\r\n        coerce('meta');\r\n\r\n        if(Registry.traceIs(traceOut, 'showLegend')) {\r\n            Lib.coerce(traceIn, traceOut,\r\n                _module.attributes.showlegend ? _module.attributes : plots.attributes,\r\n                'showlegend'\r\n            );\r\n\r\n            coerce('legendgroup');\r\n            coerce('legendrank');\r\n\r\n            traceOut._dfltShowLegend = true;\r\n        } else {\r\n            traceOut._dfltShowLegend = false;\r\n        }\r\n\r\n        if(_module) {\r\n            _module.supplyDefaults(traceIn, traceOut, defaultColor, layout);\r\n        }\r\n\r\n        if(!Registry.traceIs(traceOut, 'noOpacity')) {\r\n            coerce('opacity');\r\n        }\r\n\r\n        if(Registry.traceIs(traceOut, 'notLegendIsolatable')) {\r\n            // This clears out the legendonly state for traces like carpet that\r\n            // cannot be isolated in the legend\r\n            traceOut.visible = !!traceOut.visible;\r\n        }\r\n\r\n        if(!Registry.traceIs(traceOut, 'noHover')) {\r\n            if(!traceOut.hovertemplate) Lib.coerceHoverinfo(traceIn, traceOut, layout);\r\n\r\n            // parcats support hover, but not hoverlabel stylings (yet)\r\n            if(traceOut.type !== 'parcats') {\r\n                Registry.getComponentMethod('fx', 'supplyDefaults')(traceIn, traceOut, defaultColor, layout);\r\n            }\r\n        }\r\n\r\n        if(_module && _module.selectPoints) {\r\n            coerce('selectedpoints');\r\n        }\r\n\r\n        plots.supplyTransformDefaults(traceIn, traceOut, layout);\r\n    }\r\n\r\n    return traceOut;\r\n};\r\n\r\n/**\r\n * hasMakesDataTransform: does this trace have a transform that makes its own\r\n * data, either by grabbing it from somewhere else or by creating it from input\r\n * parameters? If so, we should still keep going with supplyDefaults\r\n * even if the trace is invisible, which may just be because it has no data yet.\r\n */\r\nfunction hasMakesDataTransform(trace) {\r\n    var transforms = trace.transforms;\r\n    if(Array.isArray(transforms) && transforms.length) {\r\n        for(var i = 0; i < transforms.length; i++) {\r\n            var ti = transforms[i];\r\n            var _module = ti._module || transformsRegistry[ti.type];\r\n            if(_module && _module.makesData) return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nplots.hasMakesDataTransform = hasMakesDataTransform;\r\n\r\nplots.supplyTransformDefaults = function(traceIn, traceOut, layout) {\r\n    // For now we only allow transforms on 1D traces, ie those that specify a _length.\r\n    // If we were to implement 2D transforms, we'd need to have each transform\r\n    // describe its own applicability and disable itself when it doesn't apply.\r\n    // Also allow transforms that make their own data, but not in globalTransforms\r\n    if(!(traceOut._length || hasMakesDataTransform(traceIn))) return;\r\n\r\n    var globalTransforms = layout._globalTransforms || [];\r\n    var transformModules = layout._transformModules || [];\r\n\r\n    if(!Array.isArray(traceIn.transforms) && globalTransforms.length === 0) return;\r\n\r\n    var containerIn = traceIn.transforms || [];\r\n    var transformList = globalTransforms.concat(containerIn);\r\n    var containerOut = traceOut.transforms = [];\r\n\r\n    for(var i = 0; i < transformList.length; i++) {\r\n        var transformIn = transformList[i];\r\n        var type = transformIn.type;\r\n        var _module = transformsRegistry[type];\r\n        var transformOut;\r\n\r\n        /*\r\n         * Supply defaults may run twice. First pass runs all supply defaults steps\r\n         * and adds the _module to any output transforms.\r\n         * If transforms exist another pass is run so that any generated traces also\r\n         * go through supply defaults. This has the effect of rerunning\r\n         * supplyTransformDefaults. If the transform does not have a `transform`\r\n         * function it could not have generated any new traces and the second stage\r\n         * is unnecessary. We detect this case with the following variables.\r\n         */\r\n        var isFirstStage = !(transformIn._module && transformIn._module === _module);\r\n        var doLaterStages = _module && typeof _module.transform === 'function';\r\n\r\n        if(!_module) Lib.warn('Unrecognized transform type ' + type + '.');\r\n\r\n        if(_module && _module.supplyDefaults && (isFirstStage || doLaterStages)) {\r\n            transformOut = _module.supplyDefaults(transformIn, traceOut, layout, traceIn);\r\n            transformOut.type = type;\r\n            transformOut._module = _module;\r\n\r\n            Lib.pushUnique(transformModules, _module);\r\n        } else {\r\n            transformOut = Lib.extendFlat({}, transformIn);\r\n        }\r\n\r\n        containerOut.push(transformOut);\r\n    }\r\n};\r\n\r\nfunction applyTransforms(fullTrace, fullData, layout, fullLayout) {\r\n    var container = fullTrace.transforms;\r\n    var dataOut = [fullTrace];\r\n\r\n    for(var i = 0; i < container.length; i++) {\r\n        var transform = container[i];\r\n        var _module = transformsRegistry[transform.type];\r\n\r\n        if(_module && _module.transform) {\r\n            dataOut = _module.transform(dataOut, {\r\n                transform: transform,\r\n                fullTrace: fullTrace,\r\n                fullData: fullData,\r\n                layout: layout,\r\n                fullLayout: fullLayout,\r\n                transformIndex: i\r\n            });\r\n        }\r\n    }\r\n\r\n    return dataOut;\r\n}\r\n\r\nplots.supplyLayoutGlobalDefaults = function(layoutIn, layoutOut, formatObj) {\r\n    function coerce(attr, dflt) {\r\n        return Lib.coerce(layoutIn, layoutOut, plots.layoutAttributes, attr, dflt);\r\n    }\r\n\r\n    var template = layoutIn.template;\r\n    if(Lib.isPlainObject(template)) {\r\n        layoutOut.template = template;\r\n        layoutOut._template = template.layout;\r\n        layoutOut._dataTemplate = template.data;\r\n    }\r\n\r\n    coerce('autotypenumbers');\r\n\r\n    var globalFont = Lib.coerceFont(coerce, 'font');\r\n\r\n    coerce('title.text', layoutOut._dfltTitle.plot);\r\n\r\n    Lib.coerceFont(coerce, 'title.font', {\r\n        family: globalFont.family,\r\n        size: Math.round(globalFont.size * 1.4),\r\n        color: globalFont.color\r\n    });\r\n\r\n    coerce('title.xref');\r\n    coerce('title.yref');\r\n    coerce('title.x');\r\n    coerce('title.y');\r\n    coerce('title.xanchor');\r\n    coerce('title.yanchor');\r\n    coerce('title.pad.t');\r\n    coerce('title.pad.r');\r\n    coerce('title.pad.b');\r\n    coerce('title.pad.l');\r\n\r\n    var uniformtextMode = coerce('uniformtext.mode');\r\n    if(uniformtextMode) {\r\n        coerce('uniformtext.minsize');\r\n    }\r\n\r\n    // Make sure that autosize is defaulted to *true*\r\n    // on layouts with no set width and height for backward compatibly,\r\n    // in particular https://plotly.com/javascript/responsive-fluid-layout/\r\n    //\r\n    // Before https://github.com/plotly/plotly.js/pull/635 ,\r\n    // layouts with no set width and height were set temporary set to 'initial'\r\n    // to pass through the autosize routine\r\n    //\r\n    // This behavior is subject to change in v3.\r\n    coerce('autosize', !(layoutIn.width && layoutIn.height));\r\n\r\n    coerce('width');\r\n    coerce('height');\r\n    coerce('margin.l');\r\n    coerce('margin.r');\r\n    coerce('margin.t');\r\n    coerce('margin.b');\r\n    coerce('margin.pad');\r\n    coerce('margin.autoexpand');\r\n\r\n    if(layoutIn.width && layoutIn.height) plots.sanitizeMargins(layoutOut);\r\n\r\n    Registry.getComponentMethod('grid', 'sizeDefaults')(layoutIn, layoutOut);\r\n\r\n    coerce('paper_bgcolor');\r\n\r\n    coerce('separators', formatObj.decimal + formatObj.thousands);\r\n    coerce('hidesources');\r\n\r\n    coerce('colorway');\r\n\r\n    coerce('datarevision');\r\n    var uirevision = coerce('uirevision');\r\n    coerce('editrevision', uirevision);\r\n    coerce('selectionrevision', uirevision);\r\n\r\n    Registry.getComponentMethod(\r\n        'modebar',\r\n        'supplyLayoutDefaults'\r\n    )(layoutIn, layoutOut);\r\n\r\n    Registry.getComponentMethod(\r\n        'shapes',\r\n        'supplyDrawNewShapeDefaults'\r\n    )(layoutIn, layoutOut, coerce);\r\n\r\n    coerce('meta');\r\n\r\n    // do not include defaults in fullLayout when users do not set transition\r\n    if(Lib.isPlainObject(layoutIn.transition)) {\r\n        coerce('transition.duration');\r\n        coerce('transition.easing');\r\n        coerce('transition.ordering');\r\n    }\r\n\r\n    Registry.getComponentMethod(\r\n        'calendars',\r\n        'handleDefaults'\r\n    )(layoutIn, layoutOut, 'calendar');\r\n\r\n    Registry.getComponentMethod(\r\n        'fx',\r\n        'supplyLayoutGlobalDefaults'\r\n    )(layoutIn, layoutOut, coerce);\r\n};\r\n\r\nfunction getComputedSize(attr) {\r\n    return (\r\n        (typeof attr === 'string') &&\r\n        (attr.substr(attr.length - 2) === 'px') &&\r\n        parseFloat(attr)\r\n    );\r\n}\r\n\r\n\r\nplots.plotAutoSize = function plotAutoSize(gd, layout, fullLayout) {\r\n    var context = gd._context || {};\r\n    var frameMargins = context.frameMargins;\r\n    var newWidth;\r\n    var newHeight;\r\n\r\n    var isPlotDiv = Lib.isPlotDiv(gd);\r\n\r\n    if(isPlotDiv) gd.emit('plotly_autosize');\r\n\r\n    // embedded in an iframe - just take the full iframe size\r\n    // if we get to this point, with no aspect ratio restrictions\r\n    if(context.fillFrame) {\r\n        newWidth = window.innerWidth;\r\n        newHeight = window.innerHeight;\r\n\r\n        // somehow we get a few extra px height sometimes...\r\n        // just hide it\r\n        document.body.style.overflow = 'hidden';\r\n    } else {\r\n        // plotly.js - let the developers do what they want, either\r\n        // provide height and width for the container div,\r\n        // specify size in layout, or take the defaults,\r\n        // but don't enforce any ratio restrictions\r\n        var computedStyle = isPlotDiv ? window.getComputedStyle(gd) : {};\r\n\r\n        newWidth = getComputedSize(computedStyle.width) || getComputedSize(computedStyle.maxWidth) || fullLayout.width;\r\n        newHeight = getComputedSize(computedStyle.height) || getComputedSize(computedStyle.maxHeight) || fullLayout.height;\r\n\r\n        if(isNumeric(frameMargins) && frameMargins > 0) {\r\n            var factor = 1 - 2 * frameMargins;\r\n            newWidth = Math.round(factor * newWidth);\r\n            newHeight = Math.round(factor * newHeight);\r\n        }\r\n    }\r\n\r\n    var minWidth = plots.layoutAttributes.width.min;\r\n    var minHeight = plots.layoutAttributes.height.min;\r\n    if(newWidth < minWidth) newWidth = minWidth;\r\n    if(newHeight < minHeight) newHeight = minHeight;\r\n\r\n    var widthHasChanged = !layout.width &&\r\n        (Math.abs(fullLayout.width - newWidth) > 1);\r\n    var heightHasChanged = !layout.height &&\r\n        (Math.abs(fullLayout.height - newHeight) > 1);\r\n\r\n    if(heightHasChanged || widthHasChanged) {\r\n        if(widthHasChanged) fullLayout.width = newWidth;\r\n        if(heightHasChanged) fullLayout.height = newHeight;\r\n    }\r\n\r\n    // cache initial autosize value, used in relayout when\r\n    // width or height values are set to null\r\n    if(!gd._initialAutoSize) {\r\n        gd._initialAutoSize = { width: newWidth, height: newHeight };\r\n    }\r\n\r\n    plots.sanitizeMargins(fullLayout);\r\n};\r\n\r\nplots.supplyLayoutModuleDefaults = function(layoutIn, layoutOut, fullData, transitionData) {\r\n    var componentsRegistry = Registry.componentsRegistry;\r\n    var basePlotModules = layoutOut._basePlotModules;\r\n    var component, i, _module;\r\n\r\n    var Cartesian = Registry.subplotsRegistry.cartesian;\r\n\r\n    // check if any components need to add more base plot modules\r\n    // that weren't captured by traces\r\n    for(component in componentsRegistry) {\r\n        _module = componentsRegistry[component];\r\n\r\n        if(_module.includeBasePlot) {\r\n            _module.includeBasePlot(layoutIn, layoutOut);\r\n        }\r\n    }\r\n\r\n    // make sure we *at least* have some cartesian axes\r\n    if(!basePlotModules.length) {\r\n        basePlotModules.push(Cartesian);\r\n    }\r\n\r\n    // ensure all cartesian axes have at least one subplot\r\n    if(layoutOut._has('cartesian')) {\r\n        Registry.getComponentMethod('grid', 'contentDefaults')(layoutIn, layoutOut);\r\n        Cartesian.finalizeSubplots(layoutIn, layoutOut);\r\n    }\r\n\r\n    // sort subplot lists\r\n    for(var subplotType in layoutOut._subplots) {\r\n        layoutOut._subplots[subplotType].sort(Lib.subplotSort);\r\n    }\r\n\r\n    // base plot module layout defaults\r\n    for(i = 0; i < basePlotModules.length; i++) {\r\n        _module = basePlotModules[i];\r\n\r\n        // e.g. pie does not have a layout-defaults step\r\n        if(_module.supplyLayoutDefaults) {\r\n            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\r\n        }\r\n    }\r\n\r\n    // trace module layout defaults\r\n    // use _modules rather than _visibleModules so that even\r\n    // legendonly traces can include settings - eg barmode, which affects\r\n    // legend.traceorder default value.\r\n    var modules = layoutOut._modules;\r\n    for(i = 0; i < modules.length; i++) {\r\n        _module = modules[i];\r\n\r\n        if(_module.supplyLayoutDefaults) {\r\n            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\r\n        }\r\n    }\r\n\r\n    // transform module layout defaults\r\n    var transformModules = layoutOut._transformModules;\r\n    for(i = 0; i < transformModules.length; i++) {\r\n        _module = transformModules[i];\r\n\r\n        if(_module.supplyLayoutDefaults) {\r\n            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData, transitionData);\r\n        }\r\n    }\r\n\r\n    for(component in componentsRegistry) {\r\n        _module = componentsRegistry[component];\r\n\r\n        if(_module.supplyLayoutDefaults) {\r\n            _module.supplyLayoutDefaults(layoutIn, layoutOut, fullData);\r\n        }\r\n    }\r\n};\r\n\r\n// Remove all plotly attributes from a div so it can be replotted fresh\r\n// TODO: these really need to be encapsulated into a much smaller set...\r\nplots.purge = function(gd) {\r\n    // note: we DO NOT remove _context because it doesn't change when we insert\r\n    // a new plot, and may have been set outside of our scope.\r\n\r\n    var fullLayout = gd._fullLayout || {};\r\n    if(fullLayout._glcontainer !== undefined) {\r\n        fullLayout._glcontainer.selectAll('.gl-canvas').remove();\r\n        fullLayout._glcontainer.remove();\r\n        fullLayout._glcanvas = null;\r\n    }\r\n\r\n    // remove modebar\r\n    if(fullLayout._modeBar) fullLayout._modeBar.destroy();\r\n\r\n    if(gd._transitionData) {\r\n        // Ensure any dangling callbacks are simply dropped if the plot is purged.\r\n        // This is more or less only actually important for testing.\r\n        if(gd._transitionData._interruptCallbacks) {\r\n            gd._transitionData._interruptCallbacks.length = 0;\r\n        }\r\n\r\n        if(gd._transitionData._animationRaf) {\r\n            window.cancelAnimationFrame(gd._transitionData._animationRaf);\r\n        }\r\n    }\r\n\r\n    // remove any planned throttles\r\n    Lib.clearThrottle();\r\n\r\n    // remove responsive handler\r\n    Lib.clearResponsive(gd);\r\n\r\n    // data and layout\r\n    delete gd.data;\r\n    delete gd.layout;\r\n    delete gd._fullData;\r\n    delete gd._fullLayout;\r\n    delete gd.calcdata;\r\n    delete gd.empty;\r\n\r\n    delete gd.fid;\r\n\r\n    delete gd.undoqueue; // action queue\r\n    delete gd.undonum;\r\n    delete gd.autoplay; // are we doing an action that doesn't go in undo queue?\r\n    delete gd.changed;\r\n\r\n    // these get recreated on _doPlot anyway, but just to be safe\r\n    // (and to have a record of them...)\r\n    delete gd._promises;\r\n    delete gd._redrawTimer;\r\n    delete gd._hmlumcount;\r\n    delete gd._hmpixcount;\r\n    delete gd._transitionData;\r\n    delete gd._transitioning;\r\n    delete gd._initialAutoSize;\r\n    delete gd._transitioningWithDuration;\r\n\r\n    // created during certain events, that *should* clean them up\r\n    // themselves, but may not if there was an error\r\n    delete gd._dragging;\r\n    delete gd._dragged;\r\n    delete gd._dragdata;\r\n    delete gd._hoverdata;\r\n    delete gd._snapshotInProgress;\r\n    delete gd._editing;\r\n    delete gd._mouseDownTime;\r\n    delete gd._legendMouseDownTime;\r\n\r\n    // remove all event listeners\r\n    if(gd.removeAllListeners) gd.removeAllListeners();\r\n};\r\n\r\nplots.style = function(gd) {\r\n    var _modules = gd._fullLayout._visibleModules;\r\n    var styleModules = [];\r\n    var i;\r\n\r\n    // some trace modules reuse the same style method,\r\n    // make sure to not unnecessary call them multiple times.\r\n\r\n    for(i = 0; i < _modules.length; i++) {\r\n        var _module = _modules[i];\r\n        if(_module.style) {\r\n            Lib.pushUnique(styleModules, _module.style);\r\n        }\r\n    }\r\n\r\n    for(i = 0; i < styleModules.length; i++) {\r\n        styleModules[i](gd);\r\n    }\r\n};\r\n\r\nplots.sanitizeMargins = function(fullLayout) {\r\n    // polar doesn't do margins...\r\n    if(!fullLayout || !fullLayout.margin) return;\r\n\r\n    var width = fullLayout.width;\r\n    var height = fullLayout.height;\r\n    var margin = fullLayout.margin;\r\n    var plotWidth = width - (margin.l + margin.r);\r\n    var plotHeight = height - (margin.t + margin.b);\r\n    var correction;\r\n\r\n    // if margin.l + margin.r = 0 then plotWidth > 0\r\n    // as width >= 10 by supplyDefaults\r\n    // similarly for margin.t + margin.b\r\n\r\n    if(plotWidth < 0) {\r\n        correction = (width - 1) / (margin.l + margin.r);\r\n        margin.l = Math.floor(correction * margin.l);\r\n        margin.r = Math.floor(correction * margin.r);\r\n    }\r\n\r\n    if(plotHeight < 0) {\r\n        correction = (height - 1) / (margin.t + margin.b);\r\n        margin.t = Math.floor(correction * margin.t);\r\n        margin.b = Math.floor(correction * margin.b);\r\n    }\r\n};\r\n\r\nplots.clearAutoMarginIds = function(gd) {\r\n    gd._fullLayout._pushmarginIds = {};\r\n};\r\n\r\nplots.allowAutoMargin = function(gd, id) {\r\n    gd._fullLayout._pushmarginIds[id] = 1;\r\n};\r\n\r\nfunction initMargins(fullLayout) {\r\n    var margin = fullLayout.margin;\r\n\r\n    if(!fullLayout._size) {\r\n        var gs = fullLayout._size = {\r\n            l: Math.round(margin.l),\r\n            r: Math.round(margin.r),\r\n            t: Math.round(margin.t),\r\n            b: Math.round(margin.b),\r\n            p: Math.round(margin.pad)\r\n        };\r\n        gs.w = Math.round(fullLayout.width) - gs.l - gs.r;\r\n        gs.h = Math.round(fullLayout.height) - gs.t - gs.b;\r\n    }\r\n    if(!fullLayout._pushmargin) fullLayout._pushmargin = {};\r\n    if(!fullLayout._pushmarginIds) fullLayout._pushmarginIds = {};\r\n}\r\n\r\n// non-negotiable - this is the smallest height we will allow users to specify via explicit margins\r\nvar MIN_SPECIFIED_WIDTH = 2;\r\nvar MIN_SPECIFIED_HEIGHT = 2;\r\n\r\n// could be exposed as an option - the smallest we will allow automargin to shrink a larger plot\r\nvar MIN_REDUCED_WIDTH = 64;\r\nvar MIN_REDUCED_HEIGHT = 64;\r\n\r\n/**\r\n * autoMargin: called by components that may need to expand the margins to\r\n * be rendered on-plot.\r\n *\r\n * @param {DOM element} gd\r\n * @param {string} id - an identifier unique (within this plot) to this object,\r\n *     so we can remove a previous margin expansion from the same object.\r\n * @param {object} o - the margin requirements of this object, or omit to delete\r\n *     this entry (like if it's hidden). Keys are:\r\n *     x, y: plot fraction of the anchor point.\r\n *     xl, xr, yt, yb: if the object has an extent defined in plot fraction,\r\n *         you can specify both edges as plot fractions in each dimension\r\n *     l, r, t, b: the pixels to pad past the plot fraction x[l|r] and y[t|b]\r\n *     pad: extra pixels to add in all directions, default 12 (why?)\r\n */\r\nplots.autoMargin = function(gd, id, o) {\r\n    var fullLayout = gd._fullLayout;\r\n    var width = fullLayout.width;\r\n    var height = fullLayout.height;\r\n    var margin = fullLayout.margin;\r\n\r\n    var minFinalWidth = Lib.constrain(\r\n        width - margin.l - margin.r,\r\n        MIN_SPECIFIED_WIDTH,\r\n        MIN_REDUCED_WIDTH\r\n    );\r\n\r\n    var minFinalHeight = Lib.constrain(\r\n        height - margin.t - margin.b,\r\n        MIN_SPECIFIED_HEIGHT,\r\n        MIN_REDUCED_HEIGHT\r\n    );\r\n\r\n    var maxSpaceW = Math.max(0, width - minFinalWidth);\r\n    var maxSpaceH = Math.max(0, height - minFinalHeight);\r\n\r\n    var pushMargin = fullLayout._pushmargin;\r\n    var pushMarginIds = fullLayout._pushmarginIds;\r\n\r\n    if(margin.autoexpand !== false) {\r\n        if(!o) {\r\n            delete pushMargin[id];\r\n            delete pushMarginIds[id];\r\n        } else {\r\n            var pad = o.pad;\r\n            if(pad === undefined) {\r\n                // if no explicit pad is given, use 12px unless there's a\r\n                // specified margin that's smaller than that\r\n                pad = Math.min(12, margin.l, margin.r, margin.t, margin.b);\r\n            }\r\n\r\n            // if the item is too big, just give it enough automargin to\r\n            // make sure you can still grab it and bring it back\r\n            if(maxSpaceW) {\r\n                var rW = (o.l + o.r) / maxSpaceW;\r\n                if(rW > 1) {\r\n                    o.l /= rW;\r\n                    o.r /= rW;\r\n                }\r\n            }\r\n            if(maxSpaceH) {\r\n                var rH = (o.t + o.b) / maxSpaceH;\r\n                if(rH > 1) {\r\n                    o.t /= rH;\r\n                    o.b /= rH;\r\n                }\r\n            }\r\n\r\n            var xl = o.xl !== undefined ? o.xl : o.x;\r\n            var xr = o.xr !== undefined ? o.xr : o.x;\r\n            var yt = o.yt !== undefined ? o.yt : o.y;\r\n            var yb = o.yb !== undefined ? o.yb : o.y;\r\n\r\n            pushMargin[id] = {\r\n                l: {val: xl, size: o.l + pad},\r\n                r: {val: xr, size: o.r + pad},\r\n                b: {val: yb, size: o.b + pad},\r\n                t: {val: yt, size: o.t + pad}\r\n            };\r\n            pushMarginIds[id] = 1;\r\n        }\r\n\r\n        if(!fullLayout._replotting) {\r\n            return plots.doAutoMargin(gd);\r\n        }\r\n    }\r\n};\r\n\r\nplots.doAutoMargin = function(gd) {\r\n    var fullLayout = gd._fullLayout;\r\n    var width = fullLayout.width;\r\n    var height = fullLayout.height;\r\n\r\n    if(!fullLayout._size) fullLayout._size = {};\r\n    initMargins(fullLayout);\r\n\r\n    var gs = fullLayout._size;\r\n    var margin = fullLayout.margin;\r\n    var oldMargins = Lib.extendFlat({}, gs);\r\n\r\n    // adjust margins for outside components\r\n    // fullLayout.margin is the requested margin,\r\n    // fullLayout._size has margins and plotsize after adjustment\r\n    var ml = margin.l;\r\n    var mr = margin.r;\r\n    var mt = margin.t;\r\n    var mb = margin.b;\r\n    var pushMargin = fullLayout._pushmargin;\r\n    var pushMarginIds = fullLayout._pushmarginIds;\r\n\r\n    if(fullLayout.margin.autoexpand !== false) {\r\n        for(var k in pushMargin) {\r\n            if(!pushMarginIds[k]) delete pushMargin[k];\r\n        }\r\n\r\n        // fill in the requested margins\r\n        pushMargin.base = {\r\n            l: {val: 0, size: ml},\r\n            r: {val: 1, size: mr},\r\n            t: {val: 1, size: mt},\r\n            b: {val: 0, size: mb}\r\n        };\r\n\r\n        // now cycle through all the combinations of l and r\r\n        // (and t and b) to find the required margins\r\n\r\n        for(var k1 in pushMargin) {\r\n            var pushleft = pushMargin[k1].l || {};\r\n            var pushbottom = pushMargin[k1].b || {};\r\n            var fl = pushleft.val;\r\n            var pl = pushleft.size;\r\n            var fb = pushbottom.val;\r\n            var pb = pushbottom.size;\r\n\r\n            for(var k2 in pushMargin) {\r\n                if(isNumeric(pl) && pushMargin[k2].r) {\r\n                    var fr = pushMargin[k2].r.val;\r\n                    var pr = pushMargin[k2].r.size;\r\n                    if(fr > fl) {\r\n                        var newL = (pl * fr + (pr - width) * fl) / (fr - fl);\r\n                        var newR = (pr * (1 - fl) + (pl - width) * (1 - fr)) / (fr - fl);\r\n                        if(newL + newR > ml + mr) {\r\n                            ml = newL;\r\n                            mr = newR;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(isNumeric(pb) && pushMargin[k2].t) {\r\n                    var ft = pushMargin[k2].t.val;\r\n                    var pt = pushMargin[k2].t.size;\r\n                    if(ft > fb) {\r\n                        var newB = (pb * ft + (pt - height) * fb) / (ft - fb);\r\n                        var newT = (pt * (1 - fb) + (pb - height) * (1 - ft)) / (ft - fb);\r\n                        if(newB + newT > mb + mt) {\r\n                            mb = newB;\r\n                            mt = newT;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    var minFinalWidth = Lib.constrain(\r\n        width - margin.l - margin.r,\r\n        MIN_SPECIFIED_WIDTH,\r\n        MIN_REDUCED_WIDTH\r\n    );\r\n\r\n    var minFinalHeight = Lib.constrain(\r\n        height - margin.t - margin.b,\r\n        MIN_SPECIFIED_HEIGHT,\r\n        MIN_REDUCED_HEIGHT\r\n    );\r\n\r\n    var maxSpaceW = Math.max(0, width - minFinalWidth);\r\n    var maxSpaceH = Math.max(0, height - minFinalHeight);\r\n\r\n    if(maxSpaceW) {\r\n        var rW = (ml + mr) / maxSpaceW;\r\n        if(rW > 1) {\r\n            ml /= rW;\r\n            mr /= rW;\r\n        }\r\n    }\r\n\r\n    if(maxSpaceH) {\r\n        var rH = (mb + mt) / maxSpaceH;\r\n        if(rH > 1) {\r\n            mb /= rH;\r\n            mt /= rH;\r\n        }\r\n    }\r\n\r\n    gs.l = Math.round(ml);\r\n    gs.r = Math.round(mr);\r\n    gs.t = Math.round(mt);\r\n    gs.b = Math.round(mb);\r\n    gs.p = Math.round(margin.pad);\r\n    gs.w = Math.round(width) - gs.l - gs.r;\r\n    gs.h = Math.round(height) - gs.t - gs.b;\r\n\r\n    // if things changed and we're not already redrawing, trigger a redraw\r\n    if(!fullLayout._replotting && plots.didMarginChange(oldMargins, gs)) {\r\n        if('_redrawFromAutoMarginCount' in fullLayout) {\r\n            fullLayout._redrawFromAutoMarginCount++;\r\n        } else {\r\n            fullLayout._redrawFromAutoMarginCount = 1;\r\n        }\r\n\r\n        // Always allow at least one redraw and give each margin-push\r\n        // call 3 loops to converge. Of course, for most cases this way too many,\r\n        // but let's keep things on the safe side until we fix our\r\n        // auto-margin pipeline problems:\r\n        // https://github.com/plotly/plotly.js/issues/2704\r\n        var maxNumberOfRedraws = 3 * (1 + Object.keys(pushMarginIds).length);\r\n\r\n        if(fullLayout._redrawFromAutoMarginCount < maxNumberOfRedraws) {\r\n            return Registry.call('_doPlot', gd);\r\n        } else {\r\n            fullLayout._size = oldMargins;\r\n            Lib.warn('Too many auto-margin redraws.');\r\n        }\r\n    }\r\n\r\n    refineTicks(gd);\r\n};\r\n\r\nfunction refineTicks(gd) {\r\n    var axList = axisIDs.list(gd, '', true);\r\n\r\n    [\r\n        '_adjustTickLabelsOverflow',\r\n        '_hideCounterAxisInsideTickLabels'\r\n    ].forEach(function(k) {\r\n        for(var i = 0; i < axList.length; i++) {\r\n            var hideFn = axList[i][k];\r\n            if(hideFn) hideFn();\r\n        }\r\n    });\r\n}\r\n\r\nvar marginKeys = ['l', 'r', 't', 'b', 'p', 'w', 'h'];\r\n\r\nplots.didMarginChange = function(margin0, margin1) {\r\n    for(var i = 0; i < marginKeys.length; i++) {\r\n        var k = marginKeys[i];\r\n        var m0 = margin0[k];\r\n        var m1 = margin1[k];\r\n        // use 1px tolerance in case we old/new differ only\r\n        // by rounding errors, which can lead to infinite loops\r\n        if(!isNumeric(m0) || Math.abs(m1 - m0) > 1) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\n/**\r\n * JSONify the graph data and layout\r\n *\r\n * This function needs to recurse because some src can be inside\r\n * sub-objects.\r\n *\r\n * It also strips out functions and private (starts with _) elements.\r\n * Therefore, we can add temporary things to data and layout that don't\r\n * get saved.\r\n *\r\n * @param gd The graphDiv\r\n * @param {Boolean} dataonly If true, don't return layout.\r\n * @param {'keepref'|'keepdata'|'keepall'} [mode='keepref'] Filter what's kept\r\n *      keepref: remove data for which there's a src present\r\n *          eg if there's xsrc present (and xsrc is well-formed,\r\n *          ie has : and some chars before it), strip out x\r\n *      keepdata: remove all src tags, don't remove the data itself\r\n *      keepall: keep data and src\r\n * @param {String} output If you specify 'object', the result will not be stringified\r\n * @param {Boolean} useDefaults If truthy, use _fullLayout and _fullData\r\n * @param {Boolean} includeConfig If truthy, include _context\r\n * @returns {Object|String}\r\n */\r\nplots.graphJson = function(gd, dataonly, mode, output, useDefaults, includeConfig) {\r\n    // if the defaults aren't supplied yet, we need to do that...\r\n    if((useDefaults && dataonly && !gd._fullData) ||\r\n            (useDefaults && !dataonly && !gd._fullLayout)) {\r\n        plots.supplyDefaults(gd);\r\n    }\r\n\r\n    var data = (useDefaults) ? gd._fullData : gd.data;\r\n    var layout = (useDefaults) ? gd._fullLayout : gd.layout;\r\n    var frames = (gd._transitionData || {})._frames;\r\n\r\n    function stripObj(d, keepFunction) {\r\n        if(typeof d === 'function') {\r\n            return keepFunction ? '_function_' : null;\r\n        }\r\n        if(Lib.isPlainObject(d)) {\r\n            var o = {};\r\n            var src;\r\n            Object.keys(d).sort().forEach(function(v) {\r\n                // remove private elements and functions\r\n                // _ is for private, [ is a mistake ie [object Object]\r\n                if(['_', '['].indexOf(v.charAt(0)) !== -1) return;\r\n\r\n                // if a function, add if necessary then move on\r\n                if(typeof d[v] === 'function') {\r\n                    if(keepFunction) o[v] = '_function';\r\n                    return;\r\n                }\r\n\r\n                // look for src/data matches and remove the appropriate one\r\n                if(mode === 'keepdata') {\r\n                    // keepdata: remove all ...src tags\r\n                    if(v.substr(v.length - 3) === 'src') {\r\n                        return;\r\n                    }\r\n                } else if(mode === 'keepstream') {\r\n                    // keep sourced data if it's being streamed.\r\n                    // similar to keepref, but if the 'stream' object exists\r\n                    // in a trace, we will keep the data array.\r\n                    src = d[v + 'src'];\r\n                    if(typeof src === 'string' && src.indexOf(':') > 0) {\r\n                        if(!Lib.isPlainObject(d.stream)) {\r\n                            return;\r\n                        }\r\n                    }\r\n                } else if(mode !== 'keepall') {\r\n                    // keepref: remove sourced data but only\r\n                    // if the source tag is well-formed\r\n                    src = d[v + 'src'];\r\n                    if(typeof src === 'string' && src.indexOf(':') > 0) {\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                // OK, we're including this... recurse into it\r\n                o[v] = stripObj(d[v], keepFunction);\r\n            });\r\n            return o;\r\n        }\r\n\r\n        if(Array.isArray(d)) {\r\n            return d.map(function(x) {return stripObj(x, keepFunction);});\r\n        }\r\n\r\n        if(Lib.isTypedArray(d)) {\r\n            return Lib.simpleMap(d, Lib.identity);\r\n        }\r\n\r\n        // convert native dates to date strings...\r\n        // mostly for external users exporting to plotly\r\n        if(Lib.isJSDate(d)) return Lib.ms2DateTimeLocal(+d);\r\n\r\n        return d;\r\n    }\r\n\r\n    var obj = {\r\n        data: (data || []).map(function(v) {\r\n            var d = stripObj(v);\r\n            // fit has some little arrays in it that don't contain data,\r\n            // just fit params and meta\r\n            if(dataonly) { delete d.fit; }\r\n            return d;\r\n        })\r\n    };\r\n    if(!dataonly) {\r\n        obj.layout = stripObj(layout);\r\n        if(useDefaults) {\r\n            var gs = layout._size;\r\n            obj.layout.computed = {\r\n                margin: {\r\n                    b: gs.b,\r\n                    l: gs.l,\r\n                    r: gs.r,\r\n                    t: gs.t\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    if(frames) obj.frames = stripObj(frames);\r\n\r\n    if(includeConfig) obj.config = stripObj(gd._context, true);\r\n\r\n    return (output === 'object') ? obj : JSON.stringify(obj);\r\n};\r\n\r\n/**\r\n * Modify a keyframe using a list of operations:\r\n *\r\n * @param {array of objects} operations\r\n *      Sequence of operations to be performed on the keyframes\r\n */\r\nplots.modifyFrames = function(gd, operations) {\r\n    var i, op, frame;\r\n    var _frames = gd._transitionData._frames;\r\n    var _frameHash = gd._transitionData._frameHash;\r\n\r\n    for(i = 0; i < operations.length; i++) {\r\n        op = operations[i];\r\n\r\n        switch(op.type) {\r\n            // No reason this couldn't exist, but is currently unused/untested:\r\n            /* case 'rename':\r\n                frame = _frames[op.index];\r\n                delete _frameHash[frame.name];\r\n                _frameHash[op.name] = frame;\r\n                frame.name = op.name;\r\n                break;*/\r\n            case 'replace':\r\n                frame = op.value;\r\n                var oldName = (_frames[op.index] || {}).name;\r\n                var newName = frame.name;\r\n                _frames[op.index] = _frameHash[newName] = frame;\r\n\r\n                if(newName !== oldName) {\r\n                    // If name has changed in addition to replacement, then update\r\n                    // the lookup table:\r\n                    delete _frameHash[oldName];\r\n                    _frameHash[newName] = frame;\r\n                }\r\n\r\n                break;\r\n            case 'insert':\r\n                frame = op.value;\r\n                _frameHash[frame.name] = frame;\r\n                _frames.splice(op.index, 0, frame);\r\n                break;\r\n            case 'delete':\r\n                frame = _frames[op.index];\r\n                delete _frameHash[frame.name];\r\n                _frames.splice(op.index, 1);\r\n                break;\r\n        }\r\n    }\r\n\r\n    return Promise.resolve();\r\n};\r\n\r\n/*\r\n * Compute a keyframe. Merge a keyframe into its base frame(s) and\r\n * expand properties.\r\n *\r\n * @param {object} frameLookup\r\n *      An object containing frames keyed by name (i.e. gd._transitionData._frameHash)\r\n * @param {string} frame\r\n *      The name of the keyframe to be computed\r\n *\r\n * Returns: a new object with the merged content\r\n */\r\nplots.computeFrame = function(gd, frameName) {\r\n    var frameLookup = gd._transitionData._frameHash;\r\n    var i, traceIndices, traceIndex, destIndex;\r\n\r\n    // Null or undefined will fail on .toString(). We'll allow numbers since we\r\n    // make it clear frames must be given string names, but we'll allow numbers\r\n    // here since they're otherwise fine for looking up frames as long as they're\r\n    // properly cast to strings. We really just want to ensure here that this\r\n    // 1) doesn't fail, and\r\n    // 2) doens't give an incorrect answer (which String(frameName) would)\r\n    if(!frameName) {\r\n        throw new Error('computeFrame must be given a string frame name');\r\n    }\r\n\r\n    var framePtr = frameLookup[frameName.toString()];\r\n\r\n    // Return false if the name is invalid:\r\n    if(!framePtr) {\r\n        return false;\r\n    }\r\n\r\n    var frameStack = [framePtr];\r\n    var frameNameStack = [framePtr.name];\r\n\r\n    // Follow frame pointers:\r\n    while(framePtr.baseframe && (framePtr = frameLookup[framePtr.baseframe.toString()])) {\r\n        // Avoid infinite loops:\r\n        if(frameNameStack.indexOf(framePtr.name) !== -1) break;\r\n\r\n        frameStack.push(framePtr);\r\n        frameNameStack.push(framePtr.name);\r\n    }\r\n\r\n    // A new object for the merged result:\r\n    var result = {};\r\n\r\n    // Merge, starting with the last and ending with the desired frame:\r\n    while((framePtr = frameStack.pop())) {\r\n        if(framePtr.layout) {\r\n            result.layout = plots.extendLayout(result.layout, framePtr.layout);\r\n        }\r\n\r\n        if(framePtr.data) {\r\n            if(!result.data) {\r\n                result.data = [];\r\n            }\r\n            traceIndices = framePtr.traces;\r\n\r\n            if(!traceIndices) {\r\n                // If not defined, assume serial order starting at zero\r\n                traceIndices = [];\r\n                for(i = 0; i < framePtr.data.length; i++) {\r\n                    traceIndices[i] = i;\r\n                }\r\n            }\r\n\r\n            if(!result.traces) {\r\n                result.traces = [];\r\n            }\r\n\r\n            for(i = 0; i < framePtr.data.length; i++) {\r\n                // Loop through this frames data, find out where it should go,\r\n                // and merge it!\r\n                traceIndex = traceIndices[i];\r\n                if(traceIndex === undefined || traceIndex === null) {\r\n                    continue;\r\n                }\r\n\r\n                destIndex = result.traces.indexOf(traceIndex);\r\n                if(destIndex === -1) {\r\n                    destIndex = result.data.length;\r\n                    result.traces[destIndex] = traceIndex;\r\n                }\r\n\r\n                result.data[destIndex] = plots.extendTrace(result.data[destIndex], framePtr.data[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    return result;\r\n};\r\n\r\n/*\r\n * Recompute the lookup table that maps frame name -> frame object. addFrames/\r\n * deleteFrames already manages this data one at a time, so the only time this\r\n * is necessary is if you poke around manually in `gd._transitionData._frames`\r\n * and create and haven't updated the lookup table.\r\n */\r\nplots.recomputeFrameHash = function(gd) {\r\n    var hash = gd._transitionData._frameHash = {};\r\n    var frames = gd._transitionData._frames;\r\n    for(var i = 0; i < frames.length; i++) {\r\n        var frame = frames[i];\r\n        if(frame && frame.name) {\r\n            hash[frame.name] = frame;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Extend an object, treating container arrays very differently by extracting\r\n * their contents and merging them separately.\r\n *\r\n * This exists so that we can extendDeepNoArrays and avoid stepping into data\r\n * arrays without knowledge of the plot schema, but so that we may also manually\r\n * recurse into known container arrays, such as transforms.\r\n *\r\n * See extendTrace and extendLayout below for usage.\r\n */\r\nplots.extendObjectWithContainers = function(dest, src, containerPaths) {\r\n    var containerProp, containerVal, i, j, srcProp, destProp, srcContainer, destContainer;\r\n    var copy = Lib.extendDeepNoArrays({}, src || {});\r\n    var expandedObj = Lib.expandObjectPaths(copy);\r\n    var containerObj = {};\r\n\r\n    // Step through and extract any container properties. Otherwise extendDeepNoArrays\r\n    // will clobber any existing properties with an empty array and then supplyDefaults\r\n    // will reset everything to defaults.\r\n    if(containerPaths && containerPaths.length) {\r\n        for(i = 0; i < containerPaths.length; i++) {\r\n            containerProp = Lib.nestedProperty(expandedObj, containerPaths[i]);\r\n            containerVal = containerProp.get();\r\n\r\n            if(containerVal === undefined) {\r\n                Lib.nestedProperty(containerObj, containerPaths[i]).set(null);\r\n            } else {\r\n                containerProp.set(null);\r\n                Lib.nestedProperty(containerObj, containerPaths[i]).set(containerVal);\r\n            }\r\n        }\r\n    }\r\n\r\n    dest = Lib.extendDeepNoArrays(dest || {}, expandedObj);\r\n\r\n    if(containerPaths && containerPaths.length) {\r\n        for(i = 0; i < containerPaths.length; i++) {\r\n            srcProp = Lib.nestedProperty(containerObj, containerPaths[i]);\r\n            srcContainer = srcProp.get();\r\n\r\n            if(!srcContainer) continue;\r\n\r\n            destProp = Lib.nestedProperty(dest, containerPaths[i]);\r\n            destContainer = destProp.get();\r\n\r\n            if(!Array.isArray(destContainer)) {\r\n                destContainer = [];\r\n                destProp.set(destContainer);\r\n            }\r\n\r\n            for(j = 0; j < srcContainer.length; j++) {\r\n                var srcObj = srcContainer[j];\r\n\r\n                if(srcObj === null) destContainer[j] = null;\r\n                else {\r\n                    destContainer[j] = plots.extendObjectWithContainers(destContainer[j], srcObj);\r\n                }\r\n            }\r\n\r\n            destProp.set(destContainer);\r\n        }\r\n    }\r\n\r\n    return dest;\r\n};\r\n\r\nplots.dataArrayContainers = ['transforms', 'dimensions'];\r\nplots.layoutArrayContainers = Registry.layoutArrayContainers;\r\n\r\n/*\r\n * Extend a trace definition. This method:\r\n *\r\n *  1. directly transfers any array references\r\n *  2. manually recurses into container arrays like transforms\r\n *\r\n * The result is the original object reference with the new contents merged in.\r\n */\r\nplots.extendTrace = function(destTrace, srcTrace) {\r\n    return plots.extendObjectWithContainers(destTrace, srcTrace, plots.dataArrayContainers);\r\n};\r\n\r\n/*\r\n * Extend a layout definition. This method:\r\n *\r\n *  1. directly transfers any array references (not critically important for\r\n *     layout since there aren't really data arrays)\r\n *  2. manually recurses into container arrays like annotations\r\n *\r\n * The result is the original object reference with the new contents merged in.\r\n */\r\nplots.extendLayout = function(destLayout, srcLayout) {\r\n    return plots.extendObjectWithContainers(destLayout, srcLayout, plots.layoutArrayContainers);\r\n};\r\n\r\n/**\r\n * Transition to a set of new data and layout properties from Plotly.animate\r\n *\r\n * @param {DOM element} gd\r\n * @param {Object[]} data\r\n *      an array of data objects following the normal Plotly data definition format\r\n * @param {Object} layout\r\n *      a layout object, following normal Plotly layout format\r\n * @param {Number[]} traces\r\n *      indices of the corresponding traces specified in `data`\r\n * @param {Object} frameOpts\r\n *      options for the frame (i.e. whether to redraw post-transition)\r\n * @param {Object} transitionOpts\r\n *      options for the transition\r\n */\r\nplots.transition = function(gd, data, layout, traces, frameOpts, transitionOpts) {\r\n    var opts = {redraw: frameOpts.redraw};\r\n    var transitionedTraces = {};\r\n    var axEdits = [];\r\n\r\n    opts.prepareFn = function() {\r\n        var dataLength = Array.isArray(data) ? data.length : 0;\r\n        var traceIndices = traces.slice(0, dataLength);\r\n\r\n        for(var i = 0; i < traceIndices.length; i++) {\r\n            var traceIdx = traceIndices[i];\r\n            var trace = gd._fullData[traceIdx];\r\n            var _module = trace._module;\r\n\r\n            // There's nothing to do if this module is not defined:\r\n            if(!_module) continue;\r\n\r\n            // Don't register the trace as transitioned if it doesn't know what to do.\r\n            // If it *is* registered, it will receive a callback that it's responsible\r\n            // for calling in order to register the transition as having completed.\r\n            if(_module.animatable) {\r\n                var n = _module.basePlotModule.name;\r\n                if(!transitionedTraces[n]) transitionedTraces[n] = [];\r\n                transitionedTraces[n].push(traceIdx);\r\n            }\r\n\r\n            gd.data[traceIndices[i]] = plots.extendTrace(gd.data[traceIndices[i]], data[i]);\r\n        }\r\n\r\n        // Follow the same procedure. Clone it so we don't mangle the input, then\r\n        // expand any object paths so we can merge deep into gd.layout:\r\n        var layoutUpdate = Lib.expandObjectPaths(Lib.extendDeepNoArrays({}, layout));\r\n\r\n        // Before merging though, we need to modify the incoming layout. We only\r\n        // know how to *transition* layout ranges, so it's imperative that a new\r\n        // range not be sent to the layout before the transition has started. So\r\n        // we must remove the things we can transition:\r\n        var axisAttrRe = /^[xy]axis[0-9]*$/;\r\n        for(var attr in layoutUpdate) {\r\n            if(!axisAttrRe.test(attr)) continue;\r\n            delete layoutUpdate[attr].range;\r\n        }\r\n\r\n        plots.extendLayout(gd.layout, layoutUpdate);\r\n\r\n        // Supply defaults after applying the incoming properties. Note that any attempt\r\n        // to simplify this step and reduce the amount of work resulted in the reconstruction\r\n        // of essentially the whole supplyDefaults step, so that it seems sensible to just use\r\n        // supplyDefaults even though it's heavier than would otherwise be desired for\r\n        // transitions:\r\n\r\n        // first delete calcdata so supplyDefaults knows a calc step is coming\r\n        delete gd.calcdata;\r\n\r\n        plots.supplyDefaults(gd);\r\n        plots.doCalcdata(gd);\r\n\r\n        var newLayout = Lib.expandObjectPaths(layout);\r\n\r\n        if(newLayout) {\r\n            var subplots = gd._fullLayout._plots;\r\n\r\n            for(var k in subplots) {\r\n                var plotinfo = subplots[k];\r\n                var xa = plotinfo.xaxis;\r\n                var ya = plotinfo.yaxis;\r\n                var xr0 = xa.range.slice();\r\n                var yr0 = ya.range.slice();\r\n\r\n                var xr1 = null;\r\n                var yr1 = null;\r\n                var editX = null;\r\n                var editY = null;\r\n\r\n                if(Array.isArray(newLayout[xa._name + '.range'])) {\r\n                    xr1 = newLayout[xa._name + '.range'].slice();\r\n                } else if(Array.isArray((newLayout[xa._name] || {}).range)) {\r\n                    xr1 = newLayout[xa._name].range.slice();\r\n                }\r\n                if(Array.isArray(newLayout[ya._name + '.range'])) {\r\n                    yr1 = newLayout[ya._name + '.range'].slice();\r\n                } else if(Array.isArray((newLayout[ya._name] || {}).range)) {\r\n                    yr1 = newLayout[ya._name].range.slice();\r\n                }\r\n\r\n                if(xr0 && xr1 &&\r\n                    (xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1]))\r\n                ) {\r\n                    editX = {xr0: xr0, xr1: xr1};\r\n                }\r\n                if(yr0 && yr1 &&\r\n                    (ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1]))\r\n                ) {\r\n                    editY = {yr0: yr0, yr1: yr1};\r\n                }\r\n\r\n                if(editX || editY) {\r\n                    axEdits.push(Lib.extendFlat({plotinfo: plotinfo}, editX, editY));\r\n                }\r\n            }\r\n        }\r\n\r\n        return Promise.resolve();\r\n    };\r\n\r\n    opts.runFn = function(makeCallback) {\r\n        var traceTransitionOpts;\r\n        var basePlotModules = gd._fullLayout._basePlotModules;\r\n        var hasAxisTransition = axEdits.length;\r\n        var i;\r\n\r\n        if(layout) {\r\n            for(i = 0; i < basePlotModules.length; i++) {\r\n                if(basePlotModules[i].transitionAxes) {\r\n                    basePlotModules[i].transitionAxes(gd, axEdits, transitionOpts, makeCallback);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Here handle the exception that we refuse to animate scales and axes at the same\r\n        // time. In other words, if there's an axis transition, then set the data transition\r\n        // to instantaneous.\r\n        if(hasAxisTransition) {\r\n            traceTransitionOpts = Lib.extendFlat({}, transitionOpts);\r\n            traceTransitionOpts.duration = 0;\r\n            // This means do not transition cartesian traces,\r\n            // this happens on layout-only (e.g. axis range) animations\r\n            delete transitionedTraces.cartesian;\r\n        } else {\r\n            traceTransitionOpts = transitionOpts;\r\n        }\r\n\r\n        // Note that we pass a callback to *create* the callback that must be invoked on completion.\r\n        // This is since not all traces know about transitions, so it greatly simplifies matters if\r\n        // the trace is responsible for creating a callback, if needed, and then executing it when\r\n        // the time is right.\r\n        for(var n in transitionedTraces) {\r\n            var traceIndices = transitionedTraces[n];\r\n            var _module = gd._fullData[traceIndices[0]]._module;\r\n            _module.basePlotModule.plot(gd, traceIndices, traceTransitionOpts, makeCallback);\r\n        }\r\n    };\r\n\r\n    return _transition(gd, transitionOpts, opts);\r\n};\r\n\r\n/**\r\n * Transition to a set of new data and layout properties from Plotly.react\r\n *\r\n * @param {DOM element} gd\r\n * @param {object} restyleFlags\r\n * - anim {'all'|'some'}\r\n * @param {object} relayoutFlags\r\n * - anim {'all'|'some'}\r\n * @param {object} oldFullLayout : old (pre Plotly.react) fullLayout\r\n */\r\nplots.transitionFromReact = function(gd, restyleFlags, relayoutFlags, oldFullLayout) {\r\n    var fullLayout = gd._fullLayout;\r\n    var transitionOpts = fullLayout.transition;\r\n    var opts = {};\r\n    var axEdits = [];\r\n\r\n    opts.prepareFn = function() {\r\n        var subplots = fullLayout._plots;\r\n\r\n        // no need to redraw at end of transition,\r\n        // if all changes are animatable\r\n        opts.redraw = false;\r\n        if(restyleFlags.anim === 'some') opts.redraw = true;\r\n        if(relayoutFlags.anim === 'some') opts.redraw = true;\r\n\r\n        for(var k in subplots) {\r\n            var plotinfo = subplots[k];\r\n            var xa = plotinfo.xaxis;\r\n            var ya = plotinfo.yaxis;\r\n            var xr0 = oldFullLayout[xa._name].range.slice();\r\n            var yr0 = oldFullLayout[ya._name].range.slice();\r\n            var xr1 = xa.range.slice();\r\n            var yr1 = ya.range.slice();\r\n\r\n            xa.setScale();\r\n            ya.setScale();\r\n\r\n            var editX = null;\r\n            var editY = null;\r\n\r\n            if(xa.r2l(xr0[0]) !== xa.r2l(xr1[0]) || xa.r2l(xr0[1]) !== xa.r2l(xr1[1])) {\r\n                editX = {xr0: xr0, xr1: xr1};\r\n            }\r\n            if(ya.r2l(yr0[0]) !== ya.r2l(yr1[0]) || ya.r2l(yr0[1]) !== ya.r2l(yr1[1])) {\r\n                editY = {yr0: yr0, yr1: yr1};\r\n            }\r\n\r\n            if(editX || editY) {\r\n                axEdits.push(Lib.extendFlat({plotinfo: plotinfo}, editX, editY));\r\n            }\r\n        }\r\n\r\n        return Promise.resolve();\r\n    };\r\n\r\n    opts.runFn = function(makeCallback) {\r\n        var fullData = gd._fullData;\r\n        var fullLayout = gd._fullLayout;\r\n        var basePlotModules = fullLayout._basePlotModules;\r\n\r\n        var axisTransitionOpts;\r\n        var traceTransitionOpts;\r\n        var transitionedTraces;\r\n\r\n        var allTraceIndices = [];\r\n        for(var i = 0; i < fullData.length; i++) {\r\n            allTraceIndices.push(i);\r\n        }\r\n\r\n        function transitionAxes() {\r\n            if(!gd._fullLayout) return;\r\n            for(var j = 0; j < basePlotModules.length; j++) {\r\n                if(basePlotModules[j].transitionAxes) {\r\n                    basePlotModules[j].transitionAxes(gd, axEdits, axisTransitionOpts, makeCallback);\r\n                }\r\n            }\r\n        }\r\n\r\n        function transitionTraces() {\r\n            if(!gd._fullLayout) return;\r\n            for(var j = 0; j < basePlotModules.length; j++) {\r\n                basePlotModules[j].plot(gd, transitionedTraces, traceTransitionOpts, makeCallback);\r\n            }\r\n        }\r\n\r\n        if(axEdits.length && restyleFlags.anim) {\r\n            if(transitionOpts.ordering === 'traces first') {\r\n                axisTransitionOpts = Lib.extendFlat({}, transitionOpts, {duration: 0});\r\n                transitionedTraces = allTraceIndices;\r\n                traceTransitionOpts = transitionOpts;\r\n                setTimeout(transitionAxes, transitionOpts.duration);\r\n                transitionTraces();\r\n            } else {\r\n                axisTransitionOpts = transitionOpts;\r\n                transitionedTraces = null;\r\n                traceTransitionOpts = Lib.extendFlat({}, transitionOpts, {duration: 0});\r\n                setTimeout(transitionTraces, axisTransitionOpts.duration);\r\n                transitionAxes();\r\n            }\r\n        } else if(axEdits.length) {\r\n            axisTransitionOpts = transitionOpts;\r\n            transitionAxes();\r\n        } else if(restyleFlags.anim) {\r\n            transitionedTraces = allTraceIndices;\r\n            traceTransitionOpts = transitionOpts;\r\n            transitionTraces();\r\n        }\r\n    };\r\n\r\n    return _transition(gd, transitionOpts, opts);\r\n};\r\n\r\n/**\r\n * trace/layout transition wrapper that works\r\n * for transitions initiated by Plotly.animate and Plotly.react.\r\n *\r\n * @param {DOM element} gd\r\n * @param {object} transitionOpts\r\n * @param {object} opts\r\n * - redraw {boolean}\r\n * - prepareFn {function} *should return a Promise*\r\n * - runFn {function} ran inside executeTransitions\r\n */\r\nfunction _transition(gd, transitionOpts, opts) {\r\n    var aborted = false;\r\n\r\n    function executeCallbacks(list) {\r\n        var p = Promise.resolve();\r\n        if(!list) return p;\r\n        while(list.length) {\r\n            p = p.then((list.shift()));\r\n        }\r\n        return p;\r\n    }\r\n\r\n    function flushCallbacks(list) {\r\n        if(!list) return;\r\n        while(list.length) {\r\n            list.shift();\r\n        }\r\n    }\r\n\r\n    function executeTransitions() {\r\n        gd.emit('plotly_transitioning', []);\r\n\r\n        return new Promise(function(resolve) {\r\n            // This flag is used to disabled things like autorange:\r\n            gd._transitioning = true;\r\n\r\n            // When instantaneous updates are coming through quickly, it's too much to simply disable\r\n            // all interaction, so store this flag so we can disambiguate whether mouse interactions\r\n            // should be fully disabled or not:\r\n            if(transitionOpts.duration > 0) {\r\n                gd._transitioningWithDuration = true;\r\n            }\r\n\r\n            // If another transition is triggered, this callback will be executed simply because it's\r\n            // in the interruptCallbacks queue. If this transition completes, it will instead flush\r\n            // that queue and forget about this callback.\r\n            gd._transitionData._interruptCallbacks.push(function() {\r\n                aborted = true;\r\n            });\r\n\r\n            if(opts.redraw) {\r\n                gd._transitionData._interruptCallbacks.push(function() {\r\n                    return Registry.call('redraw', gd);\r\n                });\r\n            }\r\n\r\n            // Emit this and make sure it happens last:\r\n            gd._transitionData._interruptCallbacks.push(function() {\r\n                gd.emit('plotly_transitioninterrupted', []);\r\n            });\r\n\r\n            // Construct callbacks that are executed on transition end. This ensures the d3 transitions\r\n            // are *complete* before anything else is done.\r\n            var numCallbacks = 0;\r\n            var numCompleted = 0;\r\n            function makeCallback() {\r\n                numCallbacks++;\r\n                return function() {\r\n                    numCompleted++;\r\n                    // When all are complete, perform a redraw:\r\n                    if(!aborted && numCompleted === numCallbacks) {\r\n                        completeTransition(resolve);\r\n                    }\r\n                };\r\n            }\r\n\r\n            opts.runFn(makeCallback);\r\n\r\n            // If nothing else creates a callback, then this will trigger the completion in the next tick:\r\n            setTimeout(makeCallback());\r\n        });\r\n    }\r\n\r\n    function completeTransition(callback) {\r\n        // This a simple workaround for tests which purge the graph before animations\r\n        // have completed. That's not a very common case, so this is the simplest\r\n        // fix.\r\n        if(!gd._transitionData) return;\r\n\r\n        flushCallbacks(gd._transitionData._interruptCallbacks);\r\n\r\n        return Promise.resolve().then(function() {\r\n            if(opts.redraw) {\r\n                return Registry.call('redraw', gd);\r\n            }\r\n        }).then(function() {\r\n            // Set transitioning false again once the redraw has occurred. This is used, for example,\r\n            // to prevent the trailing redraw from autoranging:\r\n            gd._transitioning = false;\r\n            gd._transitioningWithDuration = false;\r\n\r\n            gd.emit('plotly_transitioned', []);\r\n        }).then(callback);\r\n    }\r\n\r\n    function interruptPreviousTransitions() {\r\n        // Fail-safe against purged plot:\r\n        if(!gd._transitionData) return;\r\n\r\n        // If a transition is interrupted, set this to false. At the moment, the only thing that would\r\n        // interrupt a transition is another transition, so that it will momentarily be set to true\r\n        // again, but this determines whether autorange or dragbox work, so it's for the sake of\r\n        // cleanliness:\r\n        gd._transitioning = false;\r\n\r\n        return executeCallbacks(gd._transitionData._interruptCallbacks);\r\n    }\r\n\r\n    var seq = [\r\n        plots.previousPromises,\r\n        interruptPreviousTransitions,\r\n        opts.prepareFn,\r\n        plots.rehover,\r\n        executeTransitions\r\n    ];\r\n\r\n    var transitionStarting = Lib.syncOrAsync(seq, gd);\r\n\r\n    if(!transitionStarting || !transitionStarting.then) {\r\n        transitionStarting = Promise.resolve();\r\n    }\r\n\r\n    return transitionStarting.then(function() { return gd; });\r\n}\r\n\r\nplots.doCalcdata = function(gd, traces) {\r\n    var axList = axisIDs.list(gd);\r\n    var fullData = gd._fullData;\r\n    var fullLayout = gd._fullLayout;\r\n\r\n    var trace, _module, i, j;\r\n\r\n    // XXX: Is this correct? Needs a closer look so that *some* traces can be recomputed without\r\n    // *all* needing doCalcdata:\r\n    var calcdata = new Array(fullData.length);\r\n    var oldCalcdata = (gd.calcdata || []).slice();\r\n    gd.calcdata = calcdata;\r\n\r\n    // extra helper variables\r\n\r\n    // how many box/violins plots do we have (in case they're grouped)\r\n    fullLayout._numBoxes = 0;\r\n    fullLayout._numViolins = 0;\r\n\r\n    // initialize violin per-scale-group stats container\r\n    fullLayout._violinScaleGroupStats = {};\r\n\r\n    // for calculating avg luminosity of heatmaps\r\n    gd._hmpixcount = 0;\r\n    gd._hmlumcount = 0;\r\n\r\n    // for sharing colors across pies / sunbursts / treemap / icicle / funnelarea (and for legend)\r\n    fullLayout._piecolormap = {};\r\n    fullLayout._sunburstcolormap = {};\r\n    fullLayout._treemapcolormap = {};\r\n    fullLayout._iciclecolormap = {};\r\n    fullLayout._funnelareacolormap = {};\r\n\r\n    // If traces were specified and this trace was not included,\r\n    // then transfer it over from the old calcdata:\r\n    for(i = 0; i < fullData.length; i++) {\r\n        if(Array.isArray(traces) && traces.indexOf(i) === -1) {\r\n            calcdata[i] = oldCalcdata[i];\r\n            continue;\r\n        }\r\n    }\r\n\r\n    for(i = 0; i < fullData.length; i++) {\r\n        trace = fullData[i];\r\n\r\n        trace._arrayAttrs = PlotSchema.findArrayAttributes(trace);\r\n\r\n        // keep track of trace extremes (for autorange) in here\r\n        trace._extremes = {};\r\n    }\r\n\r\n    // add polar axes to axis list\r\n    var polarIds = fullLayout._subplots.polar || [];\r\n    for(i = 0; i < polarIds.length; i++) {\r\n        axList.push(\r\n            fullLayout[polarIds[i]].radialaxis,\r\n            fullLayout[polarIds[i]].angularaxis\r\n        );\r\n    }\r\n\r\n    // clear relinked cmin/cmax values in shared axes to start aggregation from scratch\r\n    for(var k in fullLayout._colorAxes) {\r\n        var cOpts = fullLayout[k];\r\n        if(cOpts.cauto !== false) {\r\n            delete cOpts.cmin;\r\n            delete cOpts.cmax;\r\n        }\r\n    }\r\n\r\n    var hasCalcTransform = false;\r\n\r\n    function transformCalci(i) {\r\n        trace = fullData[i];\r\n        _module = trace._module;\r\n\r\n        if(trace.visible === true && trace.transforms) {\r\n            // we need one round of trace module calc before\r\n            // the calc transform to 'fill in' the categories list\r\n            // used for example in the data-to-coordinate method\r\n            if(_module && _module.calc) {\r\n                var cdi = _module.calc(gd, trace);\r\n\r\n                // must clear scene 'batches', so that 2nd\r\n                // _module.calc call starts from scratch\r\n                if(cdi[0] && cdi[0].t && cdi[0].t._scene) {\r\n                    delete cdi[0].t._scene.dirty;\r\n                }\r\n            }\r\n\r\n            for(j = 0; j < trace.transforms.length; j++) {\r\n                var transform = trace.transforms[j];\r\n\r\n                _module = transformsRegistry[transform.type];\r\n                if(_module && _module.calcTransform) {\r\n                    trace._hasCalcTransform = true;\r\n                    hasCalcTransform = true;\r\n                    _module.calcTransform(gd, trace, transform);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function calci(i, isContainer) {\r\n        trace = fullData[i];\r\n        _module = trace._module;\r\n\r\n        if(!!_module.isContainer !== isContainer) return;\r\n\r\n        var cd = [];\r\n\r\n        if(trace.visible === true && trace._length !== 0) {\r\n            // clear existing ref in case it got relinked\r\n            delete trace._indexToPoints;\r\n            // keep ref of index-to-points map object of the *last* enabled transform,\r\n            // this index-to-points map object is required to determine the calcdata indices\r\n            // that correspond to input indices (e.g. from 'selectedpoints')\r\n            var transforms = trace.transforms || [];\r\n            for(j = transforms.length - 1; j >= 0; j--) {\r\n                if(transforms[j].enabled) {\r\n                    trace._indexToPoints = transforms[j]._indexToPoints;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if(_module && _module.calc) {\r\n                cd = _module.calc(gd, trace);\r\n            }\r\n        }\r\n\r\n        // Make sure there is a first point.\r\n        //\r\n        // This ensures there is a calcdata item for every trace,\r\n        // even if cartesian logic doesn't handle it (for things like legends).\r\n        if(!Array.isArray(cd) || !cd[0]) {\r\n            cd = [{x: BADNUM, y: BADNUM}];\r\n        }\r\n\r\n        // add the trace-wide properties to the first point,\r\n        // per point properties to every point\r\n        // t is the holder for trace-wide properties\r\n        if(!cd[0].t) cd[0].t = {};\r\n        cd[0].trace = trace;\r\n\r\n        calcdata[i] = cd;\r\n    }\r\n\r\n    setupAxisCategories(axList, fullData, fullLayout);\r\n\r\n    // 'transform' loop - must calc container traces first\r\n    // so that if their dependent traces can get transform properly\r\n    for(i = 0; i < fullData.length; i++) calci(i, true);\r\n    for(i = 0; i < fullData.length; i++) transformCalci(i);\r\n\r\n    // clear stuff that should recomputed in 'regular' loop\r\n    if(hasCalcTransform) setupAxisCategories(axList, fullData, fullLayout);\r\n\r\n    // 'regular' loop - make sure container traces (eg carpet) calc before\r\n    // contained traces (eg contourcarpet)\r\n    for(i = 0; i < fullData.length; i++) calci(i, true);\r\n    for(i = 0; i < fullData.length; i++) calci(i, false);\r\n\r\n    doCrossTraceCalc(gd);\r\n\r\n    // Sort axis categories per value if specified\r\n    var sorted = sortAxisCategoriesByValue(axList, gd);\r\n    if(sorted.length) {\r\n        // how many box/violins plots do we have (in case they're grouped)\r\n        fullLayout._numBoxes = 0;\r\n        fullLayout._numViolins = 0;\r\n        // If a sort operation was performed, run calc() again\r\n        for(i = 0; i < sorted.length; i++) calci(sorted[i], true);\r\n        for(i = 0; i < sorted.length; i++) calci(sorted[i], false);\r\n        doCrossTraceCalc(gd);\r\n    }\r\n\r\n    Registry.getComponentMethod('fx', 'calc')(gd);\r\n    Registry.getComponentMethod('errorbars', 'calc')(gd);\r\n};\r\n\r\nvar sortAxisCategoriesByValueRegex = /(total|sum|min|max|mean|median) (ascending|descending)/;\r\n\r\nfunction sortAxisCategoriesByValue(axList, gd) {\r\n    var affectedTraces = [];\r\n    var i, j, k, l, o;\r\n\r\n    function zMapCategory(type, ax, value) {\r\n        var axLetter = ax._id.charAt(0);\r\n        if(type === 'histogram2dcontour') {\r\n            var counterAxLetter = ax._counterAxes[0];\r\n            var counterAx = axisIDs.getFromId(gd, counterAxLetter);\r\n\r\n            var xCategorical = axLetter === 'x' || (counterAxLetter === 'x' && counterAx.type === 'category');\r\n            var yCategorical = axLetter === 'y' || (counterAxLetter === 'y' && counterAx.type === 'category');\r\n\r\n            return function(o, l) {\r\n                if(o === 0 || l === 0) return -1; // Skip first row and column\r\n                if(xCategorical && o === value[l].length - 1) return -1;\r\n                if(yCategorical && l === value.length - 1) return -1;\r\n\r\n                return (axLetter === 'y' ? l : o) - 1;\r\n            };\r\n        } else {\r\n            return function(o, l) {\r\n                return axLetter === 'y' ? l : o;\r\n            };\r\n        }\r\n    }\r\n\r\n    var aggFn = {\r\n        'min': function(values) {return Lib.aggNums(Math.min, null, values);},\r\n        'max': function(values) {return Lib.aggNums(Math.max, null, values);},\r\n        'sum': function(values) {return Lib.aggNums(function(a, b) { return a + b;}, null, values);},\r\n        'total': function(values) {return Lib.aggNums(function(a, b) { return a + b;}, null, values);},\r\n        'mean': function(values) {return Lib.mean(values);},\r\n        'median': function(values) {return Lib.median(values);}\r\n    };\r\n\r\n    for(i = 0; i < axList.length; i++) {\r\n        var ax = axList[i];\r\n        if(ax.type !== 'category') continue;\r\n\r\n        // Order by value\r\n        var match = ax.categoryorder.match(sortAxisCategoriesByValueRegex);\r\n        if(match) {\r\n            var aggregator = match[1];\r\n            var order = match[2];\r\n\r\n            var axLetter = ax._id.charAt(0);\r\n            var isX = axLetter === 'x';\r\n\r\n            // Store values associated with each category\r\n            var categoriesValue = [];\r\n            for(j = 0; j < ax._categories.length; j++) {\r\n                categoriesValue.push([ax._categories[j], []]);\r\n            }\r\n\r\n            // Collect values across traces\r\n            for(j = 0; j < ax._traceIndices.length; j++) {\r\n                var traceIndex = ax._traceIndices[j];\r\n                var fullTrace = gd._fullData[traceIndex];\r\n\r\n                // Skip over invisible traces\r\n                if(fullTrace.visible !== true) continue;\r\n\r\n                var type = fullTrace.type;\r\n                if(Registry.traceIs(fullTrace, 'histogram')) {\r\n                    delete fullTrace._xautoBinFinished;\r\n                    delete fullTrace._yautoBinFinished;\r\n                }\r\n                var isSplom = type === 'splom';\r\n                var isScattergl = type === 'scattergl';\r\n\r\n                var cd = gd.calcdata[traceIndex];\r\n                for(k = 0; k < cd.length; k++) {\r\n                    var cdi = cd[k];\r\n                    var catIndex, value;\r\n\r\n                    if(isSplom) {\r\n                        // If `splom`, collect values across dimensions\r\n                        // Find which dimension the current axis is representing\r\n                        var currentDimensionIndex = fullTrace._axesDim[ax._id];\r\n\r\n                        // Apply logic to associated x axis if it's defined\r\n                        if(!isX) {\r\n                            var associatedXAxisID = fullTrace._diag[currentDimensionIndex][0];\r\n                            if(associatedXAxisID) ax = gd._fullLayout[axisIDs.id2name(associatedXAxisID)];\r\n                        }\r\n\r\n                        var categories = cdi.trace.dimensions[currentDimensionIndex].values;\r\n                        for(l = 0; l < categories.length; l++) {\r\n                            catIndex = ax._categoriesMap[categories[l]];\r\n\r\n                            // Collect associated values at index `l` over all other dimensions\r\n                            for(o = 0; o < cdi.trace.dimensions.length; o++) {\r\n                                if(o === currentDimensionIndex) continue;\r\n                                var dimension = cdi.trace.dimensions[o];\r\n                                categoriesValue[catIndex][1].push(dimension.values[l]);\r\n                            }\r\n                        }\r\n                    } else if(isScattergl) {\r\n                        // If `scattergl`, collect all values stashed under cdi.t\r\n                        for(l = 0; l < cdi.t.x.length; l++) {\r\n                            if(isX) {\r\n                                catIndex = cdi.t.x[l];\r\n                                value = cdi.t.y[l];\r\n                            } else {\r\n                                catIndex = cdi.t.y[l];\r\n                                value = cdi.t.x[l];\r\n                            }\r\n                            categoriesValue[catIndex][1].push(value);\r\n                        }\r\n                        // must clear scene 'batches', so that 2nd\r\n                        // _module.calc call starts from scratch\r\n                        if(cdi.t && cdi.t._scene) {\r\n                            delete cdi.t._scene.dirty;\r\n                        }\r\n                    } else if(cdi.hasOwnProperty('z')) {\r\n                        // If 2dMap, collect values in `z`\r\n                        value = cdi.z;\r\n                        var mapping = zMapCategory(fullTrace.type, ax, value);\r\n\r\n                        for(l = 0; l < value.length; l++) {\r\n                            for(o = 0; o < value[l].length; o++) {\r\n                                catIndex = mapping(o, l);\r\n                                if(catIndex + 1) categoriesValue[catIndex][1].push(value[l][o]);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        // For all other 2d cartesian traces\r\n                        catIndex = cdi.p;\r\n                        if(catIndex === undefined) catIndex = cdi[axLetter];\r\n\r\n                        value = cdi.s;\r\n                        if(value === undefined) value = cdi.v;\r\n                        if(value === undefined) value = isX ? cdi.y : cdi.x;\r\n\r\n                        if(!Array.isArray(value)) {\r\n                            if(value === undefined) value = [];\r\n                            else value = [value];\r\n                        }\r\n                        for(l = 0; l < value.length; l++) {\r\n                            categoriesValue[catIndex][1].push(value[l]);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            ax._categoriesValue = categoriesValue;\r\n\r\n            var categoriesAggregatedValue = [];\r\n            for(j = 0; j < categoriesValue.length; j++) {\r\n                categoriesAggregatedValue.push([\r\n                    categoriesValue[j][0],\r\n                    aggFn[aggregator](categoriesValue[j][1])\r\n                ]);\r\n            }\r\n\r\n            // Sort by aggregated value\r\n            categoriesAggregatedValue.sort(function(a, b) {\r\n                return a[1] - b[1];\r\n            });\r\n\r\n            ax._categoriesAggregatedValue = categoriesAggregatedValue;\r\n\r\n            // Set new category order\r\n            ax._initialCategories = categoriesAggregatedValue.map(function(c) {\r\n                return c[0];\r\n            });\r\n\r\n            // Reverse if descending\r\n            if(order === 'descending') {\r\n                ax._initialCategories.reverse();\r\n            }\r\n\r\n            // Sort all matching axes\r\n            affectedTraces = affectedTraces.concat(ax.sortByInitialCategories());\r\n        }\r\n    }\r\n    return affectedTraces;\r\n}\r\n\r\nfunction setupAxisCategories(axList, fullData, fullLayout) {\r\n    var axLookup = {};\r\n\r\n    function setupOne(ax) {\r\n        ax.clearCalc();\r\n        if(ax.type === 'multicategory') {\r\n            ax.setupMultiCategory(fullData);\r\n        }\r\n\r\n        axLookup[ax._id] = 1;\r\n    }\r\n\r\n    Lib.simpleMap(axList, setupOne);\r\n\r\n    // look into match groups for 'missing' axes\r\n    var matchGroups = fullLayout._axisMatchGroups || [];\r\n    for(var i = 0; i < matchGroups.length; i++) {\r\n        for(var axId in matchGroups[i]) {\r\n            if(!axLookup[axId]) {\r\n                setupOne(fullLayout[axisIDs.id2name(axId)]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction doCrossTraceCalc(gd) {\r\n    var fullLayout = gd._fullLayout;\r\n    var modules = fullLayout._visibleModules;\r\n    var hash = {};\r\n    var i, j, k;\r\n\r\n    // position and range calculations for traces that\r\n    // depend on each other ie bars (stacked or grouped)\r\n    // and boxes (grouped) push each other out of the way\r\n\r\n    for(j = 0; j < modules.length; j++) {\r\n        var _module = modules[j];\r\n        var fn = _module.crossTraceCalc;\r\n        if(fn) {\r\n            var spType = _module.basePlotModule.name;\r\n            if(hash[spType]) {\r\n                Lib.pushUnique(hash[spType], fn);\r\n            } else {\r\n                hash[spType] = [fn];\r\n            }\r\n        }\r\n    }\r\n\r\n    for(k in hash) {\r\n        var methods = hash[k];\r\n        var subplots = fullLayout._subplots[k];\r\n\r\n        if(Array.isArray(subplots)) {\r\n            for(i = 0; i < subplots.length; i++) {\r\n                var sp = subplots[i];\r\n                var spInfo = k === 'cartesian' ?\r\n                    fullLayout._plots[sp] :\r\n                    fullLayout[sp];\r\n\r\n                for(j = 0; j < methods.length; j++) {\r\n                    methods[j](gd, spInfo, sp);\r\n                }\r\n            }\r\n        } else {\r\n            for(j = 0; j < methods.length; j++) {\r\n                methods[j](gd);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nplots.rehover = function(gd) {\r\n    if(gd._fullLayout._rehover) {\r\n        gd._fullLayout._rehover();\r\n    }\r\n};\r\n\r\nplots.redrag = function(gd) {\r\n    if(gd._fullLayout._redrag) {\r\n        gd._fullLayout._redrag();\r\n    }\r\n};\r\n\r\nplots.generalUpdatePerTraceModule = function(gd, subplot, subplotCalcData, subplotLayout) {\r\n    var traceHashOld = subplot.traceHash;\r\n    var traceHash = {};\r\n    var i;\r\n\r\n    // build up moduleName -> calcData hash\r\n    for(i = 0; i < subplotCalcData.length; i++) {\r\n        var calcTraces = subplotCalcData[i];\r\n        var trace = calcTraces[0].trace;\r\n\r\n        // skip over visible === false traces\r\n        // as they don't have `_module` ref\r\n        if(trace.visible) {\r\n            traceHash[trace.type] = traceHash[trace.type] || [];\r\n            traceHash[trace.type].push(calcTraces);\r\n        }\r\n    }\r\n\r\n    // when a trace gets deleted, make sure that its module's\r\n    // plot method is called so that it is properly\r\n    // removed from the DOM.\r\n    for(var moduleNameOld in traceHashOld) {\r\n        if(!traceHash[moduleNameOld]) {\r\n            var fakeCalcTrace = traceHashOld[moduleNameOld][0];\r\n            var fakeTrace = fakeCalcTrace[0].trace;\r\n\r\n            fakeTrace.visible = false;\r\n            traceHash[moduleNameOld] = [fakeCalcTrace];\r\n        }\r\n    }\r\n\r\n    // call module plot method\r\n    for(var moduleName in traceHash) {\r\n        var moduleCalcData = traceHash[moduleName];\r\n        var _module = moduleCalcData[0][0].trace._module;\r\n\r\n        _module.plot(gd, subplot, Lib.filterVisible(moduleCalcData), subplotLayout);\r\n    }\r\n\r\n    // update moduleName -> calcData hash\r\n    subplot.traceHash = traceHash;\r\n};\r\n\r\nplots.plotBasePlot = function(desiredType, gd, traces, transitionOpts, makeOnCompleteCallback) {\r\n    var _module = Registry.getModule(desiredType);\r\n    var cdmodule = getModuleCalcData(gd.calcdata, _module)[0];\r\n    _module.plot(gd, cdmodule, transitionOpts, makeOnCompleteCallback);\r\n};\r\n\r\nplots.cleanBasePlot = function(desiredType, newFullData, newFullLayout, oldFullData, oldFullLayout) {\r\n    var had = (oldFullLayout._has && oldFullLayout._has(desiredType));\r\n    var has = (newFullLayout._has && newFullLayout._has(desiredType));\r\n\r\n    if(had && !has) {\r\n        oldFullLayout['_' + desiredType + 'layer'].selectAll('g.trace').remove();\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}
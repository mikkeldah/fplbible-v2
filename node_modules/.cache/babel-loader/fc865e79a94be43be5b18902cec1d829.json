{"ast":null,"code":"var tarjan = require('strongly-connected-components');\n\nmodule.exports = function findCircuits(edges, cb) {\n  var circuits = []; // Output\n\n  var stack = [];\n  var blocked = [];\n  var B = {};\n  var Ak = [];\n  var s;\n\n  function unblock(u) {\n    blocked[u] = false;\n\n    if (B.hasOwnProperty(u)) {\n      Object.keys(B[u]).forEach(function (w) {\n        delete B[u][w];\n\n        if (blocked[w]) {\n          unblock(w);\n        }\n      });\n    }\n  }\n\n  function circuit(v) {\n    var found = false;\n    stack.push(v);\n    blocked[v] = true; // L1\n\n    var i;\n    var w;\n\n    for (i = 0; i < Ak[v].length; i++) {\n      w = Ak[v][i];\n\n      if (w === s) {\n        output(s, stack);\n        found = true;\n      } else if (!blocked[w]) {\n        found = circuit(w);\n      }\n    } // L2\n\n\n    if (found) {\n      unblock(v);\n    } else {\n      for (i = 0; i < Ak[v].length; i++) {\n        w = Ak[v][i];\n        var entry = B[w];\n\n        if (!entry) {\n          entry = {};\n          B[w] = entry;\n        }\n\n        entry[w] = true;\n      }\n    }\n\n    stack.pop();\n    return found;\n  }\n\n  function output(start, stack) {\n    var cycle = [].concat(stack).concat(start);\n\n    if (cb) {\n      cb(cycle);\n    } else {\n      circuits.push(cycle);\n    }\n  }\n\n  function subgraph(minId) {\n    // Remove edges with indice smaller than minId\n    for (var i = 0; i < edges.length; i++) {\n      if (i < minId || !edges[i]) edges[i] = [];\n      edges[i] = edges[i].filter(function (i) {\n        return i >= minId;\n      });\n    }\n  }\n\n  function adjacencyStructureSCC(from) {\n    // Make subgraph starting from vertex minId\n    subgraph(from);\n    var g = edges; // Find strongly connected components using Tarjan algorithm\n\n    var sccs = tarjan(g); // Filter out trivial connected components (ie. made of one node)\n\n    var ccs = sccs.components.filter(function (scc) {\n      return scc.length > 1;\n    }); // Find least vertex\n\n    var leastVertex = Infinity;\n    var leastVertexComponent;\n\n    for (var i = 0; i < ccs.length; i++) {\n      for (var j = 0; j < ccs[i].length; j++) {\n        if (ccs[i][j] < leastVertex) {\n          leastVertex = ccs[i][j];\n          leastVertexComponent = i;\n        }\n      }\n    }\n\n    var cc = ccs[leastVertexComponent];\n    if (!cc) return false; // Return the adjacency list of first component\n\n    var adjList = edges.map(function (l, index) {\n      if (cc.indexOf(index) === -1) return [];\n      return l.filter(function (i) {\n        return cc.indexOf(i) !== -1;\n      });\n    });\n    return {\n      leastVertex: leastVertex,\n      adjList: adjList\n    };\n  }\n\n  s = 0;\n  var n = edges.length;\n\n  while (s < n) {\n    // find strong component with least vertex in\n    // subgraph starting from vertex `s`\n    var p = adjacencyStructureSCC(s); // Its least vertex\n\n    s = p.leastVertex; // Its adjacency list\n\n    Ak = p.adjList;\n\n    if (Ak) {\n      for (var i = 0; i < Ak.length; i++) {\n        for (var j = 0; j < Ak[i].length; j++) {\n          var vertexId = Ak[i][j];\n          blocked[+vertexId] = false;\n          B[vertexId] = {};\n        }\n      }\n\n      circuit(s);\n      s = s + 1;\n    } else {\n      s = n;\n    }\n  }\n\n  if (cb) {\n    return;\n  } else {\n    return circuits;\n  }\n};","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/elementary-circuits-directed-graph/johnson.js"],"names":["tarjan","require","module","exports","findCircuits","edges","cb","circuits","stack","blocked","B","Ak","s","unblock","u","hasOwnProperty","Object","keys","forEach","w","circuit","v","found","push","i","length","output","entry","pop","start","cycle","concat","subgraph","minId","filter","adjacencyStructureSCC","from","g","sccs","ccs","components","scc","leastVertex","Infinity","leastVertexComponent","j","cc","adjList","map","l","index","indexOf","n","p","vertexId"],"mappings":"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","sourcesContent":["var tarjan = require('strongly-connected-components');\r\n\r\nmodule.exports = function findCircuits(edges, cb) {\r\n    var circuits = []; // Output\r\n\r\n    var stack = [];\r\n    var blocked = [];\r\n    var B = {};\r\n    var Ak = [];\r\n    var s;\r\n\r\n    function unblock(u) {\r\n        blocked[u] = false;\r\n        if(B.hasOwnProperty(u)) {\r\n            Object.keys(B[u]).forEach(function(w) {\r\n                delete B[u][w];\r\n                if(blocked[w]) {unblock(w);}\r\n            });\r\n        }\r\n    }\r\n\r\n    function circuit(v) {\r\n        var found = false;\r\n\r\n        stack.push(v);\r\n        blocked[v] = true;\r\n\r\n        // L1\r\n        var i;\r\n        var w;\r\n        for(i = 0; i < Ak[v].length; i++) {\r\n            w = Ak[v][i];\r\n            if(w === s) {\r\n                output(s, stack);\r\n                found = true;\r\n            } else if(!blocked[w]) {\r\n                found = circuit(w);\r\n            }\r\n        }\r\n\r\n        // L2\r\n        if(found) {\r\n            unblock(v);\r\n        } else {\r\n            for(i = 0; i < Ak[v].length; i++) {\r\n                w = Ak[v][i];\r\n                var entry = B[w];\r\n\r\n                if(!entry) {\r\n                    entry = {};\r\n                    B[w] = entry;\r\n                }\r\n\r\n                entry[w] = true;\r\n            }\r\n        }\r\n        stack.pop();\r\n        return found;\r\n    }\r\n\r\n    function output(start, stack) {\r\n        var cycle = [].concat(stack).concat(start);\r\n        if(cb) {\r\n            cb(cycle);\r\n        } else {\r\n            circuits.push(cycle);\r\n        }\r\n    }\r\n\r\n    function subgraph(minId) {\r\n      // Remove edges with indice smaller than minId\r\n        for(var i = 0; i < edges.length; i++) {\r\n            if(i < minId || !edges[i]) edges[i] = [];\r\n            edges[i] = edges[i].filter(function(i) {\r\n                return i >= minId;\r\n            });\r\n        }\r\n    }\r\n\r\n    function adjacencyStructureSCC(from) {\r\n        // Make subgraph starting from vertex minId\r\n        subgraph(from);\r\n        var g = edges;\r\n\r\n        // Find strongly connected components using Tarjan algorithm\r\n        var sccs = tarjan(g);\r\n\r\n        // Filter out trivial connected components (ie. made of one node)\r\n        var ccs = sccs.components.filter(function(scc) {\r\n            return scc.length > 1;\r\n        });\r\n\r\n        // Find least vertex\r\n        var leastVertex = Infinity;\r\n        var leastVertexComponent;\r\n        for(var i = 0; i < ccs.length; i++) {\r\n            for(var j = 0; j < ccs[i].length; j++) {\r\n                if(ccs[i][j] < leastVertex) {\r\n                    leastVertex = ccs[i][j];\r\n                    leastVertexComponent = i;\r\n                }\r\n            }\r\n        }\r\n\r\n        var cc = ccs[leastVertexComponent];\r\n\r\n        if(!cc) return false;\r\n\r\n        // Return the adjacency list of first component\r\n        var adjList = edges.map(function(l, index) {\r\n            if(cc.indexOf(index) === -1) return [];\r\n            return l.filter(function(i) {\r\n                return cc.indexOf(i) !== -1;\r\n            });\r\n        });\r\n\r\n        return {\r\n            leastVertex: leastVertex,\r\n            adjList: adjList\r\n        };\r\n    }\r\n\r\n    s = 0;\r\n    var n = edges.length;\r\n    while(s < n) {\r\n        // find strong component with least vertex in\r\n        // subgraph starting from vertex `s`\r\n        var p = adjacencyStructureSCC(s);\r\n\r\n        // Its least vertex\r\n        s = p.leastVertex;\r\n        // Its adjacency list\r\n        Ak = p.adjList;\r\n\r\n        if(Ak) {\r\n            for(var i = 0; i < Ak.length; i++) {\r\n                for(var j = 0; j < Ak[i].length; j++) {\r\n                    var vertexId = Ak[i][j];\r\n                    blocked[+vertexId] = false;\r\n                    B[vertexId] = {};\r\n                }\r\n            }\r\n            circuit(s);\r\n            s = s + 1;\r\n        } else {\r\n            s = n;\r\n        }\r\n\r\n    }\r\n\r\n    if(cb) {\r\n        return;\r\n    } else {\r\n        return circuits;\r\n    }\r\n};\r\n"]},"metadata":{},"sourceType":"script"}
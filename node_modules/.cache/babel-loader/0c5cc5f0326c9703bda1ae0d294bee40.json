{"ast":null,"code":"'use strict';\n\nvar Registry = require('../../registry');\n\nvar helpers = require('./helpers');\n\nmodule.exports = function getLegendData(calcdata, opts) {\n  var grouped = helpers.isGrouped(opts);\n  var reversed = helpers.isReversed(opts);\n  var lgroupToTraces = {};\n  var lgroups = [];\n  var hasOneNonBlankGroup = false;\n  var slicesShown = {};\n  var lgroupi = 0;\n  var maxNameLength = 0;\n  var i, j;\n\n  function addOneItem(legendGroup, legendItem) {\n    // each '' legend group is treated as a separate group\n    if (legendGroup === '' || !helpers.isGrouped(opts)) {\n      // TODO: check this against fullData legendgroups?\n      var uniqueGroup = '~~i' + lgroupi;\n      lgroups.push(uniqueGroup);\n      lgroupToTraces[uniqueGroup] = [legendItem];\n      lgroupi++;\n    } else if (lgroups.indexOf(legendGroup) === -1) {\n      lgroups.push(legendGroup);\n      hasOneNonBlankGroup = true;\n      lgroupToTraces[legendGroup] = [legendItem];\n    } else {\n      lgroupToTraces[legendGroup].push(legendItem);\n    }\n  } // build an { legendgroup: [cd0, cd0], ... } object\n\n\n  for (i = 0; i < calcdata.length; i++) {\n    var cd = calcdata[i];\n    var cd0 = cd[0];\n    var trace = cd0.trace;\n    var lgroup = trace.legendgroup;\n    if (!opts._inHover && (!trace.visible || !trace.showlegend)) continue;\n\n    if (Registry.traceIs(trace, 'pie-like')) {\n      if (!slicesShown[lgroup]) slicesShown[lgroup] = {};\n\n      for (j = 0; j < cd.length; j++) {\n        var labelj = cd[j].label;\n\n        if (!slicesShown[lgroup][labelj]) {\n          addOneItem(lgroup, {\n            label: labelj,\n            color: cd[j].color,\n            i: cd[j].i,\n            trace: trace,\n            pts: cd[j].pts\n          });\n          slicesShown[lgroup][labelj] = true;\n          maxNameLength = Math.max(maxNameLength, (labelj || '').length);\n        }\n      }\n    } else {\n      addOneItem(lgroup, cd0);\n      maxNameLength = Math.max(maxNameLength, (trace.name || '').length);\n    }\n  } // won't draw a legend in this case\n\n\n  if (!lgroups.length) return []; // collapse all groups into one if all groups are blank\n\n  var shouldCollapse = !hasOneNonBlankGroup || !grouped;\n  var legendData = [];\n\n  for (i = 0; i < lgroups.length; i++) {\n    var t = lgroupToTraces[lgroups[i]];\n\n    if (shouldCollapse) {\n      legendData.push(t[0]);\n    } else {\n      legendData.push(t);\n    }\n  }\n\n  if (shouldCollapse) legendData = [legendData];\n\n  for (i = 0; i < legendData.length; i++) {\n    // find minimum rank within group\n    var groupMinRank = Infinity;\n\n    for (j = 0; j < legendData[i].length; j++) {\n      var rank = legendData[i][j].trace.legendrank;\n      if (groupMinRank > rank) groupMinRank = rank;\n    } // record on first group element\n\n\n    legendData[i][0]._groupMinRank = groupMinRank;\n    legendData[i][0]._preGroupSort = i;\n  }\n\n  var orderFn1 = function (a, b) {\n    return a[0]._groupMinRank - b[0]._groupMinRank || a[0]._preGroupSort - b[0]._preGroupSort // fallback for old Chrome < 70 https://bugs.chromium.org/p/v8/issues/detail?id=90\n    ;\n  };\n\n  var orderFn2 = function (a, b) {\n    return a.trace.legendrank - b.trace.legendrank || a._preSort - b._preSort // fallback for old Chrome < 70 https://bugs.chromium.org/p/v8/issues/detail?id=90\n    ;\n  }; // sort considering minimum group legendrank\n\n\n  legendData.forEach(function (a, k) {\n    a[0]._preGroupSort = k;\n  });\n  legendData.sort(orderFn1);\n\n  for (i = 0; i < legendData.length; i++) {\n    // sort considering trace.legendrank and legend.traceorder\n    legendData[i].forEach(function (a, k) {\n      a._preSort = k;\n    });\n    legendData[i].sort(orderFn2);\n    if (reversed) legendData[i].reverse(); // rearrange lgroupToTraces into a d3-friendly array of arrays\n\n    for (j = 0; j < legendData[i].length; j++) {\n      legendData[i][j] = [legendData[i][j]];\n    }\n  } // number of legend groups - needed in legend/draw.js\n\n\n  opts._lgroupsLength = legendData.length; // maximum name/label length - needed in legend/draw.js\n\n  opts._maxNameLength = maxNameLength;\n  return legendData;\n};","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/components/legend/get_legend_data.js"],"names":["Registry","require","helpers","module","exports","getLegendData","calcdata","opts","grouped","isGrouped","reversed","isReversed","lgroupToTraces","lgroups","hasOneNonBlankGroup","slicesShown","lgroupi","maxNameLength","i","j","addOneItem","legendGroup","legendItem","uniqueGroup","push","indexOf","length","cd","cd0","trace","lgroup","legendgroup","_inHover","visible","showlegend","traceIs","labelj","label","color","pts","Math","max","name","shouldCollapse","legendData","t","groupMinRank","Infinity","rank","legendrank","_groupMinRank","_preGroupSort","orderFn1","a","b","orderFn2","_preSort","forEach","k","sort","reverse","_lgroupsLength","_maxNameLength"],"mappings":"AAAA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,gBAAD,CAAtB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,WAAD,CAArB;;AAEAE,MAAM,CAACC,OAAP,GAAiB,SAASC,aAAT,CAAuBC,QAAvB,EAAiCC,IAAjC,EAAuC;AACpD,MAAIC,OAAO,GAAGN,OAAO,CAACO,SAAR,CAAkBF,IAAlB,CAAd;AACA,MAAIG,QAAQ,GAAGR,OAAO,CAACS,UAAR,CAAmBJ,IAAnB,CAAf;AAEA,MAAIK,cAAc,GAAG,EAArB;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,mBAAmB,GAAG,KAA1B;AACA,MAAIC,WAAW,GAAG,EAAlB;AACA,MAAIC,OAAO,GAAG,CAAd;AACA,MAAIC,aAAa,GAAG,CAApB;AACA,MAAIC,CAAJ,EAAOC,CAAP;;AAEA,WAASC,UAAT,CAAoBC,WAApB,EAAiCC,UAAjC,EAA6C;AACzC;AACA,QAAGD,WAAW,KAAK,EAAhB,IAAsB,CAACnB,OAAO,CAACO,SAAR,CAAkBF,IAAlB,CAA1B,EAAmD;AAC/C;AACA,UAAIgB,WAAW,GAAG,QAAQP,OAA1B;AACAH,MAAAA,OAAO,CAACW,IAAR,CAAaD,WAAb;AACAX,MAAAA,cAAc,CAACW,WAAD,CAAd,GAA8B,CAACD,UAAD,CAA9B;AACAN,MAAAA,OAAO;AACV,KAND,MAMO,IAAGH,OAAO,CAACY,OAAR,CAAgBJ,WAAhB,MAAiC,CAAC,CAArC,EAAwC;AAC3CR,MAAAA,OAAO,CAACW,IAAR,CAAaH,WAAb;AACAP,MAAAA,mBAAmB,GAAG,IAAtB;AACAF,MAAAA,cAAc,CAACS,WAAD,CAAd,GAA8B,CAACC,UAAD,CAA9B;AACH,KAJM,MAIA;AACHV,MAAAA,cAAc,CAACS,WAAD,CAAd,CAA4BG,IAA5B,CAAiCF,UAAjC;AACH;AACJ,GA3BmD,CA6BpD;;;AACA,OAAIJ,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGZ,QAAQ,CAACoB,MAAxB,EAAgCR,CAAC,EAAjC,EAAqC;AACjC,QAAIS,EAAE,GAAGrB,QAAQ,CAACY,CAAD,CAAjB;AACA,QAAIU,GAAG,GAAGD,EAAE,CAAC,CAAD,CAAZ;AACA,QAAIE,KAAK,GAAGD,GAAG,CAACC,KAAhB;AACA,QAAIC,MAAM,GAAGD,KAAK,CAACE,WAAnB;AAEA,QAAG,CAACxB,IAAI,CAACyB,QAAN,KAAmB,CAACH,KAAK,CAACI,OAAP,IAAkB,CAACJ,KAAK,CAACK,UAA5C,CAAH,EAA4D;;AAE5D,QAAGlC,QAAQ,CAACmC,OAAT,CAAiBN,KAAjB,EAAwB,UAAxB,CAAH,EAAwC;AACpC,UAAG,CAACd,WAAW,CAACe,MAAD,CAAf,EAAyBf,WAAW,CAACe,MAAD,CAAX,GAAsB,EAAtB;;AAEzB,WAAIX,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGQ,EAAE,CAACD,MAAlB,EAA0BP,CAAC,EAA3B,EAA+B;AAC3B,YAAIiB,MAAM,GAAGT,EAAE,CAACR,CAAD,CAAF,CAAMkB,KAAnB;;AAEA,YAAG,CAACtB,WAAW,CAACe,MAAD,CAAX,CAAoBM,MAApB,CAAJ,EAAiC;AAC7BhB,UAAAA,UAAU,CAACU,MAAD,EAAS;AACfO,YAAAA,KAAK,EAAED,MADQ;AAEfE,YAAAA,KAAK,EAAEX,EAAE,CAACR,CAAD,CAAF,CAAMmB,KAFE;AAGfpB,YAAAA,CAAC,EAAES,EAAE,CAACR,CAAD,CAAF,CAAMD,CAHM;AAIfW,YAAAA,KAAK,EAAEA,KAJQ;AAKfU,YAAAA,GAAG,EAAEZ,EAAE,CAACR,CAAD,CAAF,CAAMoB;AALI,WAAT,CAAV;AAQAxB,UAAAA,WAAW,CAACe,MAAD,CAAX,CAAoBM,MAApB,IAA8B,IAA9B;AACAnB,UAAAA,aAAa,GAAGuB,IAAI,CAACC,GAAL,CAASxB,aAAT,EAAwB,CAACmB,MAAM,IAAI,EAAX,EAAeV,MAAvC,CAAhB;AACH;AACJ;AACJ,KAnBD,MAmBO;AACHN,MAAAA,UAAU,CAACU,MAAD,EAASF,GAAT,CAAV;AACAX,MAAAA,aAAa,GAAGuB,IAAI,CAACC,GAAL,CAASxB,aAAT,EAAwB,CAACY,KAAK,CAACa,IAAN,IAAc,EAAf,EAAmBhB,MAA3C,CAAhB;AACH;AACJ,GA7DmD,CA+DpD;;;AACA,MAAG,CAACb,OAAO,CAACa,MAAZ,EAAoB,OAAO,EAAP,CAhEgC,CAkEpD;;AACA,MAAIiB,cAAc,GAAG,CAAC7B,mBAAD,IAAwB,CAACN,OAA9C;AAEA,MAAIoC,UAAU,GAAG,EAAjB;;AACA,OAAI1B,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGL,OAAO,CAACa,MAAvB,EAA+BR,CAAC,EAAhC,EAAoC;AAChC,QAAI2B,CAAC,GAAGjC,cAAc,CAACC,OAAO,CAACK,CAAD,CAAR,CAAtB;;AACA,QAAGyB,cAAH,EAAmB;AACfC,MAAAA,UAAU,CAACpB,IAAX,CAAgBqB,CAAC,CAAC,CAAD,CAAjB;AACH,KAFD,MAEO;AACHD,MAAAA,UAAU,CAACpB,IAAX,CAAgBqB,CAAhB;AACH;AACJ;;AACD,MAAGF,cAAH,EAAmBC,UAAU,GAAG,CAACA,UAAD,CAAb;;AAEnB,OAAI1B,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG0B,UAAU,CAAClB,MAA1B,EAAkCR,CAAC,EAAnC,EAAuC;AACnC;AACA,QAAI4B,YAAY,GAAGC,QAAnB;;AACA,SAAI5B,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGyB,UAAU,CAAC1B,CAAD,CAAV,CAAcQ,MAA7B,EAAqCP,CAAC,EAAtC,EAA0C;AACtC,UAAI6B,IAAI,GAAGJ,UAAU,CAAC1B,CAAD,CAAV,CAAcC,CAAd,EAAiBU,KAAjB,CAAuBoB,UAAlC;AACA,UAAGH,YAAY,GAAGE,IAAlB,EAAwBF,YAAY,GAAGE,IAAf;AAC3B,KANkC,CAQnC;;;AACAJ,IAAAA,UAAU,CAAC1B,CAAD,CAAV,CAAc,CAAd,EAAiBgC,aAAjB,GAAiCJ,YAAjC;AACAF,IAAAA,UAAU,CAAC1B,CAAD,CAAV,CAAc,CAAd,EAAiBiC,aAAjB,GAAiCjC,CAAjC;AACH;;AAED,MAAIkC,QAAQ,GAAG,UAASC,CAAT,EAAYC,CAAZ,EAAe;AAC1B,WACKD,CAAC,CAAC,CAAD,CAAD,CAAKH,aAAL,GAAqBI,CAAC,CAAC,CAAD,CAAD,CAAKJ,aAA3B,IACCG,CAAC,CAAC,CAAD,CAAD,CAAKF,aAAL,GAAqBG,CAAC,CAAC,CAAD,CAAD,CAAKH,aAF/B,CAE8C;AAF9C;AAIH,GALD;;AAOA,MAAII,QAAQ,GAAG,UAASF,CAAT,EAAYC,CAAZ,EAAe;AAC1B,WACKD,CAAC,CAACxB,KAAF,CAAQoB,UAAR,GAAqBK,CAAC,CAACzB,KAAF,CAAQoB,UAA9B,IACCI,CAAC,CAACG,QAAF,GAAaF,CAAC,CAACE,QAFpB,CAE8B;AAF9B;AAIH,GALD,CApGoD,CA2GpD;;;AACAZ,EAAAA,UAAU,CAACa,OAAX,CAAmB,UAASJ,CAAT,EAAYK,CAAZ,EAAe;AAAEL,IAAAA,CAAC,CAAC,CAAD,CAAD,CAAKF,aAAL,GAAqBO,CAArB;AAAyB,GAA7D;AACAd,EAAAA,UAAU,CAACe,IAAX,CAAgBP,QAAhB;;AACA,OAAIlC,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAG0B,UAAU,CAAClB,MAA1B,EAAkCR,CAAC,EAAnC,EAAuC;AACnC;AACA0B,IAAAA,UAAU,CAAC1B,CAAD,CAAV,CAAcuC,OAAd,CAAsB,UAASJ,CAAT,EAAYK,CAAZ,EAAe;AAAEL,MAAAA,CAAC,CAACG,QAAF,GAAaE,CAAb;AAAiB,KAAxD;AACAd,IAAAA,UAAU,CAAC1B,CAAD,CAAV,CAAcyC,IAAd,CAAmBJ,QAAnB;AACA,QAAG7C,QAAH,EAAakC,UAAU,CAAC1B,CAAD,CAAV,CAAc0C,OAAd,GAJsB,CAMnC;;AACA,SAAIzC,CAAC,GAAG,CAAR,EAAWA,CAAC,GAAGyB,UAAU,CAAC1B,CAAD,CAAV,CAAcQ,MAA7B,EAAqCP,CAAC,EAAtC,EAA0C;AACtCyB,MAAAA,UAAU,CAAC1B,CAAD,CAAV,CAAcC,CAAd,IAAmB,CACfyB,UAAU,CAAC1B,CAAD,CAAV,CAAcC,CAAd,CADe,CAAnB;AAGH;AACJ,GA1HmD,CA4HpD;;;AACAZ,EAAAA,IAAI,CAACsD,cAAL,GAAsBjB,UAAU,CAAClB,MAAjC,CA7HoD,CA8HpD;;AACAnB,EAAAA,IAAI,CAACuD,cAAL,GAAsB7C,aAAtB;AAEA,SAAO2B,UAAP;AACH,CAlID","sourcesContent":["'use strict';\r\n\r\nvar Registry = require('../../registry');\r\nvar helpers = require('./helpers');\r\n\r\nmodule.exports = function getLegendData(calcdata, opts) {\r\n    var grouped = helpers.isGrouped(opts);\r\n    var reversed = helpers.isReversed(opts);\r\n\r\n    var lgroupToTraces = {};\r\n    var lgroups = [];\r\n    var hasOneNonBlankGroup = false;\r\n    var slicesShown = {};\r\n    var lgroupi = 0;\r\n    var maxNameLength = 0;\r\n    var i, j;\r\n\r\n    function addOneItem(legendGroup, legendItem) {\r\n        // each '' legend group is treated as a separate group\r\n        if(legendGroup === '' || !helpers.isGrouped(opts)) {\r\n            // TODO: check this against fullData legendgroups?\r\n            var uniqueGroup = '~~i' + lgroupi;\r\n            lgroups.push(uniqueGroup);\r\n            lgroupToTraces[uniqueGroup] = [legendItem];\r\n            lgroupi++;\r\n        } else if(lgroups.indexOf(legendGroup) === -1) {\r\n            lgroups.push(legendGroup);\r\n            hasOneNonBlankGroup = true;\r\n            lgroupToTraces[legendGroup] = [legendItem];\r\n        } else {\r\n            lgroupToTraces[legendGroup].push(legendItem);\r\n        }\r\n    }\r\n\r\n    // build an { legendgroup: [cd0, cd0], ... } object\r\n    for(i = 0; i < calcdata.length; i++) {\r\n        var cd = calcdata[i];\r\n        var cd0 = cd[0];\r\n        var trace = cd0.trace;\r\n        var lgroup = trace.legendgroup;\r\n\r\n        if(!opts._inHover && (!trace.visible || !trace.showlegend)) continue;\r\n\r\n        if(Registry.traceIs(trace, 'pie-like')) {\r\n            if(!slicesShown[lgroup]) slicesShown[lgroup] = {};\r\n\r\n            for(j = 0; j < cd.length; j++) {\r\n                var labelj = cd[j].label;\r\n\r\n                if(!slicesShown[lgroup][labelj]) {\r\n                    addOneItem(lgroup, {\r\n                        label: labelj,\r\n                        color: cd[j].color,\r\n                        i: cd[j].i,\r\n                        trace: trace,\r\n                        pts: cd[j].pts\r\n                    });\r\n\r\n                    slicesShown[lgroup][labelj] = true;\r\n                    maxNameLength = Math.max(maxNameLength, (labelj || '').length);\r\n                }\r\n            }\r\n        } else {\r\n            addOneItem(lgroup, cd0);\r\n            maxNameLength = Math.max(maxNameLength, (trace.name || '').length);\r\n        }\r\n    }\r\n\r\n    // won't draw a legend in this case\r\n    if(!lgroups.length) return [];\r\n\r\n    // collapse all groups into one if all groups are blank\r\n    var shouldCollapse = !hasOneNonBlankGroup || !grouped;\r\n\r\n    var legendData = [];\r\n    for(i = 0; i < lgroups.length; i++) {\r\n        var t = lgroupToTraces[lgroups[i]];\r\n        if(shouldCollapse) {\r\n            legendData.push(t[0]);\r\n        } else {\r\n            legendData.push(t);\r\n        }\r\n    }\r\n    if(shouldCollapse) legendData = [legendData];\r\n\r\n    for(i = 0; i < legendData.length; i++) {\r\n        // find minimum rank within group\r\n        var groupMinRank = Infinity;\r\n        for(j = 0; j < legendData[i].length; j++) {\r\n            var rank = legendData[i][j].trace.legendrank;\r\n            if(groupMinRank > rank) groupMinRank = rank;\r\n        }\r\n\r\n        // record on first group element\r\n        legendData[i][0]._groupMinRank = groupMinRank;\r\n        legendData[i][0]._preGroupSort = i;\r\n    }\r\n\r\n    var orderFn1 = function(a, b) {\r\n        return (\r\n            (a[0]._groupMinRank - b[0]._groupMinRank) ||\r\n            (a[0]._preGroupSort - b[0]._preGroupSort) // fallback for old Chrome < 70 https://bugs.chromium.org/p/v8/issues/detail?id=90\r\n        );\r\n    };\r\n\r\n    var orderFn2 = function(a, b) {\r\n        return (\r\n            (a.trace.legendrank - b.trace.legendrank) ||\r\n            (a._preSort - b._preSort) // fallback for old Chrome < 70 https://bugs.chromium.org/p/v8/issues/detail?id=90\r\n        );\r\n    };\r\n\r\n    // sort considering minimum group legendrank\r\n    legendData.forEach(function(a, k) { a[0]._preGroupSort = k; });\r\n    legendData.sort(orderFn1);\r\n    for(i = 0; i < legendData.length; i++) {\r\n        // sort considering trace.legendrank and legend.traceorder\r\n        legendData[i].forEach(function(a, k) { a._preSort = k; });\r\n        legendData[i].sort(orderFn2);\r\n        if(reversed) legendData[i].reverse();\r\n\r\n        // rearrange lgroupToTraces into a d3-friendly array of arrays\r\n        for(j = 0; j < legendData[i].length; j++) {\r\n            legendData[i][j] = [\r\n                legendData[i][j]\r\n            ];\r\n        }\r\n    }\r\n\r\n    // number of legend groups - needed in legend/draw.js\r\n    opts._lgroupsLength = legendData.length;\r\n    // maximum name/label length - needed in legend/draw.js\r\n    opts._maxNameLength = maxNameLength;\r\n\r\n    return legendData;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}
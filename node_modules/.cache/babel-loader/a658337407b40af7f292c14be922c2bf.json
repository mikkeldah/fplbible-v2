{"ast":null,"code":"// (c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc\n// MIT License\n// Project Home: https://github.com/voidqk/polybooljs\n//\n// convert between PolyBool polygon format and GeoJSON formats (Polygon and MultiPolygon)\n//\nvar GeoJSON = {\n  // convert a GeoJSON object to a PolyBool polygon\n  toPolygon: function (PolyBool, geojson) {\n    // converts list of LineString's to segments\n    function GeoPoly(coords) {\n      // check for empty coords\n      if (coords.length <= 0) return PolyBool.segments({\n        inverted: false,\n        regions: []\n      }); // convert LineString to segments\n\n      function LineString(ls) {\n        // remove tail which should be the same as head\n        var reg = ls.slice(0, ls.length - 1);\n        return PolyBool.segments({\n          inverted: false,\n          regions: [reg]\n        });\n      } // the first LineString is considered the outside\n\n\n      var out = LineString(coords[0]); // the rest of the LineStrings are considered interior holes, so subtract them from the\n      // current result\n\n      for (var i = 1; i < coords.length; i++) out = PolyBool.selectDifference(PolyBool.combine(out, LineString(coords[i])));\n\n      return out;\n    }\n\n    if (geojson.type === 'Polygon') {\n      // single polygon, so just convert it and we're done\n      return PolyBool.polygon(GeoPoly(geojson.coordinates));\n    } else if (geojson.type === 'MultiPolygon') {\n      // multiple polygons, so union all the polygons together\n      var out = PolyBool.segments({\n        inverted: false,\n        regions: []\n      });\n\n      for (var i = 0; i < geojson.coordinates.length; i++) out = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));\n\n      return PolyBool.polygon(out);\n    }\n\n    throw new Error('PolyBool: Cannot convert GeoJSON object to PolyBool polygon');\n  },\n  // convert a PolyBool polygon to a GeoJSON object\n  fromPolygon: function (PolyBool, eps, poly) {\n    // make sure out polygon is clean\n    poly = PolyBool.polygon(PolyBool.segments(poly)); // test if r1 is inside r2\n\n    function regionInsideRegion(r1, r2) {\n      // we're guaranteed no lines intersect (because the polygon is clean), but a vertex\n      // could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the\n      // edge of the first line, which cannot be on an edge\n      return eps.pointInsideRegion([(r1[0][0] + r1[1][0]) * 0.5, (r1[0][1] + r1[1][1]) * 0.5], r2);\n    } // calculate inside heirarchy\n    //\n    //  _____________________   _______    roots -> A       -> F\n    // |          A          | |   F   |            |          |\n    // |  _______   _______  | |  ___  |            +-- B      +-- G\n    // | |   B   | |   C   | | | |   | |            |   |\n    // | |  ___  | |  ___  | | | |   | |            |   +-- D\n    // | | | D | | | | E | | | | | G | |            |\n    // | | |___| | | |___| | | | |   | |            +-- C\n    // | |_______| |_______| | | |___| |                |\n    // |_____________________| |_______|                +-- E\n\n\n    function newNode(region) {\n      return {\n        region: region,\n        children: []\n      };\n    }\n\n    var roots = newNode(null);\n\n    function addChild(root, region) {\n      // first check if we're inside any children\n      for (var i = 0; i < root.children.length; i++) {\n        var child = root.children[i];\n\n        if (regionInsideRegion(region, child.region)) {\n          // we are, so insert inside them instead\n          addChild(child, region);\n          return;\n        }\n      } // not inside any children, so check to see if any children are inside us\n\n\n      var node = newNode(region);\n\n      for (var i = 0; i < root.children.length; i++) {\n        var child = root.children[i];\n\n        if (regionInsideRegion(child.region, region)) {\n          // oops... move the child beneath us, and remove them from root\n          node.children.push(child);\n          root.children.splice(i, 1);\n          i--;\n        }\n      } // now we can add ourselves\n\n\n      root.children.push(node);\n    } // add all regions to the root\n\n\n    for (var i = 0; i < poly.regions.length; i++) {\n      var region = poly.regions[i];\n      if (region.length < 3) // regions must have at least 3 points (sanity check)\n        continue;\n      addChild(roots, region);\n    } // with our heirarchy, we can distinguish between exterior borders, and interior holes\n    // the root nodes are exterior, children are interior, children's children are exterior,\n    // children's children's children are interior, etc\n    // while we're at it, exteriors are counter-clockwise, and interiors are clockwise\n\n\n    function forceWinding(region, clockwise) {\n      // first, see if we're clockwise or counter-clockwise\n      // https://en.wikipedia.org/wiki/Shoelace_formula\n      var winding = 0;\n      var last_x = region[region.length - 1][0];\n      var last_y = region[region.length - 1][1];\n      var copy = [];\n\n      for (var i = 0; i < region.length; i++) {\n        var curr_x = region[i][0];\n        var curr_y = region[i][1];\n        copy.push([curr_x, curr_y]); // create a copy while we're at it\n\n        winding += curr_y * last_x - curr_x * last_y;\n        last_x = curr_x;\n        last_y = curr_y;\n      } // this assumes Cartesian coordinates (Y is positive going up)\n\n\n      var isclockwise = winding < 0;\n      if (isclockwise !== clockwise) copy.reverse(); // while we're here, the last point must be the first point...\n\n      copy.push([copy[0][0], copy[0][1]]);\n      return copy;\n    }\n\n    var geopolys = [];\n\n    function addExterior(node) {\n      var poly = [forceWinding(node.region, false)];\n      geopolys.push(poly); // children of exteriors are interior\n\n      for (var i = 0; i < node.children.length; i++) poly.push(getInterior(node.children[i]));\n    }\n\n    function getInterior(node) {\n      // children of interiors are exterior\n      for (var i = 0; i < node.children.length; i++) addExterior(node.children[i]); // return the clockwise interior\n\n\n      return forceWinding(node.region, true);\n    } // root nodes are exterior\n\n\n    for (var i = 0; i < roots.children.length; i++) addExterior(roots.children[i]); // lastly, construct the approrpriate GeoJSON object\n\n\n    if (geopolys.length <= 0) // empty GeoJSON Polygon\n      return {\n        type: 'Polygon',\n        coordinates: []\n      };\n    if (geopolys.length == 1) // use a GeoJSON Polygon\n      return {\n        type: 'Polygon',\n        coordinates: geopolys[0]\n      };\n    return {\n      // otherwise, use a GeoJSON MultiPolygon\n      type: 'MultiPolygon',\n      coordinates: geopolys\n    };\n  }\n};\nmodule.exports = GeoJSON;","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/polybooljs/lib/geojson.js"],"names":["GeoJSON","toPolygon","PolyBool","geojson","GeoPoly","coords","length","segments","inverted","regions","LineString","ls","reg","slice","out","i","selectDifference","combine","type","polygon","coordinates","selectUnion","Error","fromPolygon","eps","poly","regionInsideRegion","r1","r2","pointInsideRegion","newNode","region","children","roots","addChild","root","child","node","push","splice","forceWinding","clockwise","winding","last_x","last_y","copy","curr_x","curr_y","isclockwise","reverse","geopolys","addExterior","getInterior","module","exports"],"mappings":"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","sourcesContent":["// (c) Copyright 2017, Sean Connelly (@voidqk), http://syntheti.cc\r\n// MIT License\r\n// Project Home: https://github.com/voidqk/polybooljs\r\n\r\n//\r\n// convert between PolyBool polygon format and GeoJSON formats (Polygon and MultiPolygon)\r\n//\r\n\r\nvar GeoJSON = {\r\n\t// convert a GeoJSON object to a PolyBool polygon\r\n\ttoPolygon: function(PolyBool, geojson){\r\n\r\n\t\t// converts list of LineString's to segments\r\n\t\tfunction GeoPoly(coords){\r\n\t\t\t// check for empty coords\r\n\t\t\tif (coords.length <= 0)\r\n\t\t\t\treturn PolyBool.segments({ inverted: false, regions: [] });\r\n\r\n\t\t\t// convert LineString to segments\r\n\t\t\tfunction LineString(ls){\r\n\t\t\t\t// remove tail which should be the same as head\r\n\t\t\t\tvar reg = ls.slice(0, ls.length - 1);\r\n\t\t\t\treturn PolyBool.segments({ inverted: false, regions: [reg] });\r\n\t\t\t}\r\n\r\n\t\t\t// the first LineString is considered the outside\r\n\t\t\tvar out = LineString(coords[0]);\r\n\r\n\t\t\t// the rest of the LineStrings are considered interior holes, so subtract them from the\r\n\t\t\t// current result\r\n\t\t\tfor (var i = 1; i < coords.length; i++)\r\n\t\t\t\tout = PolyBool.selectDifference(PolyBool.combine(out, LineString(coords[i])));\r\n\r\n\t\t\treturn out;\r\n\t\t}\r\n\r\n\t\tif (geojson.type === 'Polygon'){\r\n\t\t\t// single polygon, so just convert it and we're done\r\n\t\t\treturn PolyBool.polygon(GeoPoly(geojson.coordinates));\r\n\t\t}\r\n\t\telse if (geojson.type === 'MultiPolygon'){\r\n\t\t\t// multiple polygons, so union all the polygons together\r\n\t\t\tvar out = PolyBool.segments({ inverted: false, regions: [] });\r\n\t\t\tfor (var i = 0; i < geojson.coordinates.length; i++)\r\n\t\t\t\tout = PolyBool.selectUnion(PolyBool.combine(out, GeoPoly(geojson.coordinates[i])));\r\n\t\t\treturn PolyBool.polygon(out);\r\n\t\t}\r\n\t\tthrow new Error('PolyBool: Cannot convert GeoJSON object to PolyBool polygon');\r\n\t},\r\n\r\n\t// convert a PolyBool polygon to a GeoJSON object\r\n\tfromPolygon: function(PolyBool, eps, poly){\r\n\t\t// make sure out polygon is clean\r\n\t\tpoly = PolyBool.polygon(PolyBool.segments(poly));\r\n\r\n\t\t// test if r1 is inside r2\r\n\t\tfunction regionInsideRegion(r1, r2){\r\n\t\t\t// we're guaranteed no lines intersect (because the polygon is clean), but a vertex\r\n\t\t\t// could be on the edge -- so we just average pt[0] and pt[1] to produce a point on the\r\n\t\t\t// edge of the first line, which cannot be on an edge\r\n\t\t\treturn eps.pointInsideRegion([\r\n\t\t\t\t(r1[0][0] + r1[1][0]) * 0.5,\r\n\t\t\t\t(r1[0][1] + r1[1][1]) * 0.5\r\n\t\t\t], r2);\r\n\t\t}\r\n\r\n\t\t// calculate inside heirarchy\r\n\t\t//\r\n\t\t//  _____________________   _______    roots -> A       -> F\r\n\t\t// |          A          | |   F   |            |          |\r\n\t\t// |  _______   _______  | |  ___  |            +-- B      +-- G\r\n\t\t// | |   B   | |   C   | | | |   | |            |   |\r\n\t\t// | |  ___  | |  ___  | | | |   | |            |   +-- D\r\n\t\t// | | | D | | | | E | | | | | G | |            |\r\n\t\t// | | |___| | | |___| | | | |   | |            +-- C\r\n\t\t// | |_______| |_______| | | |___| |                |\r\n\t\t// |_____________________| |_______|                +-- E\r\n\r\n\t\tfunction newNode(region){\r\n\t\t\treturn {\r\n\t\t\t\tregion: region,\r\n\t\t\t\tchildren: []\r\n\t\t\t};\r\n\t\t}\r\n\r\n\t\tvar roots = newNode(null);\r\n\r\n\t\tfunction addChild(root, region){\r\n\t\t\t// first check if we're inside any children\r\n\t\t\tfor (var i = 0; i < root.children.length; i++){\r\n\t\t\t\tvar child = root.children[i];\r\n\t\t\t\tif (regionInsideRegion(region, child.region)){\r\n\t\t\t\t\t// we are, so insert inside them instead\r\n\t\t\t\t\taddChild(child, region);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// not inside any children, so check to see if any children are inside us\r\n\t\t\tvar node = newNode(region);\r\n\t\t\tfor (var i = 0; i < root.children.length; i++){\r\n\t\t\t\tvar child = root.children[i];\r\n\t\t\t\tif (regionInsideRegion(child.region, region)){\r\n\t\t\t\t\t// oops... move the child beneath us, and remove them from root\r\n\t\t\t\t\tnode.children.push(child);\r\n\t\t\t\t\troot.children.splice(i, 1);\r\n\t\t\t\t\ti--;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// now we can add ourselves\r\n\t\t\troot.children.push(node);\r\n\t\t}\r\n\r\n\t\t// add all regions to the root\r\n\t\tfor (var i = 0; i < poly.regions.length; i++){\r\n\t\t\tvar region = poly.regions[i];\r\n\t\t\tif (region.length < 3) // regions must have at least 3 points (sanity check)\r\n\t\t\t\tcontinue;\r\n\t\t\taddChild(roots, region);\r\n\t\t}\r\n\r\n\t\t// with our heirarchy, we can distinguish between exterior borders, and interior holes\r\n\t\t// the root nodes are exterior, children are interior, children's children are exterior,\r\n\t\t// children's children's children are interior, etc\r\n\r\n\t\t// while we're at it, exteriors are counter-clockwise, and interiors are clockwise\r\n\r\n\t\tfunction forceWinding(region, clockwise){\r\n\t\t\t// first, see if we're clockwise or counter-clockwise\r\n\t\t\t// https://en.wikipedia.org/wiki/Shoelace_formula\r\n\t\t\tvar winding = 0;\r\n\t\t\tvar last_x = region[region.length - 1][0];\r\n\t\t\tvar last_y = region[region.length - 1][1];\r\n\t\t\tvar copy = [];\r\n\t\t\tfor (var i = 0; i < region.length; i++){\r\n\t\t\t\tvar curr_x = region[i][0];\r\n\t\t\t\tvar curr_y = region[i][1];\r\n\t\t\t\tcopy.push([curr_x, curr_y]); // create a copy while we're at it\r\n\t\t\t\twinding += curr_y * last_x - curr_x * last_y;\r\n\t\t\t\tlast_x = curr_x;\r\n\t\t\t\tlast_y = curr_y;\r\n\t\t\t}\r\n\t\t\t// this assumes Cartesian coordinates (Y is positive going up)\r\n\t\t\tvar isclockwise = winding < 0;\r\n\t\t\tif (isclockwise !== clockwise)\r\n\t\t\t\tcopy.reverse();\r\n\t\t\t// while we're here, the last point must be the first point...\r\n\t\t\tcopy.push([copy[0][0], copy[0][1]]);\r\n\t\t\treturn copy;\r\n\t\t}\r\n\r\n\t\tvar geopolys = [];\r\n\r\n\t\tfunction addExterior(node){\r\n\t\t\tvar poly = [forceWinding(node.region, false)];\r\n\t\t\tgeopolys.push(poly);\r\n\t\t\t// children of exteriors are interior\r\n\t\t\tfor (var i = 0; i < node.children.length; i++)\r\n\t\t\t\tpoly.push(getInterior(node.children[i]));\r\n\t\t}\r\n\r\n\t\tfunction getInterior(node){\r\n\t\t\t// children of interiors are exterior\r\n\t\t\tfor (var i = 0; i < node.children.length; i++)\r\n\t\t\t\taddExterior(node.children[i]);\r\n\t\t\t// return the clockwise interior\r\n\t\t\treturn forceWinding(node.region, true);\r\n\t\t}\r\n\r\n\t\t// root nodes are exterior\r\n\t\tfor (var i = 0; i < roots.children.length; i++)\r\n\t\t\taddExterior(roots.children[i]);\r\n\r\n\t\t// lastly, construct the approrpriate GeoJSON object\r\n\r\n\t\tif (geopolys.length <= 0) // empty GeoJSON Polygon\r\n\t\t\treturn { type: 'Polygon', coordinates: [] };\r\n\t\tif (geopolys.length == 1) // use a GeoJSON Polygon\r\n\t\t\treturn { type: 'Polygon', coordinates: geopolys[0] };\r\n\t\treturn { // otherwise, use a GeoJSON MultiPolygon\r\n\t\t\ttype: 'MultiPolygon',\r\n\t\t\tcoordinates: geopolys\r\n\t\t};\r\n\t}\r\n};\r\n\r\nmodule.exports = GeoJSON;\r\n"]},"metadata":{},"sourceType":"script"}
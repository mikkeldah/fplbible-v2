{"ast":null,"code":"'use strict';\n\nmodule.exports = Sieve;\n\nvar distinctVals = require('../../lib').distinctVals;\n\nvar BADNUM = require('../../constants/numerical').BADNUM;\n/**\r\n * Helper class to sieve data from traces into bins\r\n *\r\n * @class\r\n *\r\n * @param {Array} traces\r\n*   Array of calculated traces\r\n * @param {object} opts\r\n *  - @param {boolean} [sepNegVal]\r\n *      If true, then split data at the same position into a bar\r\n *      for positive values and another for negative values\r\n *  - @param {boolean} [overlapNoMerge]\r\n *     If true, then don't merge overlapping bars into a single bar\r\n */\n\n\nfunction Sieve(traces, opts) {\n  this.traces = traces;\n  this.sepNegVal = opts.sepNegVal;\n  this.overlapNoMerge = opts.overlapNoMerge; // for single-bin histograms - see histogram/calc\n\n  var width1 = Infinity;\n  var positions = [];\n\n  for (var i = 0; i < traces.length; i++) {\n    var trace = traces[i];\n\n    for (var j = 0; j < trace.length; j++) {\n      var bar = trace[j];\n      if (bar.p !== BADNUM) positions.push(bar.p);\n    }\n\n    if (trace[0] && trace[0].width1) {\n      width1 = Math.min(trace[0].width1, width1);\n    }\n  }\n\n  this.positions = positions;\n  var dv = distinctVals(positions);\n  this.distinctPositions = dv.vals;\n  if (dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;else this.minDiff = Math.min(dv.minDiff, width1);\n  var type = (opts.posAxis || {}).type;\n\n  if (type === 'category' || type === 'multicategory') {\n    this.minDiff = 1;\n  }\n\n  this.binWidth = this.minDiff;\n  this.bins = {};\n}\n/**\r\n * Sieve datum\r\n *\r\n * @method\r\n * @param {number} position\r\n * @param {number} value\r\n * @returns {number} Previous bin value\r\n */\n\n\nSieve.prototype.put = function put(position, value) {\n  var label = this.getLabel(position, value);\n  var oldValue = this.bins[label] || 0;\n  this.bins[label] = oldValue + value;\n  return oldValue;\n};\n/**\r\n * Get current bin value for a given datum\r\n *\r\n * @method\r\n * @param {number} position  Position of datum\r\n * @param {number} [value]   Value of datum\r\n *                           (required if this.sepNegVal is true)\r\n * @returns {number} Current bin value\r\n */\n\n\nSieve.prototype.get = function get(position, value) {\n  var label = this.getLabel(position, value);\n  return this.bins[label] || 0;\n};\n/**\r\n * Get bin label for a given datum\r\n *\r\n * @method\r\n * @param {number} position  Position of datum\r\n * @param {number} [value]   Value of datum\r\n *                           (required if this.sepNegVal is true)\r\n * @returns {string} Bin label\r\n * (prefixed with a 'v' if value is negative and this.sepNegVal is\r\n * true; otherwise prefixed with '^')\r\n */\n\n\nSieve.prototype.getLabel = function getLabel(position, value) {\n  var prefix = value < 0 && this.sepNegVal ? 'v' : '^';\n  var label = this.overlapNoMerge ? position : Math.round(position / this.binWidth);\n  return prefix + label;\n};","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/traces/bar/sieve.js"],"names":["module","exports","Sieve","distinctVals","require","BADNUM","traces","opts","sepNegVal","overlapNoMerge","width1","Infinity","positions","i","length","trace","j","bar","p","push","Math","min","dv","distinctPositions","vals","minDiff","type","posAxis","binWidth","bins","prototype","put","position","value","label","getLabel","oldValue","get","prefix","round"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,KAAjB;;AAEA,IAAIC,YAAY,GAAGC,OAAO,CAAC,WAAD,CAAP,CAAqBD,YAAxC;;AACA,IAAIE,MAAM,GAAGD,OAAO,CAAC,2BAAD,CAAP,CAAqCC,MAAlD;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASH,KAAT,CAAeI,MAAf,EAAuBC,IAAvB,EAA6B;AACzB,OAAKD,MAAL,GAAcA,MAAd;AACA,OAAKE,SAAL,GAAiBD,IAAI,CAACC,SAAtB;AACA,OAAKC,cAAL,GAAsBF,IAAI,CAACE,cAA3B,CAHyB,CAKzB;;AACA,MAAIC,MAAM,GAAGC,QAAb;AAEA,MAAIC,SAAS,GAAG,EAAhB;;AACA,OAAI,IAAIC,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGP,MAAM,CAACQ,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACnC,QAAIE,KAAK,GAAGT,MAAM,CAACO,CAAD,CAAlB;;AACA,SAAI,IAAIG,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGD,KAAK,CAACD,MAAzB,EAAiCE,CAAC,EAAlC,EAAsC;AAClC,UAAIC,GAAG,GAAGF,KAAK,CAACC,CAAD,CAAf;AACA,UAAGC,GAAG,CAACC,CAAJ,KAAUb,MAAb,EAAqBO,SAAS,CAACO,IAAV,CAAeF,GAAG,CAACC,CAAnB;AACxB;;AACD,QAAGH,KAAK,CAAC,CAAD,CAAL,IAAYA,KAAK,CAAC,CAAD,CAAL,CAASL,MAAxB,EAAgC;AAC5BA,MAAAA,MAAM,GAAGU,IAAI,CAACC,GAAL,CAASN,KAAK,CAAC,CAAD,CAAL,CAASL,MAAlB,EAA0BA,MAA1B,CAAT;AACH;AACJ;;AACD,OAAKE,SAAL,GAAiBA,SAAjB;AAEA,MAAIU,EAAE,GAAGnB,YAAY,CAACS,SAAD,CAArB;AAEA,OAAKW,iBAAL,GAAyBD,EAAE,CAACE,IAA5B;AACA,MAAGF,EAAE,CAACE,IAAH,CAAQV,MAAR,KAAmB,CAAnB,IAAwBJ,MAAM,KAAKC,QAAtC,EAAgD,KAAKc,OAAL,GAAef,MAAf,CAAhD,KACK,KAAKe,OAAL,GAAeL,IAAI,CAACC,GAAL,CAASC,EAAE,CAACG,OAAZ,EAAqBf,MAArB,CAAf;AAEL,MAAIgB,IAAI,GAAG,CAACnB,IAAI,CAACoB,OAAL,IAAgB,EAAjB,EAAqBD,IAAhC;;AACA,MAAGA,IAAI,KAAK,UAAT,IAAuBA,IAAI,KAAK,eAAnC,EAAoD;AAChD,SAAKD,OAAL,GAAe,CAAf;AACH;;AAED,OAAKG,QAAL,GAAgB,KAAKH,OAArB;AAEA,OAAKI,IAAL,GAAY,EAAZ;AACH;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA3B,KAAK,CAAC4B,SAAN,CAAgBC,GAAhB,GAAsB,SAASA,GAAT,CAAaC,QAAb,EAAuBC,KAAvB,EAA8B;AAChD,MAAIC,KAAK,GAAG,KAAKC,QAAL,CAAcH,QAAd,EAAwBC,KAAxB,CAAZ;AACA,MAAIG,QAAQ,GAAG,KAAKP,IAAL,CAAUK,KAAV,KAAoB,CAAnC;AAEA,OAAKL,IAAL,CAAUK,KAAV,IAAmBE,QAAQ,GAAGH,KAA9B;AAEA,SAAOG,QAAP;AACH,CAPD;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAlC,KAAK,CAAC4B,SAAN,CAAgBO,GAAhB,GAAsB,SAASA,GAAT,CAAaL,QAAb,EAAuBC,KAAvB,EAA8B;AAChD,MAAIC,KAAK,GAAG,KAAKC,QAAL,CAAcH,QAAd,EAAwBC,KAAxB,CAAZ;AACA,SAAO,KAAKJ,IAAL,CAAUK,KAAV,KAAoB,CAA3B;AACH,CAHD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAhC,KAAK,CAAC4B,SAAN,CAAgBK,QAAhB,GAA2B,SAASA,QAAT,CAAkBH,QAAlB,EAA4BC,KAA5B,EAAmC;AAC1D,MAAIK,MAAM,GAAIL,KAAK,GAAG,CAAR,IAAa,KAAKzB,SAAnB,GAAgC,GAAhC,GAAsC,GAAnD;AACA,MAAI0B,KAAK,GAAI,KAAKzB,cAAN,GACRuB,QADQ,GAERZ,IAAI,CAACmB,KAAL,CAAWP,QAAQ,GAAG,KAAKJ,QAA3B,CAFJ;AAGA,SAAOU,MAAM,GAAGJ,KAAhB;AACH,CAND","sourcesContent":["'use strict';\r\n\r\nmodule.exports = Sieve;\r\n\r\nvar distinctVals = require('../../lib').distinctVals;\r\nvar BADNUM = require('../../constants/numerical').BADNUM;\r\n\r\n/**\r\n * Helper class to sieve data from traces into bins\r\n *\r\n * @class\r\n *\r\n * @param {Array} traces\r\n*   Array of calculated traces\r\n * @param {object} opts\r\n *  - @param {boolean} [sepNegVal]\r\n *      If true, then split data at the same position into a bar\r\n *      for positive values and another for negative values\r\n *  - @param {boolean} [overlapNoMerge]\r\n *     If true, then don't merge overlapping bars into a single bar\r\n */\r\nfunction Sieve(traces, opts) {\r\n    this.traces = traces;\r\n    this.sepNegVal = opts.sepNegVal;\r\n    this.overlapNoMerge = opts.overlapNoMerge;\r\n\r\n    // for single-bin histograms - see histogram/calc\r\n    var width1 = Infinity;\r\n\r\n    var positions = [];\r\n    for(var i = 0; i < traces.length; i++) {\r\n        var trace = traces[i];\r\n        for(var j = 0; j < trace.length; j++) {\r\n            var bar = trace[j];\r\n            if(bar.p !== BADNUM) positions.push(bar.p);\r\n        }\r\n        if(trace[0] && trace[0].width1) {\r\n            width1 = Math.min(trace[0].width1, width1);\r\n        }\r\n    }\r\n    this.positions = positions;\r\n\r\n    var dv = distinctVals(positions);\r\n\r\n    this.distinctPositions = dv.vals;\r\n    if(dv.vals.length === 1 && width1 !== Infinity) this.minDiff = width1;\r\n    else this.minDiff = Math.min(dv.minDiff, width1);\r\n\r\n    var type = (opts.posAxis || {}).type;\r\n    if(type === 'category' || type === 'multicategory') {\r\n        this.minDiff = 1;\r\n    }\r\n\r\n    this.binWidth = this.minDiff;\r\n\r\n    this.bins = {};\r\n}\r\n\r\n/**\r\n * Sieve datum\r\n *\r\n * @method\r\n * @param {number} position\r\n * @param {number} value\r\n * @returns {number} Previous bin value\r\n */\r\nSieve.prototype.put = function put(position, value) {\r\n    var label = this.getLabel(position, value);\r\n    var oldValue = this.bins[label] || 0;\r\n\r\n    this.bins[label] = oldValue + value;\r\n\r\n    return oldValue;\r\n};\r\n\r\n/**\r\n * Get current bin value for a given datum\r\n *\r\n * @method\r\n * @param {number} position  Position of datum\r\n * @param {number} [value]   Value of datum\r\n *                           (required if this.sepNegVal is true)\r\n * @returns {number} Current bin value\r\n */\r\nSieve.prototype.get = function get(position, value) {\r\n    var label = this.getLabel(position, value);\r\n    return this.bins[label] || 0;\r\n};\r\n\r\n/**\r\n * Get bin label for a given datum\r\n *\r\n * @method\r\n * @param {number} position  Position of datum\r\n * @param {number} [value]   Value of datum\r\n *                           (required if this.sepNegVal is true)\r\n * @returns {string} Bin label\r\n * (prefixed with a 'v' if value is negative and this.sepNegVal is\r\n * true; otherwise prefixed with '^')\r\n */\r\nSieve.prototype.getLabel = function getLabel(position, value) {\r\n    var prefix = (value < 0 && this.sepNegVal) ? 'v' : '^';\r\n    var label = (this.overlapNoMerge) ?\r\n        position :\r\n        Math.round(position / this.binWidth);\r\n    return prefix + label;\r\n};\r\n"]},"metadata":{},"sourceType":"script"}
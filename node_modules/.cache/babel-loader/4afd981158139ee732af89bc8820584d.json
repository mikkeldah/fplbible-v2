{"ast":null,"code":"'use strict';\n\nvar d3 = require('@plotly/d3');\n\nvar isNumeric = require('fast-isnumeric');\n\nvar hasHover = require('has-hover');\n\nvar Lib = require('../lib');\n\nvar nestedProperty = Lib.nestedProperty;\n\nvar Events = require('../lib/events');\n\nvar Queue = require('../lib/queue');\n\nvar Registry = require('../registry');\n\nvar PlotSchema = require('./plot_schema');\n\nvar Plots = require('../plots/plots');\n\nvar Axes = require('../plots/cartesian/axes');\n\nvar Drawing = require('../components/drawing');\n\nvar Color = require('../components/color');\n\nvar initInteractions = require('../plots/cartesian/graph_interact').initInteractions;\n\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\n\nvar clearSelect = require('../plots/cartesian/select').clearSelect;\n\nvar dfltConfig = require('./plot_config').dfltConfig;\n\nvar manageArrays = require('./manage_arrays');\n\nvar helpers = require('./helpers');\n\nvar subroutines = require('./subroutines');\n\nvar editTypes = require('./edit_types');\n\nvar AX_NAME_PATTERN = require('../plots/cartesian/constants').AX_NAME_PATTERN;\n\nvar numericNameWarningCount = 0;\nvar numericNameWarningCountLimit = 5;\n/**\r\n * Internal plot-creation function\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n * @param {array of objects} data\r\n *      array of traces, containing the data and display information for each trace\r\n * @param {object} layout\r\n *      object describing the overall display of the plot,\r\n *      all the stuff that doesn't pertain to any individual trace\r\n * @param {object} config\r\n *      configuration options (see ./plot_config.js for more info)\r\n *\r\n * OR\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n * @param {object} figure\r\n *      object containing `data`, `layout`, `config`, and `frames` members\r\n *\r\n */\n\nfunction _doPlot(gd, data, layout, config) {\n  var frames;\n  gd = Lib.getGraphDiv(gd); // Events.init is idempotent and bails early if gd has already been init'd\n\n  Events.init(gd);\n\n  if (Lib.isPlainObject(data)) {\n    var obj = data;\n    data = obj.data;\n    layout = obj.layout;\n    config = obj.config;\n    frames = obj.frames;\n  }\n\n  var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);\n  if (okToPlot === false) return Promise.reject(); // if there's no data or layout, and this isn't yet a plotly plot\n  // container, log a warning to help plotly.js users debug\n\n  if (!data && !layout && !Lib.isPlotDiv(gd)) {\n    Lib.warn('Calling _doPlot as if redrawing ' + 'but this container doesn\\'t yet have a plot.', gd);\n  }\n\n  function addFrames() {\n    if (frames) {\n      return exports.addFrames(gd, frames);\n    }\n  } // transfer configuration options to gd until we move over to\n  // a more OO like model\n\n\n  setPlotContext(gd, config);\n  if (!layout) layout = {}; // hook class for plots main container (in case of plotly.js\n  // this won't be #embedded-graph or .js-tab-contents)\n\n  d3.select(gd).classed('js-plotly-plot', true); // off-screen getBoundingClientRect testing space,\n  // in #js-plotly-tester (and stored as Drawing.tester)\n  // so we can share cached text across tabs\n\n  Drawing.makeTester(); // collect promises for any async actions during plotting\n  // any part of the plotting code can push to gd._promises, then\n  // before we move to the next step, we check that they're all\n  // complete, and empty out the promise list again.\n\n  if (!Array.isArray(gd._promises)) gd._promises = [];\n  var graphWasEmpty = (gd.data || []).length === 0 && Array.isArray(data); // if there is already data on the graph, append the new data\n  // if you only want to redraw, pass a non-array for data\n\n  if (Array.isArray(data)) {\n    helpers.cleanData(data);\n    if (graphWasEmpty) gd.data = data;else gd.data.push.apply(gd.data, data); // for routines outside graph_obj that want a clean tab\n    // (rather than appending to an existing one) gd.empty\n    // is used to determine whether to make a new tab\n\n    gd.empty = false;\n  }\n\n  if (!gd.layout || graphWasEmpty) {\n    gd.layout = helpers.cleanLayout(layout);\n  }\n\n  Plots.supplyDefaults(gd);\n  var fullLayout = gd._fullLayout;\n\n  var hasCartesian = fullLayout._has('cartesian'); // so we don't try to re-call _doPlot from inside\n  // legend and colorbar, if margins changed\n\n\n  fullLayout._replotting = true; // make or remake the framework if we need to\n\n  if (graphWasEmpty || fullLayout._shouldCreateBgLayer) {\n    makePlotFramework(gd);\n\n    if (fullLayout._shouldCreateBgLayer) {\n      delete fullLayout._shouldCreateBgLayer;\n    }\n  } // clear gradient and pattern defs on each .plot call, because we know we'll loop through all traces\n\n\n  Drawing.initGradients(gd);\n  Drawing.initPatterns(gd); // save initial show spikes once per graph\n\n  if (graphWasEmpty) Axes.saveShowSpikeInitial(gd); // prepare the data and find the autorange\n  // generate calcdata, if we need to\n  // to force redoing calcdata, just delete it before calling _doPlot\n\n  var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;\n  if (recalc) Plots.doCalcdata(gd); // in case it has changed, attach fullData traces to calcdata\n\n  for (var i = 0; i < gd.calcdata.length; i++) {\n    gd.calcdata[i][0].trace = gd._fullData[i];\n  } // make the figure responsive\n\n\n  if (gd._context.responsive) {\n    if (!gd._responsiveChartHandler) {\n      // Keep a reference to the resize handler to purge it down the road\n      gd._responsiveChartHandler = function () {\n        if (!Lib.isHidden(gd)) Plots.resize(gd);\n      }; // Listen to window resize\n\n\n      window.addEventListener('resize', gd._responsiveChartHandler);\n    }\n  } else {\n    Lib.clearResponsive(gd);\n  }\n  /*\r\n   * start async-friendly code - now we're actually drawing things\r\n   */\n\n\n  var oldMargins = Lib.extendFlat({}, fullLayout._size); // draw framework first so that margin-pushing\n  // components can position themselves correctly\n\n  var drawFrameworkCalls = 0;\n\n  function drawFramework() {\n    var basePlotModules = fullLayout._basePlotModules;\n\n    for (var i = 0; i < basePlotModules.length; i++) {\n      if (basePlotModules[i].drawFramework) {\n        basePlotModules[i].drawFramework(gd);\n      }\n    }\n\n    if (!fullLayout._glcanvas && fullLayout._has('gl')) {\n      fullLayout._glcanvas = fullLayout._glcontainer.selectAll('.gl-canvas').data([{\n        key: 'contextLayer',\n        context: true,\n        pick: false\n      }, {\n        key: 'focusLayer',\n        context: false,\n        pick: false\n      }, {\n        key: 'pickLayer',\n        context: false,\n        pick: true\n      }], function (d) {\n        return d.key;\n      });\n\n      fullLayout._glcanvas.enter().append('canvas').attr('class', function (d) {\n        return 'gl-canvas gl-canvas-' + d.key.replace('Layer', '');\n      }).style({\n        position: 'absolute',\n        top: 0,\n        left: 0,\n        overflow: 'visible',\n        'pointer-events': 'none'\n      });\n    }\n\n    if (fullLayout._glcanvas) {\n      fullLayout._glcanvas.attr('width', fullLayout.width).attr('height', fullLayout.height);\n\n      var regl = fullLayout._glcanvas.data()[0].regl;\n\n      if (regl) {\n        // Unfortunately, this can happen when relayouting to large\n        // width/height on some browsers.\n        if (Math.floor(fullLayout.width) !== regl._gl.drawingBufferWidth || Math.floor(fullLayout.height) !== regl._gl.drawingBufferHeight) {\n          var msg = 'WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';\n\n          if (drawFrameworkCalls) {\n            Lib.error(msg);\n          } else {\n            Lib.log(msg + ' Clearing graph and plotting again.');\n            Plots.cleanPlot([], {}, gd._fullData, fullLayout);\n            Plots.supplyDefaults(gd);\n            fullLayout = gd._fullLayout;\n            Plots.doCalcdata(gd);\n            drawFrameworkCalls++;\n            return drawFramework();\n          }\n        }\n      }\n    }\n\n    if (fullLayout.modebar.orientation === 'h') {\n      fullLayout._modebardiv.style('height', null).style('width', '100%');\n    } else {\n      fullLayout._modebardiv.style('width', null).style('height', fullLayout.height + 'px');\n    }\n\n    return Plots.previousPromises(gd);\n  } // draw anything that can affect margins.\n\n\n  function marginPushers() {\n    // First reset the list of things that are allowed to change the margins\n    // So any deleted traces or components will be wiped out of the\n    // automargin calculation.\n    // This means *every* margin pusher must be listed here, even if it\n    // doesn't actually try to push the margins until later.\n    Plots.clearAutoMarginIds(gd);\n    subroutines.drawMarginPushers(gd);\n    Axes.allowAutoMargin(gd); // TODO can this be moved elsewhere?\n\n    if (fullLayout._has('pie')) {\n      var fullData = gd._fullData;\n\n      for (var i = 0; i < fullData.length; i++) {\n        var trace = fullData[i];\n\n        if (trace.type === 'pie' && trace.automargin) {\n          Plots.allowAutoMargin(gd, 'pie.' + trace.uid + '.automargin');\n        }\n      }\n    }\n\n    Plots.doAutoMargin(gd);\n    return Plots.previousPromises(gd);\n  } // in case the margins changed, draw margin pushers again\n\n\n  function marginPushersAgain() {\n    if (!Plots.didMarginChange(oldMargins, fullLayout._size)) return;\n    return Lib.syncOrAsync([marginPushers, subroutines.layoutStyles], gd);\n  }\n\n  function positionAndAutorange() {\n    if (!recalc) {\n      doAutoRangeAndConstraints();\n      return;\n    } // TODO: autosize extra for text markers and images\n    // see https://github.com/plotly/plotly.js/issues/1111\n\n\n    return Lib.syncOrAsync([Registry.getComponentMethod('shapes', 'calcAutorange'), Registry.getComponentMethod('annotations', 'calcAutorange'), doAutoRangeAndConstraints], gd);\n  }\n\n  function doAutoRangeAndConstraints() {\n    if (gd._transitioning) return;\n    subroutines.doAutoRangeAndConstraints(gd); // store initial ranges *after* enforcing constraints, otherwise\n    // we will never look like we're at the initial ranges\n\n    if (graphWasEmpty) Axes.saveRangeInitial(gd); // this one is different from shapes/annotations calcAutorange\n    // the others incorporate those components into ax._extremes,\n    // this one actually sets the ranges in rangesliders.\n\n    Registry.getComponentMethod('rangeslider', 'calcAutorange')(gd);\n  } // draw ticks, titles, and calculate axis scaling (._b, ._m)\n\n\n  function drawAxes() {\n    return Axes.draw(gd, graphWasEmpty ? '' : 'redraw');\n  }\n\n  var seq = [Plots.previousPromises, addFrames, drawFramework, marginPushers, marginPushersAgain];\n  if (hasCartesian) seq.push(positionAndAutorange);\n  seq.push(subroutines.layoutStyles);\n\n  if (hasCartesian) {\n    seq.push(drawAxes, function insideTickLabelsAutorange(gd) {\n      if (gd._fullLayout._insideTickLabelsAutorange) {\n        relayout(gd, gd._fullLayout._insideTickLabelsAutorange).then(function () {\n          gd._fullLayout._insideTickLabelsAutorange = undefined;\n        });\n      }\n    });\n  }\n\n  seq.push(subroutines.drawData, subroutines.finalDraw, initInteractions, Plots.addLinks, Plots.rehover, Plots.redrag, // TODO: doAutoMargin is only needed here for axis automargin, which\n  // happens outside of marginPushers where all the other automargins are\n  // calculated. Would be much better to separate margin calculations from\n  // component drawing - see https://github.com/plotly/plotly.js/issues/2704\n  Plots.doAutoMargin, saveRangeInitialForInsideTickLabels, Plots.previousPromises);\n\n  function saveRangeInitialForInsideTickLabels(gd) {\n    if (gd._fullLayout._insideTickLabelsAutorange) {\n      if (graphWasEmpty) Axes.saveRangeInitial(gd, true);\n    }\n  } // even if everything we did was synchronous, return a promise\n  // so that the caller doesn't care which route we took\n\n\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();\n  return plotDone.then(function () {\n    emitAfterPlot(gd);\n    return gd;\n  });\n}\n\nfunction emitAfterPlot(gd) {\n  var fullLayout = gd._fullLayout;\n\n  if (fullLayout._redrawFromAutoMarginCount) {\n    fullLayout._redrawFromAutoMarginCount--;\n  } else {\n    gd.emit('plotly_afterplot');\n  }\n}\n\nfunction setPlotConfig(obj) {\n  return Lib.extendFlat(dfltConfig, obj);\n}\n\nfunction setBackground(gd, bgColor) {\n  try {\n    gd._fullLayout._paper.style('background', bgColor);\n  } catch (e) {\n    Lib.error(e);\n  }\n}\n\nfunction opaqueSetBackground(gd, bgColor) {\n  var blend = Color.combine(bgColor, 'white');\n  setBackground(gd, blend);\n}\n\nfunction setPlotContext(gd, config) {\n  if (!gd._context) {\n    gd._context = Lib.extendDeep({}, dfltConfig); // stash <base> href, used to make robust clipPath URLs\n\n    var base = d3.select('base');\n    gd._context._baseUrl = base.size() && base.attr('href') ? window.location.href.split('#')[0] : '';\n  }\n\n  var context = gd._context;\n  var i, keys, key;\n\n  if (config) {\n    keys = Object.keys(config);\n\n    for (i = 0; i < keys.length; i++) {\n      key = keys[i];\n      if (key === 'editable' || key === 'edits') continue;\n\n      if (key in context) {\n        if (key === 'setBackground' && config[key] === 'opaque') {\n          context[key] = opaqueSetBackground;\n        } else {\n          context[key] = config[key];\n        }\n      }\n    } // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\n\n\n    if (config.plot3dPixelRatio && !context.plotGlPixelRatio) {\n      context.plotGlPixelRatio = context.plot3dPixelRatio;\n    } // now deal with editable and edits - first editable overrides\n    // everything, then edits refines\n\n\n    var editable = config.editable;\n\n    if (editable !== undefined) {\n      // we're not going to *use* context.editable, we're only going to\n      // use context.edits... but keep it for the record\n      context.editable = editable;\n      keys = Object.keys(context.edits);\n\n      for (i = 0; i < keys.length; i++) {\n        context.edits[keys[i]] = editable;\n      }\n    }\n\n    if (config.edits) {\n      keys = Object.keys(config.edits);\n\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n\n        if (key in context.edits) {\n          context.edits[key] = config.edits[key];\n        }\n      }\n    } // not part of the user-facing config options\n\n\n    context._exportedPlot = config._exportedPlot;\n  } // staticPlot forces a bunch of others:\n\n\n  if (context.staticPlot) {\n    context.editable = false;\n    context.edits = {};\n    context.autosizable = false;\n    context.scrollZoom = false;\n    context.doubleClick = false;\n    context.showTips = false;\n    context.showLink = false;\n    context.displayModeBar = false;\n  } // make sure hover-only devices have mode bar visible\n\n\n  if (context.displayModeBar === 'hover' && !hasHover) {\n    context.displayModeBar = true;\n  } // default and fallback for setBackground\n\n\n  if (context.setBackground === 'transparent' || typeof context.setBackground !== 'function') {\n    context.setBackground = setBackground;\n  } // Check if gd has a specified widht/height to begin with\n\n\n  context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;\n  context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0; // fill context._scrollZoom helper to help manage scrollZoom flaglist\n\n  var szIn = context.scrollZoom;\n  var szOut = context._scrollZoom = {};\n\n  if (szIn === true) {\n    szOut.cartesian = 1;\n    szOut.gl3d = 1;\n    szOut.geo = 1;\n    szOut.mapbox = 1;\n  } else if (typeof szIn === 'string') {\n    var parts = szIn.split('+');\n\n    for (i = 0; i < parts.length; i++) {\n      szOut[parts[i]] = 1;\n    }\n  } else if (szIn !== false) {\n    szOut.gl3d = 1;\n    szOut.geo = 1;\n    szOut.mapbox = 1;\n  }\n} // convenience function to force a full redraw, mostly for use by plotly.js\n\n\nfunction redraw(gd) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd);\n  }\n\n  helpers.cleanData(gd.data);\n  helpers.cleanLayout(gd.layout);\n  gd.calcdata = undefined;\n  return exports._doPlot(gd).then(function () {\n    gd.emit('plotly_redraw');\n    return gd;\n  });\n}\n/**\r\n * Convenience function to make idempotent plot option obvious to users.\r\n *\r\n * @param gd\r\n * @param {Object[]} data\r\n * @param {Object} layout\r\n * @param {Object} config\r\n */\n\n\nfunction newPlot(gd, data, layout, config) {\n  gd = Lib.getGraphDiv(gd); // remove gl contexts\n\n  Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});\n  Plots.purge(gd);\n  return exports._doPlot(gd, data, layout, config);\n}\n/**\r\n * Wrap negative indicies to their positive counterparts.\r\n *\r\n * @param {Number[]} indices An array of indices\r\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\r\n */\n\n\nfunction positivifyIndices(indices, maxIndex) {\n  var parentLength = maxIndex + 1;\n  var positiveIndices = [];\n  var i;\n  var index;\n\n  for (i = 0; i < indices.length; i++) {\n    index = indices[i];\n\n    if (index < 0) {\n      positiveIndices.push(parentLength + index);\n    } else {\n      positiveIndices.push(index);\n    }\n  }\n\n  return positiveIndices;\n}\n/**\r\n * Ensures that an index array for manipulating gd.data is valid.\r\n *\r\n * Intended for use with addTraces, deleteTraces, and moveTraces.\r\n *\r\n * @param gd\r\n * @param indices\r\n * @param arrayName\r\n */\n\n\nfunction assertIndexArray(gd, indices, arrayName) {\n  var i, index;\n\n  for (i = 0; i < indices.length; i++) {\n    index = indices[i]; // validate that indices are indeed integers\n\n    if (index !== parseInt(index, 10)) {\n      throw new Error('all values in ' + arrayName + ' must be integers');\n    } // check that all indices are in bounds for given gd.data array length\n\n\n    if (index >= gd.data.length || index < -gd.data.length) {\n      throw new Error(arrayName + ' must be valid indices for gd.data.');\n    } // check that indices aren't repeated\n\n\n    if (indices.indexOf(index, i + 1) > -1 || index >= 0 && indices.indexOf(-gd.data.length + index) > -1 || index < 0 && indices.indexOf(gd.data.length + index) > -1) {\n      throw new Error('each index in ' + arrayName + ' must be unique.');\n    }\n  }\n}\n/**\r\n * Private function used by Plotly.moveTraces to check input args\r\n *\r\n * @param gd\r\n * @param currentIndices\r\n * @param newIndices\r\n */\n\n\nfunction checkMoveTracesArgs(gd, currentIndices, newIndices) {\n  // check that gd has attribute 'data' and 'data' is array\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array.');\n  } // validate currentIndices array\n\n\n  if (typeof currentIndices === 'undefined') {\n    throw new Error('currentIndices is a required argument.');\n  } else if (!Array.isArray(currentIndices)) {\n    currentIndices = [currentIndices];\n  }\n\n  assertIndexArray(gd, currentIndices, 'currentIndices'); // validate newIndices array if it exists\n\n  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n\n  if (typeof newIndices !== 'undefined') {\n    assertIndexArray(gd, newIndices, 'newIndices');\n  } // check currentIndices and newIndices are the same length if newIdices exists\n\n\n  if (typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {\n    throw new Error('current and new indices must be of equal length.');\n  }\n}\n/**\r\n * A private function to reduce the type checking clutter in addTraces.\r\n *\r\n * @param gd\r\n * @param traces\r\n * @param newIndices\r\n */\n\n\nfunction checkAddTracesArgs(gd, traces, newIndices) {\n  var i, value; // check that gd has attribute 'data' and 'data' is array\n\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array.');\n  } // make sure traces exists\n\n\n  if (typeof traces === 'undefined') {\n    throw new Error('traces must be defined.');\n  } // make sure traces is an array\n\n\n  if (!Array.isArray(traces)) {\n    traces = [traces];\n  } // make sure each value in traces is an object\n\n\n  for (i = 0; i < traces.length; i++) {\n    value = traces[i];\n\n    if (typeof value !== 'object' || Array.isArray(value) || value === null) {\n      throw new Error('all values in traces array must be non-array objects');\n    }\n  } // make sure we have an index for each trace\n\n\n  if (typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n\n  if (typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {\n    throw new Error('if indices is specified, traces.length must equal indices.length');\n  }\n}\n/**\r\n * A private function to reduce the type checking clutter in spliceTraces.\r\n * Get all update Properties from gd.data. Validate inputs and outputs.\r\n * Used by prependTrace and extendTraces\r\n *\r\n * @param gd\r\n * @param update\r\n * @param indices\r\n * @param maxPoints\r\n */\n\n\nfunction assertExtendTracesArgs(gd, update, indices, maxPoints) {\n  var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n\n  if (!Array.isArray(gd.data)) {\n    throw new Error('gd.data must be an array');\n  }\n\n  if (!Lib.isPlainObject(update)) {\n    throw new Error('update must be a key:value object');\n  }\n\n  if (typeof indices === 'undefined') {\n    throw new Error('indices must be an integer or array of integers');\n  }\n\n  assertIndexArray(gd, indices, 'indices');\n\n  for (var key in update) {\n    /*\r\n     * Verify that the attribute to be updated contains as many trace updates\r\n     * as indices. Failure must result in throw and no-op\r\n     */\n    if (!Array.isArray(update[key]) || update[key].length !== indices.length) {\n      throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');\n    }\n    /*\r\n     * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\r\n     */\n\n\n    if (maxPointsIsObject && (!(key in maxPoints) || !Array.isArray(maxPoints[key]) || maxPoints[key].length !== update[key].length)) {\n      throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' + 'corrispondence with the keys and number of traces in the update object');\n    }\n  }\n}\n/**\r\n * A private function to reduce the type checking clutter in spliceTraces.\r\n *\r\n * @param {Object|HTMLDivElement} gd\r\n * @param {Object} update\r\n * @param {Number[]} indices\r\n * @param {Number||Object} maxPoints\r\n * @return {Object[]}\r\n */\n\n\nfunction getExtendProperties(gd, update, indices, maxPoints) {\n  var maxPointsIsObject = Lib.isPlainObject(maxPoints);\n  var updateProps = [];\n  var trace, target, prop, insert, maxp; // allow scalar index to represent a single trace position\n\n  if (!Array.isArray(indices)) indices = [indices]; // negative indices are wrapped around to their positive value. Equivalent to python indexing.\n\n  indices = positivifyIndices(indices, gd.data.length - 1); // loop through all update keys and traces and harvest validated data.\n\n  for (var key in update) {\n    for (var j = 0; j < indices.length; j++) {\n      /*\r\n       * Choose the trace indexed by the indices map argument and get the prop setter-getter\r\n       * instance that references the key and value for this particular trace.\r\n       */\n      trace = gd.data[indices[j]];\n      prop = nestedProperty(trace, key);\n      /*\r\n       * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\r\n       * Target must exist as an Array to allow the extend operation to be performed.\r\n       */\n\n      target = prop.get();\n      insert = update[key][j];\n\n      if (!Lib.isArrayOrTypedArray(insert)) {\n        throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');\n      }\n\n      if (!Lib.isArrayOrTypedArray(target)) {\n        throw new Error('cannot extend missing or non-array attribute: ' + key);\n      }\n\n      if (target.constructor !== insert.constructor) {\n        throw new Error('cannot extend array with an array of a different type: ' + key);\n      }\n      /*\r\n       * maxPoints may be an object map or a scalar. If object select the key:value, else\r\n       * Use the scalar maxPoints for all key and trace combinations.\r\n       */\n\n\n      maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints; // could have chosen null here, -1 just tells us to not take a window\n\n      if (!isNumeric(maxp)) maxp = -1;\n      /*\r\n       * Wrap the nestedProperty in an object containing required data\r\n       * for lengthening and windowing this particular trace - key combination.\r\n       * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\r\n       */\n\n      updateProps.push({\n        prop: prop,\n        target: target,\n        insert: insert,\n        maxp: Math.floor(maxp)\n      });\n    }\n  } // all target and insertion data now validated\n\n\n  return updateProps;\n}\n/**\r\n * A private function to key Extend and Prepend traces DRY\r\n *\r\n * @param {Object|HTMLDivElement} gd\r\n * @param {Object} update\r\n * @param {Number[]} indices\r\n * @param {Number||Object} maxPoints\r\n * @param {Function} updateArray\r\n * @return {Object}\r\n */\n\n\nfunction spliceTraces(gd, update, indices, maxPoints, updateArray) {\n  assertExtendTracesArgs(gd, update, indices, maxPoints);\n  var updateProps = getExtendProperties(gd, update, indices, maxPoints);\n  var undoUpdate = {};\n  var undoPoints = {};\n\n  for (var i = 0; i < updateProps.length; i++) {\n    var prop = updateProps[i].prop;\n    var maxp = updateProps[i].maxp; // return new array and remainder\n\n    var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);\n    prop.set(out[0]); // build the inverse update object for the undo operation\n\n    if (!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];\n    undoUpdate[prop.astr].push(out[1]); // build the matching maxPoints undo object containing original trace lengths\n\n    if (!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];\n    undoPoints[prop.astr].push(updateProps[i].target.length);\n  }\n\n  return {\n    update: undoUpdate,\n    maxPoints: undoPoints\n  };\n}\n\nfunction concatTypedArray(arr0, arr1) {\n  var arr2 = new arr0.constructor(arr0.length + arr1.length);\n  arr2.set(arr0);\n  arr2.set(arr1, arr0.length);\n  return arr2;\n}\n/**\r\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\r\n *\r\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\r\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\r\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\r\n * from the tail.\r\n *\r\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\r\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\r\n *\r\n * @param {Object|HTMLDivElement} gd The graph div\r\n * @param {Object} update The key:array map of target attributes to extend\r\n * @param {Number|Number[]} indices The locations of traces to be extended\r\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\r\n *\r\n */\n\n\nfunction extendTraces(gd, update, indices, maxPoints) {\n  gd = Lib.getGraphDiv(gd);\n\n  function updateArray(target, insert, maxp) {\n    var newArray, remainder;\n\n    if (Lib.isTypedArray(target)) {\n      if (maxp < 0) {\n        var none = new target.constructor(0);\n        var both = concatTypedArray(target, insert);\n\n        if (maxp < 0) {\n          newArray = both;\n          remainder = none;\n        } else {\n          newArray = none;\n          remainder = both;\n        }\n      } else {\n        newArray = new target.constructor(maxp);\n        remainder = new target.constructor(target.length + insert.length - maxp);\n\n        if (maxp === insert.length) {\n          newArray.set(insert);\n          remainder.set(target);\n        } else if (maxp < insert.length) {\n          var numberOfItemsFromInsert = insert.length - maxp;\n          newArray.set(insert.subarray(numberOfItemsFromInsert));\n          remainder.set(target);\n          remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);\n        } else {\n          var numberOfItemsFromTarget = maxp - insert.length;\n          var targetBegin = target.length - numberOfItemsFromTarget;\n          newArray.set(target.subarray(targetBegin));\n          newArray.set(insert, numberOfItemsFromTarget);\n          remainder.set(target.subarray(0, targetBegin));\n        }\n      }\n    } else {\n      newArray = target.concat(insert);\n      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(0, newArray.length - maxp) : [];\n    }\n\n    return [newArray, remainder];\n  }\n\n  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n  var promise = exports.redraw(gd);\n  var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n  Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);\n  return promise;\n}\n\nfunction prependTraces(gd, update, indices, maxPoints) {\n  gd = Lib.getGraphDiv(gd);\n\n  function updateArray(target, insert, maxp) {\n    var newArray, remainder;\n\n    if (Lib.isTypedArray(target)) {\n      if (maxp <= 0) {\n        var none = new target.constructor(0);\n        var both = concatTypedArray(insert, target);\n\n        if (maxp < 0) {\n          newArray = both;\n          remainder = none;\n        } else {\n          newArray = none;\n          remainder = both;\n        }\n      } else {\n        newArray = new target.constructor(maxp);\n        remainder = new target.constructor(target.length + insert.length - maxp);\n\n        if (maxp === insert.length) {\n          newArray.set(insert);\n          remainder.set(target);\n        } else if (maxp < insert.length) {\n          var numberOfItemsFromInsert = insert.length - maxp;\n          newArray.set(insert.subarray(0, numberOfItemsFromInsert));\n          remainder.set(insert.subarray(numberOfItemsFromInsert));\n          remainder.set(target, numberOfItemsFromInsert);\n        } else {\n          var numberOfItemsFromTarget = maxp - insert.length;\n          newArray.set(insert);\n          newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);\n          remainder.set(target.subarray(numberOfItemsFromTarget));\n        }\n      }\n    } else {\n      newArray = insert.concat(target);\n      remainder = maxp >= 0 && maxp < newArray.length ? newArray.splice(maxp, newArray.length) : [];\n    }\n\n    return [newArray, remainder];\n  }\n\n  var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\n  var promise = exports.redraw(gd);\n  var undoArgs = [gd, undo.update, indices, undo.maxPoints];\n  Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);\n  return promise;\n}\n/**\r\n * Add data traces to an existing graph div.\r\n *\r\n * @param {Object|HTMLDivElement} gd The graph div\r\n * @param {Object[]} gd.data The array of traces we're adding to\r\n * @param {Object[]|Object} traces The object or array of objects to add\r\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\r\n *\r\n */\n\n\nfunction addTraces(gd, traces, newIndices) {\n  gd = Lib.getGraphDiv(gd);\n  var currentIndices = [];\n  var undoFunc = exports.deleteTraces;\n  var redoFunc = addTraces;\n  var undoArgs = [gd, currentIndices];\n  var redoArgs = [gd, traces]; // no newIndices here\n\n  var i;\n  var promise; // all validation is done elsewhere to remove clutter here\n\n  checkAddTracesArgs(gd, traces, newIndices); // make sure traces is an array\n\n  if (!Array.isArray(traces)) {\n    traces = [traces];\n  } // make sure traces do not repeat existing ones\n\n\n  traces = traces.map(function (trace) {\n    return Lib.extendFlat({}, trace);\n  });\n  helpers.cleanData(traces); // add the traces to gd.data (no redrawing yet!)\n\n  for (i = 0; i < traces.length; i++) {\n    gd.data.push(traces[i]);\n  } // to continue, we need to call moveTraces which requires currentIndices\n\n\n  for (i = 0; i < traces.length; i++) {\n    currentIndices.push(-traces.length + i);\n  } // if the user didn't define newIndices, they just want the traces appended\n  // i.e., we can simply redraw and be done\n\n\n  if (typeof newIndices === 'undefined') {\n    promise = exports.redraw(gd);\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n    return promise;\n  } // make sure indices is property defined\n\n\n  if (!Array.isArray(newIndices)) {\n    newIndices = [newIndices];\n  }\n\n  try {\n    // this is redundant, but necessary to not catch later possible errors!\n    checkMoveTracesArgs(gd, currentIndices, newIndices);\n  } catch (error) {\n    // something went wrong, reset gd to be safe and rethrow error\n    gd.data.splice(gd.data.length - traces.length, traces.length);\n    throw error;\n  } // if we're here, the user has defined specific places to place the new traces\n  // this requires some extra work that moveTraces will do\n\n\n  Queue.startSequence(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  promise = exports.moveTraces(gd, currentIndices, newIndices);\n  Queue.stopSequence(gd);\n  return promise;\n}\n/**\r\n * Delete traces at `indices` from gd.data array.\r\n *\r\n * @param {Object|HTMLDivElement} gd The graph div\r\n * @param {Object[]} gd.data The array of traces we're removing from\r\n * @param {Number|Number[]} indices The indices\r\n */\n\n\nfunction deleteTraces(gd, indices) {\n  gd = Lib.getGraphDiv(gd);\n  var traces = [];\n  var undoFunc = exports.addTraces;\n  var redoFunc = deleteTraces;\n  var undoArgs = [gd, traces, indices];\n  var redoArgs = [gd, indices];\n  var i;\n  var deletedTrace; // make sure indices are defined\n\n  if (typeof indices === 'undefined') {\n    throw new Error('indices must be an integer or array of integers.');\n  } else if (!Array.isArray(indices)) {\n    indices = [indices];\n  }\n\n  assertIndexArray(gd, indices, 'indices'); // convert negative indices to positive indices\n\n  indices = positivifyIndices(indices, gd.data.length - 1); // we want descending here so that splicing later doesn't affect indexing\n\n  indices.sort(Lib.sorterDes);\n\n  for (i = 0; i < indices.length; i += 1) {\n    deletedTrace = gd.data.splice(indices[i], 1)[0];\n    traces.push(deletedTrace);\n  }\n\n  var promise = exports.redraw(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return promise;\n}\n/**\r\n * Move traces at currentIndices array to locations in newIndices array.\r\n *\r\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\r\n * these are equivalent:\r\n *\r\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\r\n * Plotly.moveTraces(gd, [1, 2, 3])\r\n *\r\n * @param {Object|HTMLDivElement} gd The graph div\r\n * @param {Object[]} gd.data The array of traces we're removing from\r\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\r\n * @param {Number|Number[]} [newIndices] The locations to move traces to\r\n *\r\n * Example calls:\r\n *\r\n *      // move trace i to location x\r\n *      Plotly.moveTraces(gd, i, x)\r\n *\r\n *      // move trace i to end of array\r\n *      Plotly.moveTraces(gd, i)\r\n *\r\n *      // move traces i, j, k to end of array (i != j != k)\r\n *      Plotly.moveTraces(gd, [i, j, k])\r\n *\r\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\r\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\r\n *\r\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\r\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\r\n */\n\n\nfunction moveTraces(gd, currentIndices, newIndices) {\n  gd = Lib.getGraphDiv(gd);\n  var newData = [];\n  var movingTraceMap = [];\n  var undoFunc = moveTraces;\n  var redoFunc = moveTraces;\n  var undoArgs = [gd, newIndices, currentIndices];\n  var redoArgs = [gd, currentIndices, newIndices];\n  var i; // to reduce complexity here, check args elsewhere\n  // this throws errors where appropriate\n\n  checkMoveTracesArgs(gd, currentIndices, newIndices); // make sure currentIndices is an array\n\n  currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices]; // if undefined, define newIndices to point to the end of gd.data array\n\n  if (typeof newIndices === 'undefined') {\n    newIndices = [];\n\n    for (i = 0; i < currentIndices.length; i++) {\n      newIndices.push(-currentIndices.length + i);\n    }\n  } // make sure newIndices is an array if it's user-defined\n\n\n  newIndices = Array.isArray(newIndices) ? newIndices : [newIndices]; // convert negative indices to positive indices (they're the same length)\n\n  currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);\n  newIndices = positivifyIndices(newIndices, gd.data.length - 1); // at this point, we've coerced the index arrays into predictable forms\n  // get the traces that aren't being moved around\n\n  for (i = 0; i < gd.data.length; i++) {\n    // if index isn't in currentIndices, include it in ignored!\n    if (currentIndices.indexOf(i) === -1) {\n      newData.push(gd.data[i]);\n    }\n  } // get a mapping of indices to moving traces\n\n\n  for (i = 0; i < currentIndices.length; i++) {\n    movingTraceMap.push({\n      newIndex: newIndices[i],\n      trace: gd.data[currentIndices[i]]\n    });\n  } // reorder this mapping by newIndex, ascending\n\n\n  movingTraceMap.sort(function (a, b) {\n    return a.newIndex - b.newIndex;\n  }); // now, add the moving traces back in, in order!\n\n  for (i = 0; i < movingTraceMap.length; i += 1) {\n    newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);\n  }\n\n  gd.data = newData;\n  var promise = exports.redraw(gd);\n  Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return promise;\n}\n/**\r\n * restyle: update trace attributes of an existing plot\r\n *\r\n * Can be called two ways.\r\n *\r\n * Signature 1:\r\n * @param {String | HTMLDivElement} gd\r\n *  the id or DOM element of the graph container div\r\n * @param {String} astr\r\n *  attribute string (like `'marker.symbol'`) to update\r\n * @param {*} val\r\n *  value to give this attribute\r\n * @param {Number[] | Number} [traces]\r\n *  integer or array of integers for the traces to alter (all if omitted)\r\n *\r\n * Signature 2:\r\n * @param {String | HTMLDivElement} gd\r\n *  (as in signature 1)\r\n * @param {Object} aobj\r\n *  attribute object `{astr1: val1, astr2: val2 ...}`\r\n *  allows setting multiple attributes simultaneously\r\n * @param {Number[] | Number} [traces]\r\n *  (as in signature 1)\r\n *\r\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\r\n * to apply different values to each trace.\r\n *\r\n * If the array is too short, it will wrap around (useful for\r\n * style files that want to specify cyclical default values).\r\n */\n\n\nfunction restyle(gd, astr, val, _traces) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var aobj = {};\n  if (typeof astr === 'string') aobj[astr] = val;else if (Lib.isPlainObject(astr)) {\n    // the 3-arg form\n    aobj = Lib.extendFlat({}, astr);\n    if (_traces === undefined) _traces = val;\n  } else {\n    Lib.warn('Restyle fail.', astr, val, _traces);\n    return Promise.reject();\n  }\n  if (Object.keys(aobj).length) gd.changed = true;\n  var traces = helpers.coerceTraceIndices(gd, _traces);\n\n  var specs = _restyle(gd, aobj, traces);\n\n  var flags = specs.flags; // clear calcdata and/or axis types if required so they get regenerated\n\n  if (flags.calc) gd.calcdata = undefined;\n  if (flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {}); // fill in redraw sequence\n\n  var seq = [];\n\n  if (flags.fullReplot) {\n    seq.push(exports._doPlot);\n  } else {\n    seq.push(Plots.previousPromises); // maybe only call Plots.supplyDataDefaults in the splom case,\n    // to skip over long and slow axes defaults\n\n    Plots.supplyDefaults(gd);\n\n    if (flags.markerSize) {\n      Plots.doCalcdata(gd);\n      addAxRangeSequence(seq); // TODO\n      // if all axes have autorange:false, then\n      // proceed to subroutines.doTraceStyle(),\n      // otherwise we must go through addAxRangeSequence,\n      // which in general must redraws 'all' axes\n    }\n\n    if (flags.style) seq.push(subroutines.doTraceStyle);\n    if (flags.colorbars) seq.push(subroutines.doColorBars);\n    seq.push(emitAfterPlot);\n  }\n\n  seq.push(Plots.rehover, Plots.redrag);\n  Queue.add(gd, restyle, [gd, specs.undoit, specs.traces], restyle, [gd, specs.redoit, specs.traces]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve();\n  return plotDone.then(function () {\n    gd.emit('plotly_restyle', specs.eventData);\n    return gd;\n  });\n} // for undo: undefined initial vals must be turned into nulls\n// so that we unset rather than ignore them\n\n\nfunction undefinedToNull(val) {\n  if (val === undefined) return null;\n  return val;\n}\n/**\r\n * Factory function to wrap nestedProperty with GUI edits if necessary\r\n * with GUI edits we add an optional prefix to the nestedProperty constructor\r\n * to prepend to the attribute string in the preGUI store.\r\n */\n\n\nfunction makeNP(preGUI, guiEditFlag) {\n  if (!guiEditFlag) return nestedProperty;\n  return function (container, attr, prefix) {\n    var np = nestedProperty(container, attr);\n    var npSet = np.set;\n\n    np.set = function (val) {\n      var fullAttr = (prefix || '') + attr;\n      storeCurrent(fullAttr, np.get(), val, preGUI);\n      npSet(val);\n    };\n\n    return np;\n  };\n}\n\nfunction storeCurrent(attr, val, newVal, preGUI) {\n  if (Array.isArray(val) || Array.isArray(newVal)) {\n    var arrayVal = Array.isArray(val) ? val : [];\n    var arrayNew = Array.isArray(newVal) ? newVal : [];\n    var maxLen = Math.max(arrayVal.length, arrayNew.length);\n\n    for (var i = 0; i < maxLen; i++) {\n      storeCurrent(attr + '[' + i + ']', arrayVal[i], arrayNew[i], preGUI);\n    }\n  } else if (Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {\n    var objVal = Lib.isPlainObject(val) ? val : {};\n    var objNew = Lib.isPlainObject(newVal) ? newVal : {};\n    var objBoth = Lib.extendFlat({}, objVal, objNew);\n\n    for (var key in objBoth) {\n      storeCurrent(attr + '.' + key, objVal[key], objNew[key], preGUI);\n    }\n  } else if (preGUI[attr] === undefined) {\n    preGUI[attr] = undefinedToNull(val);\n  }\n}\n/**\r\n * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it\r\n * by emitting a plotly_restyle or plotly_relayout event, this routine\r\n * keeps track of the initial state in _preGUI for use by uirevision\r\n * Does *not* apply these changes to data/layout - that's the responsibility\r\n * of the calling routine.\r\n *\r\n * @param {object} container: the input attributes container (eg `layout` or a `trace`)\r\n * @param {object} preGUI: where original values should be stored, either\r\n *     `layout._preGUI` or `layout._tracePreGUI[uid]`\r\n * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc\r\n */\n\n\nfunction _storeDirectGUIEdit(container, preGUI, edits) {\n  for (var attr in edits) {\n    var np = nestedProperty(container, attr);\n    storeCurrent(attr, np.get(), edits[attr], preGUI);\n  }\n}\n\nfunction _restyle(gd, aobj, traces) {\n  var fullLayout = gd._fullLayout;\n  var fullData = gd._fullData;\n  var data = gd.data;\n  var guiEditFlag = fullLayout._guiEditing;\n  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n  var eventData = Lib.extendDeepAll({}, aobj);\n  var i;\n  cleanDeprecatedAttributeKeys(aobj); // initialize flags\n\n  var flags = editTypes.traceFlags(); // copies of the change (and previous values of anything affected)\n  // for the undo / redo queue\n\n  var redoit = {};\n  var undoit = {};\n  var axlist; // make a new empty vals array for undoit\n\n  function a0() {\n    return traces.map(function () {\n      return undefined;\n    });\n  } // for autoranging multiple axes\n\n\n  function addToAxlist(axid) {\n    var axName = Axes.id2name(axid);\n    if (axlist.indexOf(axName) === -1) axlist.push(axName);\n  }\n\n  function autorangeAttr(axName) {\n    return 'LAYOUT' + axName + '.autorange';\n  }\n\n  function rangeAttr(axName) {\n    return 'LAYOUT' + axName + '.range';\n  }\n\n  function getFullTrace(traceIndex) {\n    // usually fullData maps 1:1 onto data, but with groupby transforms\n    // the fullData index can be greater. Take the *first* matching trace.\n    for (var j = traceIndex; j < fullData.length; j++) {\n      if (fullData[j]._input === data[traceIndex]) return fullData[j];\n    } // should never get here - and if we *do* it should cause an error\n    // later on undefined fullTrace is passed to nestedProperty.\n\n  } // for attrs that interact (like scales & autoscales), save the\n  // old vals before making the change\n  // val=undefined will not set a value, just record what the value was.\n  // val=null will delete the attribute\n  // attr can be an array to set several at once (all to the same val)\n\n\n  function doextra(attr, val, i) {\n    if (Array.isArray(attr)) {\n      attr.forEach(function (a) {\n        doextra(a, val, i);\n      });\n      return;\n    } // quit if explicitly setting this elsewhere\n\n\n    if (attr in aobj || helpers.hasParent(aobj, attr)) return;\n    var extraparam;\n\n    if (attr.substr(0, 6) === 'LAYOUT') {\n      extraparam = layoutNP(gd.layout, attr.replace('LAYOUT', ''));\n    } else {\n      var tracei = traces[i];\n\n      var preGUI = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];\n\n      extraparam = makeNP(preGUI, guiEditFlag)(data[tracei], attr);\n    }\n\n    if (!(attr in undoit)) {\n      undoit[attr] = a0();\n    }\n\n    if (undoit[attr][i] === undefined) {\n      undoit[attr][i] = undefinedToNull(extraparam.get());\n    }\n\n    if (val !== undefined) {\n      extraparam.set(val);\n    }\n  }\n\n  function allBins(binAttr) {\n    return function (j) {\n      return fullData[j][binAttr];\n    };\n  }\n\n  function arrayBins(binAttr) {\n    return function (vij, j) {\n      return vij === false ? fullData[traces[j]][binAttr] : null;\n    };\n  } // now make the changes to gd.data (and occasionally gd.layout)\n  // and figure out what kind of graphics update we need to do\n\n\n  for (var ai in aobj) {\n    if (helpers.hasParent(aobj, ai)) {\n      throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n    }\n\n    var vi = aobj[ai];\n    var cont;\n    var contFull;\n    var param;\n    var oldVal;\n    var newVal;\n    var valObject; // Backward compatibility shim for turning histogram autobin on,\n    // or freezing previous autobinned values.\n    // Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`\n    // and `autobin(x|y): false` with the `(x|y)bins` in `fullData`\n\n    if (ai === 'autobinx' || ai === 'autobiny') {\n      ai = ai.charAt(ai.length - 1) + 'bins';\n      if (Array.isArray(vi)) vi = vi.map(arrayBins(ai));else if (vi === false) vi = traces.map(allBins(ai));else vi = null;\n    }\n\n    redoit[ai] = vi;\n\n    if (ai.substr(0, 6) === 'LAYOUT') {\n      param = layoutNP(gd.layout, ai.replace('LAYOUT', ''));\n      undoit[ai] = [undefinedToNull(param.get())]; // since we're allowing val to be an array, allow it here too,\n      // even though that's meaningless\n\n      param.set(Array.isArray(vi) ? vi[0] : vi); // ironically, the layout attrs in restyle only require replot,\n      // not relayout\n\n      flags.calc = true;\n      continue;\n    } // set attribute in gd.data\n\n\n    undoit[ai] = a0();\n\n    for (i = 0; i < traces.length; i++) {\n      cont = data[traces[i]];\n      contFull = getFullTrace(traces[i]);\n      var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];\n      param = makeNP(preGUI, guiEditFlag)(cont, ai);\n      oldVal = param.get();\n      newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;\n      if (newVal === undefined) continue;\n      var finalPart = param.parts[param.parts.length - 1];\n      var prefix = ai.substr(0, ai.length - finalPart.length - 1);\n      var prefixDot = prefix ? prefix + '.' : '';\n      var innerContFull = prefix ? nestedProperty(contFull, prefix).get() : contFull;\n      valObject = PlotSchema.getTraceValObject(contFull, param.parts);\n\n      if (valObject && valObject.impliedEdits && newVal !== null) {\n        for (var impliedKey in valObject.impliedEdits) {\n          doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);\n        }\n      } else if ((finalPart === 'thicknessmode' || finalPart === 'lenmode') && oldVal !== newVal && (newVal === 'fraction' || newVal === 'pixels') && innerContFull) {\n        // changing colorbar size modes,\n        // make the resulting size not change\n        // note that colorbar fractional sizing is based on the\n        // original plot size, before anything (like a colorbar)\n        // increases the margins\n        var gs = fullLayout._size;\n        var orient = innerContFull.orient;\n        var topOrBottom = orient === 'top' || orient === 'bottom';\n\n        if (finalPart === 'thicknessmode') {\n          var thicknorm = topOrBottom ? gs.h : gs.w;\n          doextra(prefixDot + 'thickness', innerContFull.thickness * (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);\n        } else {\n          var lennorm = topOrBottom ? gs.w : gs.h;\n          doextra(prefixDot + 'len', innerContFull.len * (newVal === 'fraction' ? 1 / lennorm : lennorm), i);\n        }\n      } else if (ai === 'type' && (newVal === 'pie' !== (oldVal === 'pie') || newVal === 'funnelarea' !== (oldVal === 'funnelarea'))) {\n        var labelsTo = 'x';\n        var valuesTo = 'y';\n\n        if ((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {\n          labelsTo = 'y';\n          valuesTo = 'x';\n        }\n\n        Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);\n        Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);\n        Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);\n\n        if (oldVal === 'pie' || oldVal === 'funnelarea') {\n          nestedProperty(cont, 'marker.color').set(nestedProperty(cont, 'marker.colors').get()); // super kludgy - but if all pies are gone we won't remove them otherwise\n\n          fullLayout._pielayer.selectAll('g.trace').remove();\n        } else if (Registry.traceIs(cont, 'cartesian')) {\n          nestedProperty(cont, 'marker.colors').set(nestedProperty(cont, 'marker.color').get());\n        }\n      }\n\n      undoit[ai][i] = undefinedToNull(oldVal); // set the new value - if val is an array, it's one el per trace\n      // first check for attributes that get more complex alterations\n\n      var swapAttrs = ['swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'];\n\n      if (swapAttrs.indexOf(ai) !== -1) {\n        // setting an orientation: make sure it's changing\n        // before we swap everything else\n        if (ai === 'orientation') {\n          param.set(newVal); // obnoxious that we need this level of coupling... but in order to\n          // properly handle setting orientation to `null` we need to mimic\n          // the logic inside Bars.supplyDefaults for default orientation\n\n          var defaultOrientation = cont.x && !cont.y ? 'h' : 'v';\n\n          if ((param.get() || defaultOrientation) === contFull.orientation) {\n            continue;\n          }\n        } else if (ai === 'orientationaxes') {\n          // orientationaxes has no value,\n          // it flips everything and the axes\n          cont.orientation = {\n            v: 'h',\n            h: 'v'\n          }[contFull.orientation];\n        }\n\n        helpers.swapXYData(cont);\n        flags.calc = flags.clearAxisTypes = true;\n      } else if (Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {\n        // TODO: use manageArrays.applyContainerArrayChanges here too\n        helpers.manageArrayContainers(param, newVal, undoit);\n        flags.calc = true;\n      } else {\n        if (valObject) {\n          // must redo calcdata when restyling array values of arrayOk attributes\n          // ... but no need to this for regl-based traces\n          if (valObject.arrayOk && !Registry.traceIs(contFull, 'regl') && (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))) {\n            flags.calc = true;\n          } else editTypes.update(flags, valObject);\n        } else {\n          /*\r\n           * if we couldn't find valObject,  assume a full recalc.\r\n           * This can happen if you're changing type and making\r\n           * some other edits too, so the modules we're\r\n           * looking at don't have these attributes in them.\r\n           */\n          flags.calc = true;\n        } // all the other ones, just modify that one attribute\n\n\n        param.set(newVal);\n      }\n    } // swap the data attributes of the relevant x and y axes?\n\n\n    if (['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {\n      Axes.swap(gd, traces);\n    } // swap hovermode if set to \"compare x/y data\"\n\n\n    if (ai === 'orientationaxes') {\n      var hovermode = nestedProperty(gd.layout, 'hovermode');\n      var h = hovermode.get();\n\n      if (h === 'x') {\n        hovermode.set('y');\n      } else if (h === 'y') {\n        hovermode.set('x');\n      } else if (h === 'x unified') {\n        hovermode.set('y unified');\n      } else if (h === 'y unified') {\n        hovermode.set('x unified');\n      }\n    } // Major enough changes deserve autoscale and\n    // non-reversed axes so people don't get confused\n    //\n    // Note: autobin (or its new analog bin clearing) is not included here\n    // since we're not pushing bins back to gd.data, so if we have bin\n    // info it was explicitly provided by the user.\n\n\n    if (['orientation', 'type'].indexOf(ai) !== -1) {\n      axlist = [];\n\n      for (i = 0; i < traces.length; i++) {\n        var trace = data[traces[i]];\n\n        if (Registry.traceIs(trace, 'cartesian')) {\n          addToAxlist(trace.xaxis || 'x');\n          addToAxlist(trace.yaxis || 'y');\n        }\n      }\n\n      doextra(axlist.map(autorangeAttr), true, 0);\n      doextra(axlist.map(rangeAttr), [0, 1], 0);\n    }\n  }\n\n  if (flags.calc || flags.plot) {\n    flags.fullReplot = true;\n  }\n\n  return {\n    flags: flags,\n    undoit: undoit,\n    redoit: redoit,\n    traces: traces,\n    eventData: Lib.extendDeepNoArrays([], [eventData, traces])\n  };\n}\n/**\r\n * Converts deprecated attribute keys to\r\n * the current API to ensure backwards compatibility.\r\n *\r\n * This is needed for the update mechanism to determine which\r\n * subroutines to run based on the actual attribute\r\n * definitions (that don't include the deprecated ones).\r\n *\r\n * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}\r\n * and {titlefont: {...}} to {'title.font': {...}}.\r\n *\r\n * @param aobj\r\n */\n\n\nfunction cleanDeprecatedAttributeKeys(aobj) {\n  var oldAxisTitleRegex = Lib.counterRegex('axis', '\\.title', false, false);\n  var colorbarRegex = /colorbar\\.title$/;\n  var keys = Object.keys(aobj);\n  var i, key, value;\n\n  for (i = 0; i < keys.length; i++) {\n    key = keys[i];\n    value = aobj[key];\n\n    if ((key === 'title' || oldAxisTitleRegex.test(key) || colorbarRegex.test(key)) && (typeof value === 'string' || typeof value === 'number')) {\n      replace(key, key.replace('title', 'title.text'));\n    } else if (key.indexOf('titlefont') > -1) {\n      replace(key, key.replace('titlefont', 'title.font'));\n    } else if (key.indexOf('titleposition') > -1) {\n      replace(key, key.replace('titleposition', 'title.position'));\n    } else if (key.indexOf('titleside') > -1) {\n      replace(key, key.replace('titleside', 'title.side'));\n    } else if (key.indexOf('titleoffset') > -1) {\n      replace(key, key.replace('titleoffset', 'title.offset'));\n    }\n  }\n\n  function replace(oldAttrStr, newAttrStr) {\n    aobj[newAttrStr] = aobj[oldAttrStr];\n    delete aobj[oldAttrStr];\n  }\n}\n/**\r\n * relayout: update layout attributes of an existing plot\r\n *\r\n * Can be called two ways:\r\n *\r\n * Signature 1:\r\n * @param {String | HTMLDivElement} gd\r\n *  the id or dom element of the graph container div\r\n * @param {String} astr\r\n *  attribute string (like `'xaxis.range[0]'`) to update\r\n * @param {*} val\r\n *  value to give this attribute\r\n *\r\n * Signature 2:\r\n * @param {String | HTMLDivElement} gd\r\n *  (as in signature 1)\r\n * @param {Object} aobj\r\n *  attribute object `{astr1: val1, astr2: val2 ...}`\r\n *  allows setting multiple attributes simultaneously\r\n */\n\n\nfunction relayout(gd, astr, val) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var aobj = {};\n\n  if (typeof astr === 'string') {\n    aobj[astr] = val;\n  } else if (Lib.isPlainObject(astr)) {\n    aobj = Lib.extendFlat({}, astr);\n  } else {\n    Lib.warn('Relayout fail.', astr, val);\n    return Promise.reject();\n  }\n\n  if (Object.keys(aobj).length) gd.changed = true;\n\n  var specs = _relayout(gd, aobj);\n\n  var flags = specs.flags; // clear calcdata if required\n\n  if (flags.calc) gd.calcdata = undefined; // fill in redraw sequence\n  // even if we don't have anything left in aobj,\n  // something may have happened within relayout that we\n  // need to wait for\n\n  var seq = [Plots.previousPromises];\n\n  if (flags.layoutReplot) {\n    seq.push(subroutines.layoutReplot);\n  } else if (Object.keys(aobj).length) {\n    axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);\n    if (flags.legend) seq.push(subroutines.doLegend);\n    if (flags.layoutstyle) seq.push(subroutines.layoutStyles);\n    if (flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);\n    if (flags.ticks) seq.push(subroutines.doTicksRelayout);\n    if (flags.modebar) seq.push(subroutines.doModeBar);\n    if (flags.camera) seq.push(subroutines.doCamera);\n    if (flags.colorbars) seq.push(subroutines.doColorBars);\n    seq.push(emitAfterPlot);\n  }\n\n  seq.push(Plots.rehover, Plots.redrag);\n  Queue.add(gd, relayout, [gd, specs.undoit], relayout, [gd, specs.redoit]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  return plotDone.then(function () {\n    gd.emit('plotly_relayout', specs.eventData);\n    return gd;\n  });\n} // Optimization mostly for large splom traces where\n// Plots.supplyDefaults can take > 100ms\n\n\nfunction axRangeSupplyDefaultsByPass(gd, flags, specs) {\n  var fullLayout = gd._fullLayout;\n  if (!flags.axrange) return false;\n\n  for (var k in flags) {\n    if (k !== 'axrange' && flags[k]) return false;\n  }\n\n  for (var axId in specs.rangesAltered) {\n    var axName = Axes.id2name(axId);\n    var axIn = gd.layout[axName];\n    var axOut = fullLayout[axName];\n    axOut.autorange = axIn.autorange;\n\n    if (axIn.range) {\n      axOut.range = axIn.range.slice();\n    }\n\n    axOut.cleanRange();\n\n    if (axOut._matchGroup) {\n      for (var axId2 in axOut._matchGroup) {\n        if (axId2 !== axId) {\n          var ax2 = fullLayout[Axes.id2name(axId2)];\n          ax2.autorange = axOut.autorange;\n          ax2.range = axOut.range.slice();\n          ax2._input.range = axOut.range.slice();\n        }\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction addAxRangeSequence(seq, rangesAltered) {\n  // N.B. leave as sequence of subroutines (for now) instead of\n  // subroutine of its own so that finalDraw always gets\n  // executed after drawData\n  var drawAxes = rangesAltered ? function (gd) {\n    var axIds = [];\n    var skipTitle = true;\n\n    for (var id in rangesAltered) {\n      var ax = Axes.getFromId(gd, id);\n      axIds.push(id);\n\n      if ((ax.ticklabelposition || '').indexOf('inside') !== -1) {\n        if (ax._anchorAxis) {\n          axIds.push(ax._anchorAxis._id);\n        }\n      }\n\n      if (ax._matchGroup) {\n        for (var id2 in ax._matchGroup) {\n          if (!rangesAltered[id2]) {\n            axIds.push(id2);\n          }\n        }\n      }\n\n      if (ax.automargin) skipTitle = false;\n    }\n\n    return Axes.draw(gd, axIds, {\n      skipTitle: skipTitle\n    });\n  } : function (gd) {\n    return Axes.draw(gd, 'redraw');\n  };\n  seq.push(clearSelect, subroutines.doAutoRangeAndConstraints, drawAxes, subroutines.drawData, subroutines.finalDraw);\n}\n\nvar AX_RANGE_RE = /^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/;\nvar AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\\.autorange$/;\nvar AX_DOMAIN_RE = /^[xyz]axis[0-9]*\\.domain(\\[[0|1]\\])?$/;\n\nfunction _relayout(gd, aobj) {\n  var layout = gd.layout;\n  var fullLayout = gd._fullLayout;\n  var guiEditFlag = fullLayout._guiEditing;\n  var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\n  var keys = Object.keys(aobj);\n  var axes = Axes.list(gd);\n  var eventData = Lib.extendDeepAll({}, aobj);\n  var arrayEdits = {};\n  var arrayStr, i, j;\n  cleanDeprecatedAttributeKeys(aobj);\n  keys = Object.keys(aobj); // look for 'allaxes', split out into all axes\n  // in case of 3D the axis are nested within a scene which is held in _id\n\n  for (i = 0; i < keys.length; i++) {\n    if (keys[i].indexOf('allaxes') === 0) {\n      for (j = 0; j < axes.length; j++) {\n        var scene = axes[j]._id.substr(1);\n\n        var axisAttr = scene.indexOf('scene') !== -1 ? scene + '.' : '';\n        var newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);\n        if (!aobj[newkey]) aobj[newkey] = aobj[keys[i]];\n      }\n\n      delete aobj[keys[i]];\n    }\n  } // initialize flags\n\n\n  var flags = editTypes.layoutFlags(); // copies of the change (and previous values of anything affected)\n  // for the undo / redo queue\n\n  var redoit = {};\n  var undoit = {}; // for attrs that interact (like scales & autoscales), save the\n  // old vals before making the change\n  // val=undefined will not set a value, just record what the value was.\n  // attr can be an array to set several at once (all to the same val)\n\n  function doextra(attr, val) {\n    if (Array.isArray(attr)) {\n      attr.forEach(function (a) {\n        doextra(a, val);\n      });\n      return;\n    } // if we have another value for this attribute (explicitly or\n    // via a parent) do not override with this auto-generated extra\n\n\n    if (attr in aobj || helpers.hasParent(aobj, attr)) return;\n    var p = layoutNP(layout, attr);\n\n    if (!(attr in undoit)) {\n      undoit[attr] = undefinedToNull(p.get());\n    }\n\n    if (val !== undefined) p.set(val);\n  } // for constraint enforcement: keep track of all axes (as {id: name})\n  // we're editing the (auto)range of, so we can tell the others constrained\n  // to scale with them that it's OK for them to shrink\n\n\n  var rangesAltered = {};\n  var ax;\n\n  function recordAlteredAxis(pleafPlus) {\n    var axId = Axes.name2id(pleafPlus.split('.')[0]);\n    rangesAltered[axId] = 1;\n    return axId;\n  } // alter gd.layout\n\n\n  for (var ai in aobj) {\n    if (helpers.hasParent(aobj, ai)) {\n      throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\n    }\n\n    var p = layoutNP(layout, ai);\n    var vi = aobj[ai];\n    var plen = p.parts.length; // p.parts may end with an index integer if the property is an array\n\n    var pend = plen - 1;\n\n    while (pend > 0 && typeof p.parts[pend] !== 'string') pend--; // last property in chain (leaf node)\n\n\n    var pleaf = p.parts[pend]; // leaf plus immediate parent\n\n    var pleafPlus = p.parts[pend - 1] + '.' + pleaf; // trunk nodes (everything except the leaf)\n\n    var ptrunk = p.parts.slice(0, pend).join('.');\n    var parentIn = nestedProperty(gd.layout, ptrunk).get();\n    var parentFull = nestedProperty(fullLayout, ptrunk).get();\n    var vOld = p.get();\n    if (vi === undefined) continue;\n    redoit[ai] = vi; // axis reverse is special - it is its own inverse\n    // op and has no flag.\n\n    undoit[ai] = pleaf === 'reverse' ? vi : undefinedToNull(vOld);\n    var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);\n\n    if (valObject && valObject.impliedEdits && vi !== null) {\n      for (var impliedKey in valObject.impliedEdits) {\n        doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);\n      }\n    } // Setting width or height to null must reset the graph's width / height\n    // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n    //\n    // To do so, we must manually set them back here using the _initialAutoSize cache.\n    // can't use impliedEdits for this because behavior depends on vi\n\n\n    if (['width', 'height'].indexOf(ai) !== -1) {\n      if (vi) {\n        doextra('autosize', null); // currently we don't support autosize one dim only - so\n        // explicitly set the other one. Note that doextra will\n        // ignore this if the same relayout call also provides oppositeAttr\n\n        var oppositeAttr = ai === 'height' ? 'width' : 'height';\n        doextra(oppositeAttr, fullLayout[oppositeAttr]);\n      } else {\n        fullLayout[ai] = gd._initialAutoSize[ai];\n      }\n    } else if (ai === 'autosize') {\n      // depends on vi here too, so again can't use impliedEdits\n      doextra('width', vi ? null : fullLayout.width);\n      doextra('height', vi ? null : fullLayout.height);\n    } else if (pleafPlus.match(AX_RANGE_RE)) {\n      // check autorange vs range\n      recordAlteredAxis(pleafPlus);\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n    } else if (pleafPlus.match(AX_AUTORANGE_RE)) {\n      recordAlteredAxis(pleafPlus);\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n      var axFull = nestedProperty(fullLayout, ptrunk).get();\n\n      if (axFull._inputDomain) {\n        // if we're autoranging and this axis has a constrained domain,\n        // reset it so we don't get locked into a shrunken size\n        axFull._input.domain = axFull._inputDomain.slice();\n      }\n    } else if (pleafPlus.match(AX_DOMAIN_RE)) {\n      nestedProperty(fullLayout, ptrunk + '._inputDomain').set(null);\n    } // toggling axis type between log and linear: we need to convert\n    // positions for components that are still using linearized values,\n    // not data values like newer components.\n    // previously we did this for log <-> not-log, but now only do it\n    // for log <-> linear\n\n\n    if (pleaf === 'type') {\n      ax = parentIn;\n      var toLog = parentFull.type === 'linear' && vi === 'log';\n      var fromLog = parentFull.type === 'log' && vi === 'linear';\n\n      if (toLog || fromLog) {\n        if (!ax || !ax.range) {\n          // 2D never gets here, but 3D does\n          // I don't think this is needed, but left here in case there\n          // are edge cases I'm not thinking of.\n          doextra(ptrunk + '.autorange', true);\n        } else if (!parentFull.autorange) {\n          // toggling log without autorange: need to also recalculate ranges\n          // because log axes use linearized values for range endpoints\n          var r0 = ax.range[0];\n          var r1 = ax.range[1];\n\n          if (toLog) {\n            // if both limits are negative, autorange\n            if (r0 <= 0 && r1 <= 0) {\n              doextra(ptrunk + '.autorange', true);\n            } // if one is negative, set it 6 orders below the other.\n\n\n            if (r0 <= 0) r0 = r1 / 1e6;else if (r1 <= 0) r1 = r0 / 1e6; // now set the range values as appropriate\n\n            doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);\n            doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);\n          } else {\n            doextra(ptrunk + '.range[0]', Math.pow(10, r0));\n            doextra(ptrunk + '.range[1]', Math.pow(10, r1));\n          }\n        } else if (toLog) {\n          // just make sure the range is positive and in the right\n          // order, it'll get recalculated later\n          ax.range = ax.range[1] > ax.range[0] ? [1, 2] : [2, 1];\n        } // clear polar view initial stash for radial range so that\n        // value get recomputed in correct units\n\n\n        if (Array.isArray(fullLayout._subplots.polar) && fullLayout._subplots.polar.length && fullLayout[p.parts[0]] && p.parts[1] === 'radialaxis') {\n          delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];\n        } // Annotations and images also need to convert to/from linearized coords\n        // Shapes do not need this :)\n\n\n        Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);\n        Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);\n      } else {\n        // any other type changes: the range from the previous type\n        // will not make sense, so autorange it.\n        doextra(ptrunk + '.autorange', true);\n        doextra(ptrunk + '.range', null);\n      }\n\n      nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\n    } else if (pleaf.match(AX_NAME_PATTERN)) {\n      var fullProp = nestedProperty(fullLayout, ai).get();\n      var newType = (vi || {}).type; // This can potentially cause strange behavior if the autotype is not\n      // numeric (linear, because we don't auto-log) but the previous type\n      // was log. That's a very strange edge case though\n\n      if (!newType || newType === '-') newType = 'linear';\n      Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);\n      Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);\n    } // alter gd.layout\n    // collect array component edits for execution all together\n    // so we can ensure consistent behavior adding/removing items\n    // and order-independence for add/remove/edit all together in\n    // one relayout call\n\n\n    var containerArrayMatch = manageArrays.containerArrayMatch(ai);\n\n    if (containerArrayMatch) {\n      arrayStr = containerArrayMatch.array;\n      i = containerArrayMatch.index;\n      var propStr = containerArrayMatch.property;\n      var updateValObject = valObject || {\n        editType: 'calc'\n      };\n\n      if (i !== '' && propStr === '') {\n        // special handling of undoit if we're adding or removing an element\n        // ie 'annotations[2]' which can be {...} (add) or null,\n        // does not work when replacing the entire array\n        if (manageArrays.isAddVal(vi)) {\n          undoit[ai] = null;\n        } else if (manageArrays.isRemoveVal(vi)) {\n          undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];\n        } else {\n          Lib.warn('unrecognized full object value', aobj);\n        }\n      }\n\n      editTypes.update(flags, updateValObject); // prepare the edits object we'll send to applyContainerArrayChanges\n\n      if (!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};\n      var objEdits = arrayEdits[arrayStr][i];\n      if (!objEdits) objEdits = arrayEdits[arrayStr][i] = {};\n      objEdits[propStr] = vi;\n      delete aobj[ai];\n    } else if (pleaf === 'reverse') {\n      // handle axis reversal explicitly, as there's no 'reverse' attribute\n      if (parentIn.range) parentIn.range.reverse();else {\n        doextra(ptrunk + '.autorange', true);\n        parentIn.range = [1, 0];\n      }\n      if (parentFull.autorange) flags.calc = true;else flags.plot = true;\n    } else {\n      if (fullLayout._has('scatter-like') && fullLayout._has('regl') && ai === 'dragmode' && (vi === 'lasso' || vi === 'select') && !(vOld === 'lasso' || vOld === 'select')) {\n        flags.plot = true;\n      } else if (fullLayout._has('gl2d')) {\n        flags.plot = true;\n      } else if (valObject) editTypes.update(flags, valObject);else flags.calc = true;\n\n      p.set(vi);\n    }\n  } // now we've collected component edits - execute them all together\n\n\n  for (arrayStr in arrayEdits) {\n    var finished = manageArrays.applyContainerArrayChanges(gd, layoutNP(layout, arrayStr), arrayEdits[arrayStr], flags, layoutNP);\n    if (!finished) flags.plot = true;\n  } // figure out if we need to recalculate axis constraints\n\n\n  for (var axId in rangesAltered) {\n    ax = Axes.getFromId(gd, axId);\n    var group = ax && ax._constraintGroup;\n\n    if (group) {\n      // Always recalc if we're changing constrained ranges.\n      // Otherwise it's possible to violate the constraints by\n      // specifying arbitrary ranges for all axes in the group.\n      // this way some ranges may expand beyond what's specified,\n      // as they do at first draw, to satisfy the constraints.\n      flags.calc = true;\n\n      for (var groupAxId in group) {\n        if (!rangesAltered[groupAxId]) {\n          Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;\n        }\n      }\n    }\n  } // If the autosize changed or height or width was explicitly specified,\n  // this triggers a redraw\n  // TODO: do we really need special aobj.height/width handling here?\n  // couldn't editType do this?\n\n\n  if (updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;\n\n  if (flags.plot || flags.calc) {\n    flags.layoutReplot = true;\n  } // now all attribute mods are done, as are\n  // redo and undo so we can save them\n\n\n  return {\n    flags: flags,\n    rangesAltered: rangesAltered,\n    undoit: undoit,\n    redoit: redoit,\n    eventData: eventData\n  };\n}\n/*\r\n * updateAutosize: we made a change, does it change the autosize result?\r\n * puts the new size into fullLayout\r\n * returns true if either height or width changed\r\n */\n\n\nfunction updateAutosize(gd) {\n  var fullLayout = gd._fullLayout;\n  var oldWidth = fullLayout.width;\n  var oldHeight = fullLayout.height; // calculate autosizing\n\n  if (gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);\n  return fullLayout.width !== oldWidth || fullLayout.height !== oldHeight;\n}\n/**\r\n * update: update trace and layout attributes of an existing plot\r\n *\r\n * @param {String | HTMLDivElement} gd\r\n *  the id or DOM element of the graph container div\r\n * @param {Object} traceUpdate\r\n *  attribute object `{astr1: val1, astr2: val2 ...}`\r\n *  corresponding to updates in the plot's traces\r\n * @param {Object} layoutUpdate\r\n *  attribute object `{astr1: val1, astr2: val2 ...}`\r\n *  corresponding to updates in the plot's layout\r\n * @param {Number[] | Number} [traces]\r\n *  integer or array of integers for the traces to alter (all if omitted)\r\n *\r\n */\n\n\nfunction update(gd, traceUpdate, layoutUpdate, _traces) {\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  if (!Lib.isPlainObject(traceUpdate)) traceUpdate = {};\n  if (!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};\n  if (Object.keys(traceUpdate).length) gd.changed = true;\n  if (Object.keys(layoutUpdate).length) gd.changed = true;\n  var traces = helpers.coerceTraceIndices(gd, _traces);\n\n  var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);\n\n  var restyleFlags = restyleSpecs.flags;\n\n  var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));\n\n  var relayoutFlags = relayoutSpecs.flags; // clear calcdata and/or axis types if required\n\n  if (restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\n  if (restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate); // fill in redraw sequence\n\n  var seq = [];\n\n  if (relayoutFlags.layoutReplot) {\n    // N.B. works fine when both\n    // relayoutFlags.layoutReplot and restyleFlags.fullReplot are true\n    seq.push(subroutines.layoutReplot);\n  } else if (restyleFlags.fullReplot) {\n    seq.push(exports._doPlot);\n  } else {\n    seq.push(Plots.previousPromises);\n    axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);\n    if (restyleFlags.style) seq.push(subroutines.doTraceStyle);\n    if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n    if (relayoutFlags.legend) seq.push(subroutines.doLegend);\n    if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n    if (relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);\n    if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n    if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n    if (relayoutFlags.camera) seq.push(subroutines.doCamera);\n    seq.push(emitAfterPlot);\n  }\n\n  seq.push(Plots.rehover, Plots.redrag);\n  Queue.add(gd, update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces], update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]);\n  var plotDone = Lib.syncOrAsync(seq, gd);\n  if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  return plotDone.then(function () {\n    gd.emit('plotly_update', {\n      data: restyleSpecs.eventData,\n      layout: relayoutSpecs.eventData\n    });\n    return gd;\n  });\n}\n/*\r\n * internal-use-only restyle/relayout/update variants that record the initial\r\n * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across\r\n * Plotly.react data updates, dependent on uirevision attributes\r\n */\n\n\nfunction guiEdit(func) {\n  return function wrappedEdit(gd) {\n    gd._fullLayout._guiEditing = true;\n    var p = func.apply(null, arguments);\n    gd._fullLayout._guiEditing = false;\n    return p;\n  };\n} // For connecting edited layout attributes to uirevision attrs\n// If no `attr` we use `match[1] + '.uirevision'`\n// Ordered by most common edits first, to minimize our search time\n\n\nvar layoutUIControlPatterns = [{\n  pattern: /^hiddenlabels/,\n  attr: 'legend.uirevision'\n}, {\n  pattern: /^((x|y)axis\\d*)\\.((auto)?range|title\\.text)/\n}, // showspikes and modes include those nested inside scenes\n{\n  pattern: /axis\\d*\\.showspikes$/,\n  attr: 'modebar.uirevision'\n}, {\n  pattern: /(hover|drag)mode$/,\n  attr: 'modebar.uirevision'\n}, {\n  pattern: /^(scene\\d*)\\.camera/\n}, {\n  pattern: /^(geo\\d*)\\.(projection|center|fitbounds)/\n}, {\n  pattern: /^(ternary\\d*\\.[abc]axis)\\.(min|title\\.text)$/\n}, {\n  pattern: /^(polar\\d*\\.radialaxis)\\.((auto)?range|angle|title\\.text)/\n}, {\n  pattern: /^(polar\\d*\\.angularaxis)\\.rotation/\n}, {\n  pattern: /^(mapbox\\d*)\\.(center|zoom|bearing|pitch)/\n}, {\n  pattern: /^legend\\.(x|y)$/,\n  attr: 'editrevision'\n}, {\n  pattern: /^(shapes|annotations)/,\n  attr: 'editrevision'\n}, {\n  pattern: /^title\\.text$/,\n  attr: 'editrevision'\n}]; // same for trace attributes: if `attr` is given it's in layout,\n// or with no `attr` we use `trace.uirevision`\n\nvar traceUIControlPatterns = [{\n  pattern: /^selectedpoints$/,\n  attr: 'selectionrevision'\n}, // \"visible\" includes trace.transforms[i].styles[j].value.visible\n{\n  pattern: /(^|value\\.)visible$/,\n  attr: 'legend.uirevision'\n}, {\n  pattern: /^dimensions\\[\\d+\\]\\.constraintrange/\n}, {\n  pattern: /^node\\.(x|y|groups)/\n}, // for Sankey nodes\n{\n  pattern: /^level$/\n}, // for Sunburst, Treemap and Icicle traces\n// below this you must be in editable: true mode\n// TODO: I still put name and title with `trace.uirevision`\n// reasonable or should these be `editrevision`?\n// Also applies to axis titles up in the layout section\n// \"name\" also includes transform.styles\n{\n  pattern: /(^|value\\.)name$/\n}, // including nested colorbar attributes (ie marker.colorbar)\n{\n  pattern: /colorbar\\.title\\.text$/\n}, {\n  pattern: /colorbar\\.(x|y)$/,\n  attr: 'editrevision'\n}];\n\nfunction findUIPattern(key, patternSpecs) {\n  for (var i = 0; i < patternSpecs.length; i++) {\n    var spec = patternSpecs[i];\n    var match = key.match(spec.pattern);\n\n    if (match) {\n      return {\n        head: match[1],\n        attr: spec.attr\n      };\n    }\n  }\n} // We're finding the new uirevision before supplyDefaults, so do the\n// inheritance manually. Note that only `undefined` inherits - other\n// falsy values are returned.\n\n\nfunction getNewRev(revAttr, container) {\n  var newRev = nestedProperty(container, revAttr).get();\n  if (newRev !== undefined) return newRev;\n  var parts = revAttr.split('.');\n  parts.pop();\n\n  while (parts.length > 1) {\n    parts.pop();\n    newRev = nestedProperty(container, parts.join('.') + '.uirevision').get();\n    if (newRev !== undefined) return newRev;\n  }\n\n  return container.uirevision;\n}\n\nfunction getFullTraceIndexFromUid(uid, fullData) {\n  for (var i = 0; i < fullData.length; i++) {\n    if (fullData[i]._fullInput.uid === uid) return i;\n  }\n\n  return -1;\n}\n\nfunction getTraceIndexFromUid(uid, data, tracei) {\n  for (var i = 0; i < data.length; i++) {\n    if (data[i].uid === uid) return i;\n  } // fall back on trace order, but only if user didn't provide a uid for that trace\n\n\n  return !data[tracei] || data[tracei].uid ? -1 : tracei;\n}\n\nfunction valsMatch(v1, v2) {\n  var v1IsObj = Lib.isPlainObject(v1);\n  var v1IsArray = Array.isArray(v1);\n\n  if (v1IsObj || v1IsArray) {\n    return (v1IsObj && Lib.isPlainObject(v2) || v1IsArray && Array.isArray(v2)) && JSON.stringify(v1) === JSON.stringify(v2);\n  }\n\n  return v1 === v2;\n}\n\nfunction applyUIRevisions(data, layout, oldFullData, oldFullLayout) {\n  var layoutPreGUI = oldFullLayout._preGUI;\n  var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal;\n  var bothInheritAutorange = [];\n  var newRangeAccepted = {};\n\n  for (key in layoutPreGUI) {\n    match = findUIPattern(key, layoutUIControlPatterns);\n\n    if (match) {\n      revAttr = match.attr || match.head + '.uirevision';\n      oldRev = nestedProperty(oldFullLayout, revAttr).get();\n      newRev = oldRev && getNewRev(revAttr, layout);\n\n      if (newRev && newRev === oldRev) {\n        preGUIVal = layoutPreGUI[key];\n        if (preGUIVal === null) preGUIVal = undefined;\n        newNP = nestedProperty(layout, key);\n        newVal = newNP.get();\n\n        if (valsMatch(newVal, preGUIVal)) {\n          if (newVal === undefined && key.substr(key.length - 9) === 'autorange') {\n            bothInheritAutorange.push(key.substr(0, key.length - 10));\n          }\n\n          newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\n          continue;\n        }\n      }\n    } else {\n      Lib.warn('unrecognized GUI edit: ' + key);\n    } // if we got this far, the new value was accepted as the new starting\n    // point (either because it changed or revision changed)\n    // so remove it from _preGUI for next time.\n\n\n    delete layoutPreGUI[key];\n\n    if (key.substr(key.length - 8, 6) === 'range[') {\n      newRangeAccepted[key.substr(0, key.length - 9)] = 1;\n    }\n  } // Special logic for `autorange`, since it interacts with `range`:\n  // If the new figure's matching `range` was kept, and `autorange`\n  // wasn't supplied explicitly in either the original or the new figure,\n  // we shouldn't alter that - but we may just have done that, so fix it.\n\n\n  for (var i = 0; i < bothInheritAutorange.length; i++) {\n    var axAttr = bothInheritAutorange[i];\n\n    if (newRangeAccepted[axAttr]) {\n      var newAx = nestedProperty(layout, axAttr).get();\n      if (newAx) delete newAx.autorange;\n    }\n  } // Now traces - try to match them up by uid (in case we added/deleted in\n  // the middle), then fall back on index.\n\n\n  var allTracePreGUI = oldFullLayout._tracePreGUI;\n\n  for (var uid in allTracePreGUI) {\n    var tracePreGUI = allTracePreGUI[uid];\n    var newTrace = null;\n    var fullInput;\n\n    for (key in tracePreGUI) {\n      // wait until we know we have preGUI values to look for traces\n      // but if we don't find both, stop looking at this uid\n      if (!newTrace) {\n        var fulli = getFullTraceIndexFromUid(uid, oldFullData);\n\n        if (fulli < 0) {\n          // Somehow we didn't even have this trace in oldFullData...\n          // I guess this could happen with `deleteTraces` or something\n          delete allTracePreGUI[uid];\n          break;\n        }\n\n        var fullTrace = oldFullData[fulli];\n        fullInput = fullTrace._fullInput;\n        var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);\n\n        if (newTracei < 0) {\n          // No match in new data\n          delete allTracePreGUI[uid];\n          break;\n        }\n\n        newTrace = data[newTracei];\n      }\n\n      match = findUIPattern(key, traceUIControlPatterns);\n\n      if (match) {\n        if (match.attr) {\n          oldRev = nestedProperty(oldFullLayout, match.attr).get();\n          newRev = oldRev && getNewRev(match.attr, layout);\n        } else {\n          oldRev = fullInput.uirevision; // inheritance for trace.uirevision is simple, just layout.uirevision\n\n          newRev = newTrace.uirevision;\n          if (newRev === undefined) newRev = layout.uirevision;\n        }\n\n        if (newRev && newRev === oldRev) {\n          preGUIVal = tracePreGUI[key];\n          if (preGUIVal === null) preGUIVal = undefined;\n          newNP = nestedProperty(newTrace, key);\n          newVal = newNP.get();\n\n          if (valsMatch(newVal, preGUIVal)) {\n            newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));\n            continue;\n          }\n        }\n      } else {\n        Lib.warn('unrecognized GUI edit: ' + key + ' in trace uid ' + uid);\n      }\n\n      delete tracePreGUI[key];\n    }\n  }\n}\n/**\r\n * Plotly.react:\r\n * A plot/update method that takes the full plot state (same API as plot/newPlot)\r\n * and diffs to determine the minimal update pathway\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n * @param {array of objects} data\r\n *      array of traces, containing the data and display information for each trace\r\n * @param {object} layout\r\n *      object describing the overall display of the plot,\r\n *      all the stuff that doesn't pertain to any individual trace\r\n * @param {object} config\r\n *      configuration options (see ./plot_config.js for more info)\r\n *\r\n * OR\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n * @param {object} figure\r\n *      object containing `data`, `layout`, `config`, and `frames` members\r\n *\r\n */\n\n\nfunction react(gd, data, layout, config) {\n  var frames, plotDone;\n\n  function addFrames() {\n    return exports.addFrames(gd, frames);\n  }\n\n  gd = Lib.getGraphDiv(gd);\n  helpers.clearPromiseQueue(gd);\n  var oldFullData = gd._fullData;\n  var oldFullLayout = gd._fullLayout; // you can use this as the initial draw as well as to update\n\n  if (!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {\n    plotDone = exports.newPlot(gd, data, layout, config);\n  } else {\n    if (Lib.isPlainObject(data)) {\n      var obj = data;\n      data = obj.data;\n      layout = obj.layout;\n      config = obj.config;\n      frames = obj.frames;\n    }\n\n    var configChanged = false; // assume that if there's a config at all, we're reacting to it too,\n    // and completely replace the previous config\n\n    if (config) {\n      var oldConfig = Lib.extendDeep({}, gd._context);\n      gd._context = undefined;\n      setPlotContext(gd, config);\n      configChanged = diffConfig(oldConfig, gd._context);\n    }\n\n    gd.data = data || [];\n    helpers.cleanData(gd.data);\n    gd.layout = layout || {};\n    helpers.cleanLayout(gd.layout);\n    applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout); // \"true\" skips updating calcdata and remapping arrays from calcTransforms,\n    // which supplyDefaults usually does at the end, but we may need to NOT do\n    // if the diff (which we haven't determined yet) says we'll recalc\n\n    Plots.supplyDefaults(gd, {\n      skipUpdateCalc: true\n    });\n    var newFullData = gd._fullData;\n    var newFullLayout = gd._fullLayout;\n    var immutable = newFullLayout.datarevision === undefined;\n    var transition = newFullLayout.transition;\n    var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);\n    var newDataRevision = relayoutFlags.newDataRevision;\n    var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision); // TODO: how to translate this part of relayout to Plotly.react?\n    // // Setting width or height to null must reset the graph's width / height\n    // // back to its initial value as computed during the first pass in Plots.plotAutoSize.\n    // //\n    // // To do so, we must manually set them back here using the _initialAutoSize cache.\n    // if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\n    //     fullLayout[ai] = gd._initialAutoSize[ai];\n    // }\n\n    if (updateAutosize(gd)) relayoutFlags.layoutReplot = true; // clear calcdata and empty categories if required\n\n    if (restyleFlags.calc || relayoutFlags.calc) {\n      gd.calcdata = undefined;\n      var allNames = Object.getOwnPropertyNames(newFullLayout);\n\n      for (var q = 0; q < allNames.length; q++) {\n        var name = allNames[q];\n        var start = name.substring(0, 5);\n\n        if (start === 'xaxis' || start === 'yaxis') {\n          var emptyCategories = newFullLayout[name]._emptyCategories;\n          if (emptyCategories) emptyCategories();\n        }\n      } // otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier\n\n    } else {\n      Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData);\n    } // Note: what restyle/relayout use impliedEdits and clearAxisTypes for\n    // must be handled by the user when using Plotly.react.\n    // fill in redraw sequence\n\n\n    var seq = [];\n\n    if (frames) {\n      gd._transitionData = {};\n      Plots.createTransitionData(gd);\n      seq.push(addFrames);\n    } // Transition pathway,\n    // only used when 'transition' is set by user and\n    // when at least one animatable attribute has changed,\n    // N.B. config changed aren't animatable\n\n\n    if (newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {\n      if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n      Plots.doCalcdata(gd);\n      subroutines.doAutoRangeAndConstraints(gd);\n      seq.push(function () {\n        return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);\n      });\n    } else if (restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {\n      gd._fullLayout._skipDefaults = true;\n      seq.push(exports._doPlot);\n    } else {\n      for (var componentType in relayoutFlags.arrays) {\n        var indices = relayoutFlags.arrays[componentType];\n\n        if (indices.length) {\n          var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\n\n          if (drawOne !== Lib.noop) {\n            for (var i = 0; i < indices.length; i++) {\n              drawOne(gd, indices[i]);\n            }\n          } else {\n            var draw = Registry.getComponentMethod(componentType, 'draw');\n\n            if (draw === Lib.noop) {\n              throw new Error('cannot draw components: ' + componentType);\n            }\n\n            draw(gd);\n          }\n        }\n      }\n\n      seq.push(Plots.previousPromises);\n      if (restyleFlags.style) seq.push(subroutines.doTraceStyle);\n      if (restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\n      if (relayoutFlags.legend) seq.push(subroutines.doLegend);\n      if (relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\n      if (relayoutFlags.axrange) addAxRangeSequence(seq);\n      if (relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\n      if (relayoutFlags.modebar) seq.push(subroutines.doModeBar);\n      if (relayoutFlags.camera) seq.push(subroutines.doCamera);\n      seq.push(emitAfterPlot);\n    }\n\n    seq.push(Plots.rehover, Plots.redrag);\n    plotDone = Lib.syncOrAsync(seq, gd);\n    if (!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\n  }\n\n  return plotDone.then(function () {\n    gd.emit('plotly_react', {\n      data: data,\n      layout: layout\n    });\n    return gd;\n  });\n}\n\nfunction diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {\n  var sameTraceLength = oldFullData.length === newFullData.length;\n\n  if (!transition && !sameTraceLength) {\n    return {\n      fullReplot: true,\n      calc: true\n    };\n  }\n\n  var flags = editTypes.traceFlags();\n  flags.arrays = {};\n  flags.nChanges = 0;\n  flags.nChangesAnim = 0;\n  var i, trace;\n\n  function getTraceValObject(parts) {\n    var out = PlotSchema.getTraceValObject(trace, parts);\n\n    if (!trace._module.animatable && out.anim) {\n      out.anim = false;\n    }\n\n    return out;\n  }\n\n  var diffOpts = {\n    getValObject: getTraceValObject,\n    flags: flags,\n    immutable: immutable,\n    transition: transition,\n    newDataRevision: newDataRevision,\n    gd: gd\n  };\n  var seenUIDs = {};\n\n  for (i = 0; i < oldFullData.length; i++) {\n    if (newFullData[i]) {\n      trace = newFullData[i]._fullInput;\n      if (Plots.hasMakesDataTransform(trace)) trace = newFullData[i];\n      if (seenUIDs[trace.uid]) continue;\n      seenUIDs[trace.uid] = 1;\n      getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);\n    }\n  }\n\n  if (flags.calc || flags.plot) {\n    flags.fullReplot = true;\n  }\n\n  if (transition && flags.nChanges && flags.nChangesAnim) {\n    flags.anim = flags.nChanges === flags.nChangesAnim && sameTraceLength ? 'all' : 'some';\n  }\n\n  return flags;\n}\n\nfunction diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {\n  var flags = editTypes.layoutFlags();\n  flags.arrays = {};\n  flags.rangesAltered = {};\n  flags.nChanges = 0;\n  flags.nChangesAnim = 0;\n\n  function getLayoutValObject(parts) {\n    return PlotSchema.getLayoutValObject(newFullLayout, parts);\n  }\n\n  var diffOpts = {\n    getValObject: getLayoutValObject,\n    flags: flags,\n    immutable: immutable,\n    transition: transition,\n    gd: gd\n  };\n  getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);\n\n  if (flags.plot || flags.calc) {\n    flags.layoutReplot = true;\n  }\n\n  if (transition && flags.nChanges && flags.nChangesAnim) {\n    flags.anim = flags.nChanges === flags.nChangesAnim ? 'all' : 'some';\n  }\n\n  return flags;\n}\n\nfunction getDiffFlags(oldContainer, newContainer, outerparts, opts) {\n  var valObject, key, astr;\n  var getValObject = opts.getValObject;\n  var flags = opts.flags;\n  var immutable = opts.immutable;\n  var inArray = opts.inArray;\n  var arrayIndex = opts.arrayIndex;\n\n  function changed() {\n    var editType = valObject.editType;\n\n    if (inArray && editType.indexOf('arraydraw') !== -1) {\n      Lib.pushUnique(flags.arrays[inArray], arrayIndex);\n      return;\n    }\n\n    editTypes.update(flags, valObject);\n\n    if (editType !== 'none') {\n      flags.nChanges++;\n    } // track animatable changes\n\n\n    if (opts.transition && valObject.anim) {\n      flags.nChangesAnim++;\n    } // track cartesian axes with altered ranges\n\n\n    if (AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {\n      flags.rangesAltered[outerparts[0]] = 1;\n    } // clear _inputDomain on cartesian axes with altered domains\n\n\n    if (AX_DOMAIN_RE.test(astr)) {\n      nestedProperty(newContainer, '_inputDomain').set(null);\n    } // track datarevision changes\n\n\n    if (key === 'datarevision') {\n      flags.newDataRevision = 1;\n    }\n  }\n\n  function valObjectCanBeDataArray(valObject) {\n    return valObject.valType === 'data_array' || valObject.arrayOk;\n  }\n\n  for (key in oldContainer) {\n    // short-circuit based on previous calls or previous keys that already maximized the pathway\n    if (flags.calc && !opts.transition) return;\n    var oldVal = oldContainer[key];\n    var newVal = newContainer[key];\n    var parts = outerparts.concat(key);\n    astr = parts.join('.');\n    if (key.charAt(0) === '_' || typeof oldVal === 'function' || oldVal === newVal) continue; // FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),\n    // and unlike other auto values they don't make it back into the input,\n    // so newContainer won't have them.\n\n    if ((key === 'tick0' || key === 'dtick') && outerparts[0] !== 'geo') {\n      var tickMode = newContainer.tickmode;\n      if (tickMode === 'auto' || tickMode === 'array' || !tickMode) continue;\n    } // FIXME: Similarly for axis ranges for 3D\n    // contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.\n\n\n    if (key === 'range' && newContainer.autorange) continue;\n    if ((key === 'zmin' || key === 'zmax') && newContainer.type === 'contourcarpet') continue;\n    valObject = getValObject(parts); // in case type changed, we may not even *have* a valObject.\n\n    if (!valObject) continue;\n    if (valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;\n    var valType = valObject.valType;\n    var i;\n    var canBeDataArray = valObjectCanBeDataArray(valObject);\n    var wasArray = Array.isArray(oldVal);\n    var nowArray = Array.isArray(newVal); // hack for traces that modify the data in supplyDefaults, like\n    // converting 1D to 2D arrays, which will always create new objects\n\n    if (wasArray && nowArray) {\n      var inputKey = '_input_' + key;\n      var oldValIn = oldContainer[inputKey];\n      var newValIn = newContainer[inputKey];\n      if (Array.isArray(oldValIn) && oldValIn === newValIn) continue;\n    }\n\n    if (newVal === undefined) {\n      if (canBeDataArray && wasArray) flags.calc = true;else changed();\n    } else if (valObject._isLinkedToArray) {\n      var arrayEditIndices = [];\n      var extraIndices = false;\n      if (!inArray) flags.arrays[key] = arrayEditIndices;\n      var minLen = Math.min(oldVal.length, newVal.length);\n      var maxLen = Math.max(oldVal.length, newVal.length);\n\n      if (minLen !== maxLen) {\n        if (valObject.editType === 'arraydraw') {\n          extraIndices = true;\n        } else {\n          changed();\n          continue;\n        }\n      }\n\n      for (i = 0; i < minLen; i++) {\n        getDiffFlags(oldVal[i], newVal[i], parts.concat(i), // add array indices, but not if we're already in an array\n        Lib.extendFlat({\n          inArray: key,\n          arrayIndex: i\n        }, opts));\n      } // put this at the end so that we know our collected array indices are sorted\n      // but the check for length changes happens up front so we can short-circuit\n      // diffing if appropriate\n\n\n      if (extraIndices) {\n        for (i = minLen; i < maxLen; i++) {\n          arrayEditIndices.push(i);\n        }\n      }\n    } else if (!valType && Lib.isPlainObject(oldVal)) {\n      getDiffFlags(oldVal, newVal, parts, opts);\n    } else if (canBeDataArray) {\n      if (wasArray && nowArray) {\n        // don't try to diff two data arrays. If immutable we know the data changed,\n        // if not, assume it didn't and let `layout.datarevision` tell us if it did\n        if (immutable) {\n          flags.calc = true;\n        } // look for animatable attributes when the data changed\n\n\n        if (immutable || opts.newDataRevision) {\n          changed();\n        }\n      } else if (wasArray !== nowArray) {\n        flags.calc = true;\n      } else changed();\n    } else if (wasArray && nowArray) {\n      // info array, colorscale, 'any' - these are short, just stringify.\n      // I don't *think* that covers up any real differences post-validation, does it?\n      // otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare\n      // all elements.\n      if (oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {\n        changed();\n      }\n    } else {\n      changed();\n    }\n  }\n\n  for (key in newContainer) {\n    if (!(key in oldContainer || key.charAt(0) === '_' || typeof newContainer[key] === 'function')) {\n      valObject = getValObject(outerparts.concat(key));\n\n      if (valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {\n        flags.calc = true;\n        return;\n      } else changed();\n    }\n  }\n}\n/*\r\n * simple diff for config - for now, just treat all changes as equivalent\r\n */\n\n\nfunction diffConfig(oldConfig, newConfig) {\n  var key;\n\n  for (key in oldConfig) {\n    if (key.charAt(0) === '_') continue;\n    var oldVal = oldConfig[key];\n    var newVal = newConfig[key];\n\n    if (oldVal !== newVal) {\n      if (Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {\n        if (diffConfig(oldVal, newVal)) {\n          return true;\n        }\n      } else if (Array.isArray(oldVal) && Array.isArray(newVal)) {\n        if (oldVal.length !== newVal.length) {\n          return true;\n        }\n\n        for (var i = 0; i < oldVal.length; i++) {\n          if (oldVal[i] !== newVal[i]) {\n            if (Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {\n              if (diffConfig(oldVal[i], newVal[i])) {\n                return true;\n              }\n            } else {\n              return true;\n            }\n          }\n        }\n      } else {\n        return true;\n      }\n    }\n  }\n}\n/**\r\n * Animate to a frame, sequence of frame, frame group, or frame definition\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n *\r\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\r\n *      a single frame, array of frames, or group to which to animate. The intent is\r\n *      inferred by the type of the input. Valid inputs are:\r\n *\r\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\r\n *            in which they are defined via `Plotly.addFrames`.\r\n *\r\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\r\n *            to animate in sequence\r\n *\r\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\r\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\r\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\r\n *            frame is used as provided and does not use the `baseframe` property.\r\n *\r\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\r\n *            each following the same rules as a single `object`.\r\n *\r\n * @param {object} animationOpts\r\n *      configuration for the animation\r\n */\n\n\nfunction animate(gd, frameOrGroupNameOrFrameList, animationOpts) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' + 'to create a plot before animating it. For more details, see ' + 'https://plotly.com/javascript/animations/');\n  }\n\n  var trans = gd._transitionData; // This is the queue of frames that will be animated as soon as possible. They\n  // are popped immediately upon the *start* of a transition:\n\n  if (!trans._frameQueue) {\n    trans._frameQueue = [];\n  }\n\n  animationOpts = Plots.supplyAnimationDefaults(animationOpts);\n  var transitionOpts = animationOpts.transition;\n  var frameOpts = animationOpts.frame; // Since frames are popped immediately, an empty queue only means all frames have\n  // *started* to transition, not that the animation is complete. To solve that,\n  // track a separate counter that increments at the same time as frames are added\n  // to the queue, but decrements only when the transition is complete.\n\n  if (trans._frameWaitingCnt === undefined) {\n    trans._frameWaitingCnt = 0;\n  }\n\n  function getTransitionOpts(i) {\n    if (Array.isArray(transitionOpts)) {\n      if (i >= transitionOpts.length) {\n        return transitionOpts[0];\n      } else {\n        return transitionOpts[i];\n      }\n    } else {\n      return transitionOpts;\n    }\n  }\n\n  function getFrameOpts(i) {\n    if (Array.isArray(frameOpts)) {\n      if (i >= frameOpts.length) {\n        return frameOpts[0];\n      } else {\n        return frameOpts[i];\n      }\n    } else {\n      return frameOpts;\n    }\n  } // Execute a callback after the wrapper function has been called n times.\n  // This is used to defer the resolution until a transition has resolved *and*\n  // the frame has completed. If it's not done this way, then we get a race\n  // condition in which the animation might resolve before a transition is complete\n  // or vice versa.\n\n\n  function callbackOnNthTime(cb, n) {\n    var cnt = 0;\n    return function () {\n      if (cb && ++cnt === n) {\n        return cb();\n      }\n    };\n  }\n\n  return new Promise(function (resolve, reject) {\n    function discardExistingFrames() {\n      if (trans._frameQueue.length === 0) {\n        return;\n      }\n\n      while (trans._frameQueue.length) {\n        var next = trans._frameQueue.pop();\n\n        if (next.onInterrupt) {\n          next.onInterrupt();\n        }\n      }\n\n      gd.emit('plotly_animationinterrupted', []);\n    }\n\n    function queueFrames(frameList) {\n      if (frameList.length === 0) return;\n\n      for (var i = 0; i < frameList.length; i++) {\n        var computedFrame;\n\n        if (frameList[i].type === 'byname') {\n          // If it's a named frame, compute it:\n          computedFrame = Plots.computeFrame(gd, frameList[i].name);\n        } else {\n          // Otherwise we must have been given a simple object, so treat\n          // the input itself as the computed frame.\n          computedFrame = frameList[i].data;\n        }\n\n        var frameOpts = getFrameOpts(i);\n        var transitionOpts = getTransitionOpts(i); // It doesn't make much sense for the transition duration to be greater than\n        // the frame duration, so limit it:\n\n        transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);\n        var nextFrame = {\n          frame: computedFrame,\n          name: frameList[i].name,\n          frameOpts: frameOpts,\n          transitionOpts: transitionOpts\n        };\n\n        if (i === frameList.length - 1) {\n          // The last frame in this .animate call stores the promise resolve\n          // and reject callbacks. This is how we ensure that the animation\n          // loop (which may exist as a result of a *different* .animate call)\n          // still resolves or rejecdts this .animate call's promise. once it's\n          // complete.\n          nextFrame.onComplete = callbackOnNthTime(resolve, 2);\n          nextFrame.onInterrupt = reject;\n        }\n\n        trans._frameQueue.push(nextFrame);\n      } // Set it as never having transitioned to a frame. This will cause the animation\n      // loop to immediately transition to the next frame (which, for immediate mode,\n      // is the first frame in the list since all others would have been discarded\n      // below)\n\n\n      if (animationOpts.mode === 'immediate') {\n        trans._lastFrameAt = -Infinity;\n      } // Only it's not already running, start a RAF loop. This could be avoided in the\n      // case that there's only one frame, but it significantly complicated the logic\n      // and only sped things up by about 5% or so for a lorenz attractor simulation.\n      // It would be a fine thing to implement, but the benefit of that optimization\n      // doesn't seem worth the extra complexity.\n\n\n      if (!trans._animationRaf) {\n        beginAnimationLoop();\n      }\n    }\n\n    function stopAnimationLoop() {\n      gd.emit('plotly_animated'); // Be sure to unset also since it's how we know whether a loop is already running:\n\n      window.cancelAnimationFrame(trans._animationRaf);\n      trans._animationRaf = null;\n    }\n\n    function nextFrame() {\n      if (trans._currentFrame && trans._currentFrame.onComplete) {\n        // Execute the callback and unset it to ensure it doesn't\n        // accidentally get called twice\n        trans._currentFrame.onComplete();\n      }\n\n      var newFrame = trans._currentFrame = trans._frameQueue.shift();\n\n      if (newFrame) {\n        // Since it's sometimes necessary to do deep digging into frame data,\n        // we'll consider it not 100% impossible for nulls or numbers to sneak through,\n        // so check when casting the name, just to be absolutely certain:\n        var stringName = newFrame.name ? newFrame.name.toString() : null;\n        gd._fullLayout._currentFrame = stringName;\n        trans._lastFrameAt = Date.now();\n        trans._timeToNext = newFrame.frameOpts.duration; // This is simply called and it's left to .transition to decide how to manage\n        // interrupting current transitions. That means we don't need to worry about\n        // how it resolves or what happens after this:\n\n        Plots.transition(gd, newFrame.frame.data, newFrame.frame.layout, helpers.coerceTraceIndices(gd, newFrame.frame.traces), newFrame.frameOpts, newFrame.transitionOpts).then(function () {\n          if (newFrame.onComplete) {\n            newFrame.onComplete();\n          }\n        });\n        gd.emit('plotly_animatingframe', {\n          name: stringName,\n          frame: newFrame.frame,\n          animation: {\n            frame: newFrame.frameOpts,\n            transition: newFrame.transitionOpts\n          }\n        });\n      } else {\n        // If there are no more frames, then stop the RAF loop:\n        stopAnimationLoop();\n      }\n    }\n\n    function beginAnimationLoop() {\n      gd.emit('plotly_animating'); // If no timer is running, then set last frame = long ago so that the next\n      // frame is immediately transitioned:\n\n      trans._lastFrameAt = -Infinity;\n      trans._timeToNext = 0;\n      trans._runningTransitions = 0;\n      trans._currentFrame = null;\n\n      var doFrame = function () {\n        // This *must* be requested before nextFrame since nextFrame may decide\n        // to cancel it if there's nothing more to animated:\n        trans._animationRaf = window.requestAnimationFrame(doFrame); // Check if we're ready for a new frame:\n\n        if (Date.now() - trans._lastFrameAt > trans._timeToNext) {\n          nextFrame();\n        }\n      };\n\n      doFrame();\n    } // This is an animate-local counter that helps match up option input list\n    // items with the particular frame.\n\n\n    var configCounter = 0;\n\n    function setTransitionConfig(frame) {\n      if (Array.isArray(transitionOpts)) {\n        if (configCounter >= transitionOpts.length) {\n          frame.transitionOpts = transitionOpts[configCounter];\n        } else {\n          frame.transitionOpts = transitionOpts[0];\n        }\n      } else {\n        frame.transitionOpts = transitionOpts;\n      }\n\n      configCounter++;\n      return frame;\n    } // Disambiguate what's sort of frames have been received\n\n\n    var i, frame;\n    var frameList = [];\n    var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;\n    var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);\n    var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);\n\n    if (isSingleFrame) {\n      // In this case, a simple object has been passed to animate.\n      frameList.push({\n        type: 'object',\n        data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))\n      });\n    } else if (allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {\n      // In this case, null or undefined has been passed so that we want to\n      // animate *all* currently defined frames\n      for (i = 0; i < trans._frames.length; i++) {\n        frame = trans._frames[i];\n        if (!frame) continue;\n\n        if (allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {\n          frameList.push({\n            type: 'byname',\n            name: String(frame.name),\n            data: setTransitionConfig({\n              name: frame.name\n            })\n          });\n        }\n      }\n    } else if (isFrameArray) {\n      for (i = 0; i < frameOrGroupNameOrFrameList.length; i++) {\n        var frameOrName = frameOrGroupNameOrFrameList[i];\n\n        if (['number', 'string'].indexOf(typeof frameOrName) !== -1) {\n          frameOrName = String(frameOrName); // In this case, there's an array and this frame is a string name:\n\n          frameList.push({\n            type: 'byname',\n            name: frameOrName,\n            data: setTransitionConfig({\n              name: frameOrName\n            })\n          });\n        } else if (Lib.isPlainObject(frameOrName)) {\n          frameList.push({\n            type: 'object',\n            data: setTransitionConfig(Lib.extendFlat({}, frameOrName))\n          });\n        }\n      }\n    } // Verify that all of these frames actually exist; return and reject if not:\n\n\n    for (i = 0; i < frameList.length; i++) {\n      frame = frameList[i];\n\n      if (frame.type === 'byname' && !trans._frameHash[frame.data.name]) {\n        Lib.warn('animate failure: frame not found: \"' + frame.data.name + '\"');\n        reject();\n        return;\n      }\n    } // If the mode is either next or immediate, then all currently queued frames must\n    // be dumped and the corresponding .animate promises rejected.\n\n\n    if (['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {\n      discardExistingFrames();\n    }\n\n    if (animationOpts.direction === 'reverse') {\n      frameList.reverse();\n    }\n\n    var currentFrame = gd._fullLayout._currentFrame;\n\n    if (currentFrame && animationOpts.fromcurrent) {\n      var idx = -1;\n\n      for (i = 0; i < frameList.length; i++) {\n        frame = frameList[i];\n\n        if (frame.type === 'byname' && frame.name === currentFrame) {\n          idx = i;\n          break;\n        }\n      }\n\n      if (idx > 0 && idx < frameList.length - 1) {\n        var filteredFrameList = [];\n\n        for (i = 0; i < frameList.length; i++) {\n          frame = frameList[i];\n\n          if (frameList[i].type !== 'byname' || i > idx) {\n            filteredFrameList.push(frame);\n          }\n        }\n\n        frameList = filteredFrameList;\n      }\n    }\n\n    if (frameList.length > 0) {\n      queueFrames(frameList);\n    } else {\n      // This is the case where there were simply no frames. It's a little strange\n      // since there's not much to do:\n      gd.emit('plotly_animated');\n      resolve();\n    }\n  });\n}\n/**\r\n * Register new frames\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n *\r\n * @param {array of objects} frameList\r\n *      list of frame definitions, in which each object includes any of:\r\n *      - name: {string} name of frame to add\r\n *      - data: {array of objects} trace data\r\n *      - layout {object} layout definition\r\n *      - traces {array} trace indices\r\n *      - baseframe {string} name of frame from which this frame gets defaults\r\n *\r\n *  @param {array of integers} indices\r\n *      an array of integer indices matching the respective frames in `frameList`. If not\r\n *      provided, an index will be provided in serial order. If already used, the frame\r\n *      will be overwritten.\r\n */\n\n\nfunction addFrames(gd, frameList, indices) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (frameList === null || frameList === undefined) {\n    return Promise.resolve();\n  }\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' + 'to create a plot before adding frames. For more details, see ' + 'https://plotly.com/javascript/animations/');\n  }\n\n  var i, frame, j, idx;\n  var _frames = gd._transitionData._frames;\n  var _frameHash = gd._transitionData._frameHash;\n\n  if (!Array.isArray(frameList)) {\n    throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);\n  } // Create a sorted list of insertions since we run into lots of problems if these\n  // aren't in ascending order of index:\n  //\n  // Strictly for sorting. Make sure this is guaranteed to never collide with any\n  // already-exisisting indices:\n\n\n  var bigIndex = _frames.length + frameList.length * 2;\n  var insertions = [];\n  var _frameHashLocal = {};\n\n  for (i = frameList.length - 1; i >= 0; i--) {\n    if (!Lib.isPlainObject(frameList[i])) continue; // The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and\n    // use a Map instead of an Object instance, as Map keys aren't converted to strings.\n\n    var lookupName = frameList[i].name;\n    var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;\n    var newName = frameList[i].name;\n    var collisionPresent = _frameHash[name] || _frameHashLocal[name];\n\n    if (name && newName && typeof newName === 'number' && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {\n      numericNameWarningCount++;\n      Lib.warn('addFrames: overwriting frame \"' + (_frameHash[name] || _frameHashLocal[name]).name + '\" with a frame whose name of type \"number\" also equates to \"' + name + '\". This is valid but may potentially lead to unexpected ' + 'behavior since all plotly.js frame names are stored internally ' + 'as strings.');\n\n      if (numericNameWarningCount === numericNameWarningCountLimit) {\n        Lib.warn('addFrames: This API call has yielded too many of these warnings. ' + 'For the rest of this call, further warnings about numeric frame ' + 'names will be suppressed.');\n      }\n    }\n\n    _frameHashLocal[lookupName] = {\n      name: lookupName\n    };\n    insertions.push({\n      frame: Plots.supplyFrameDefaults(frameList[i]),\n      index: indices && indices[i] !== undefined && indices[i] !== null ? indices[i] : bigIndex + i\n    });\n  } // Sort this, taking note that undefined insertions end up at the end:\n\n\n  insertions.sort(function (a, b) {\n    if (a.index > b.index) return -1;\n    if (a.index < b.index) return 1;\n    return 0;\n  });\n  var ops = [];\n  var revops = [];\n  var frameCount = _frames.length;\n\n  for (i = insertions.length - 1; i >= 0; i--) {\n    frame = insertions[i].frame;\n\n    if (typeof frame.name === 'number') {\n      Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' + 'implicitly cast to strings');\n    }\n\n    if (!frame.name) {\n      // Repeatedly assign a default name, incrementing the counter each time until\n      // we get a name that's not in the hashed lookup table:\n      while (_frameHash[frame.name = 'frame ' + gd._transitionData._counter++]);\n    }\n\n    if (_frameHash[frame.name]) {\n      // If frame is present, overwrite its definition:\n      for (j = 0; j < _frames.length; j++) {\n        if ((_frames[j] || {}).name === frame.name) break;\n      }\n\n      ops.push({\n        type: 'replace',\n        index: j,\n        value: frame\n      });\n      revops.unshift({\n        type: 'replace',\n        index: j,\n        value: _frames[j]\n      });\n    } else {\n      // Otherwise insert it at the end of the list:\n      idx = Math.max(0, Math.min(insertions[i].index, frameCount));\n      ops.push({\n        type: 'insert',\n        index: idx,\n        value: frame\n      });\n      revops.unshift({\n        type: 'delete',\n        index: idx\n      });\n      frameCount++;\n    }\n  }\n\n  var undoFunc = Plots.modifyFrames;\n  var redoFunc = Plots.modifyFrames;\n  var undoArgs = [gd, revops];\n  var redoArgs = [gd, ops];\n  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return Plots.modifyFrames(gd, ops);\n}\n/**\r\n * Delete frame\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n *\r\n * @param {array of integers} frameList\r\n *      list of integer indices of frames to be deleted\r\n */\n\n\nfunction deleteFrames(gd, frameList) {\n  gd = Lib.getGraphDiv(gd);\n\n  if (!Lib.isPlotDiv(gd)) {\n    throw new Error('This element is not a Plotly plot: ' + gd);\n  }\n\n  var i, idx;\n  var _frames = gd._transitionData._frames;\n  var ops = [];\n  var revops = [];\n\n  if (!frameList) {\n    frameList = [];\n\n    for (i = 0; i < _frames.length; i++) {\n      frameList.push(i);\n    }\n  }\n\n  frameList = frameList.slice();\n  frameList.sort();\n\n  for (i = frameList.length - 1; i >= 0; i--) {\n    idx = frameList[i];\n    ops.push({\n      type: 'delete',\n      index: idx\n    });\n    revops.unshift({\n      type: 'insert',\n      index: idx,\n      value: _frames[idx]\n    });\n  }\n\n  var undoFunc = Plots.modifyFrames;\n  var redoFunc = Plots.modifyFrames;\n  var undoArgs = [gd, revops];\n  var redoArgs = [gd, ops];\n  if (Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\n  return Plots.modifyFrames(gd, ops);\n}\n/**\r\n * Purge a graph container div back to its initial pre-_doPlot state\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n */\n\n\nfunction purge(gd) {\n  gd = Lib.getGraphDiv(gd);\n  var fullLayout = gd._fullLayout || {};\n  var fullData = gd._fullData || []; // remove gl contexts\n\n  Plots.cleanPlot([], {}, fullData, fullLayout); // purge properties\n\n  Plots.purge(gd); // purge event emitter methods\n\n  Events.purge(gd); // remove plot container\n\n  if (fullLayout._container) fullLayout._container.remove(); // in contrast to _doPlots.purge which does NOT clear _context!\n\n  delete gd._context;\n  return gd;\n} // determines if the graph div requires a recalculation of its inverse matrix transforms by comparing old + new bounding boxes.\n\n\nfunction calcInverseTransform(gd) {\n  var fullLayout = gd._fullLayout;\n  var newBBox = gd.getBoundingClientRect();\n  if (Lib.equalDomRects(newBBox, fullLayout._lastBBox)) return;\n  var m = fullLayout._invTransform = Lib.inverseTransformMatrix(Lib.getFullTransformMatrix(gd));\n  fullLayout._invScaleX = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2]);\n  fullLayout._invScaleY = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1] + m[1][2] * m[1][2]);\n  fullLayout._lastBBox = newBBox;\n} // -------------------------------------------------------\n// makePlotFramework: Create the plot container and axes\n// -------------------------------------------------------\n\n\nfunction makePlotFramework(gd) {\n  var gd3 = d3.select(gd);\n  var fullLayout = gd._fullLayout;\n  fullLayout._calcInverseTransform = calcInverseTransform;\n\n  fullLayout._calcInverseTransform(gd); // Plot container\n\n\n  fullLayout._container = gd3.selectAll('.plot-container').data([0]);\n\n  fullLayout._container.enter().insert('div', ':first-child').classed('plot-container', true).classed('plotly', true); // Make the svg container\n\n\n  fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);\n\n  fullLayout._paperdiv.enter().append('div').classed('user-select-none', true).classed('svg-container', true).style('position', 'relative'); // Make the graph containers\n  // start fresh each time we get here, so we know the order comes out\n  // right, rather than enter/exit which can muck up the order\n  // TODO: sort out all the ordering so we don't have to\n  // explicitly delete anything\n  // FIXME: parcoords reuses this object, not the best pattern\n\n\n  fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container').data([{}]);\n\n  fullLayout._glcontainer.enter().append('div').classed('gl-container', true);\n\n  fullLayout._paperdiv.selectAll('.main-svg').remove();\n\n  fullLayout._paperdiv.select('.modebar-container').remove();\n\n  fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child').classed('main-svg', true);\n  fullLayout._toppaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);\n  fullLayout._modebardiv = fullLayout._paperdiv.append('div');\n  delete fullLayout._modeBar;\n  fullLayout._hoverpaper = fullLayout._paperdiv.append('svg').classed('main-svg', true);\n\n  if (!fullLayout._uid) {\n    var otherUids = {};\n    d3.selectAll('defs').each(function () {\n      if (this.id) otherUids[this.id.split('-')[1]] = 1;\n    });\n    fullLayout._uid = Lib.randstr(otherUids);\n  }\n\n  fullLayout._paperdiv.selectAll('.main-svg').attr(xmlnsNamespaces.svgAttrs);\n\n  fullLayout._defs = fullLayout._paper.append('defs').attr('id', 'defs-' + fullLayout._uid);\n  fullLayout._clips = fullLayout._defs.append('g').classed('clips', true);\n  fullLayout._topdefs = fullLayout._toppaper.append('defs').attr('id', 'topdefs-' + fullLayout._uid);\n  fullLayout._topclips = fullLayout._topdefs.append('g').classed('clips', true);\n  fullLayout._bgLayer = fullLayout._paper.append('g').classed('bglayer', true);\n  fullLayout._draggers = fullLayout._paper.append('g').classed('draglayer', true); // lower shape/image layer - note that this is behind\n  // all subplots data/grids but above the backgrounds\n  // except inset subplots, whose backgrounds are drawn\n  // inside their own group so that they appear above\n  // the data for the main subplot\n  // lower shapes and images which are fully referenced to\n  // a subplot still get drawn within the subplot's group\n  // so they will work correctly on insets\n\n  var layerBelow = fullLayout._paper.append('g').classed('layer-below', true);\n\n  fullLayout._imageLowerLayer = layerBelow.append('g').classed('imagelayer', true);\n  fullLayout._shapeLowerLayer = layerBelow.append('g').classed('shapelayer', true); // single cartesian layer for the whole plot\n\n  fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true); // single polar layer for the whole plot\n\n  fullLayout._polarlayer = fullLayout._paper.append('g').classed('polarlayer', true); // single ternary layer for the whole plot\n\n  fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true); // single geo layer for the whole plot\n\n  fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true); // single funnelarea layer for the whole plot\n\n  fullLayout._funnelarealayer = fullLayout._paper.append('g').classed('funnelarealayer', true); // single pie layer for the whole plot\n\n  fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true); // single treemap layer for the whole plot\n\n  fullLayout._iciclelayer = fullLayout._paper.append('g').classed('iciclelayer', true); // single treemap layer for the whole plot\n\n  fullLayout._treemaplayer = fullLayout._paper.append('g').classed('treemaplayer', true); // single sunburst layer for the whole plot\n\n  fullLayout._sunburstlayer = fullLayout._paper.append('g').classed('sunburstlayer', true); // single indicator layer for the whole plot\n\n  fullLayout._indicatorlayer = fullLayout._toppaper.append('g').classed('indicatorlayer', true); // fill in image server scrape-svg\n\n  fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true); // lastly upper shapes, info (legend, annotations) and hover layers go on top\n  // these are in a different svg element normally, but get collapsed into a single\n  // svg when exporting (after inserting 3D)\n  // upper shapes/images are only those drawn above the whole plot, including subplots\n\n  var layerAbove = fullLayout._toppaper.append('g').classed('layer-above', true);\n\n  fullLayout._imageUpperLayer = layerAbove.append('g').classed('imagelayer', true);\n  fullLayout._shapeUpperLayer = layerAbove.append('g').classed('shapelayer', true);\n  fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);\n  fullLayout._menulayer = fullLayout._toppaper.append('g').classed('menulayer', true);\n  fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);\n  fullLayout._hoverlayer = fullLayout._hoverpaper.append('g').classed('hoverlayer', true); // Make the modebar container\n\n  fullLayout._modebardiv.classed('modebar-container', true).style('position', 'absolute').style('top', '0px').style('right', '0px');\n\n  gd.emit('plotly_framework');\n}\n\nexports.animate = animate;\nexports.addFrames = addFrames;\nexports.deleteFrames = deleteFrames;\nexports.addTraces = addTraces;\nexports.deleteTraces = deleteTraces;\nexports.extendTraces = extendTraces;\nexports.moveTraces = moveTraces;\nexports.prependTraces = prependTraces;\nexports.newPlot = newPlot;\nexports._doPlot = _doPlot;\nexports.purge = purge;\nexports.react = react;\nexports.redraw = redraw;\nexports.relayout = relayout;\nexports.restyle = restyle;\nexports.setPlotConfig = setPlotConfig;\nexports.update = update;\nexports._guiRelayout = guiEdit(relayout);\nexports._guiRestyle = guiEdit(restyle);\nexports._guiUpdate = guiEdit(update);\nexports._storeDirectGUIEdit = _storeDirectGUIEdit;","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/plot_api/plot_api.js"],"names":["d3","require","isNumeric","hasHover","Lib","nestedProperty","Events","Queue","Registry","PlotSchema","Plots","Axes","Drawing","Color","initInteractions","xmlnsNamespaces","clearSelect","dfltConfig","manageArrays","helpers","subroutines","editTypes","AX_NAME_PATTERN","numericNameWarningCount","numericNameWarningCountLimit","_doPlot","gd","data","layout","config","frames","getGraphDiv","init","isPlainObject","obj","okToPlot","triggerHandler","Promise","reject","isPlotDiv","warn","addFrames","exports","setPlotContext","select","classed","makeTester","Array","isArray","_promises","graphWasEmpty","length","cleanData","push","apply","empty","cleanLayout","supplyDefaults","fullLayout","_fullLayout","hasCartesian","_has","_replotting","_shouldCreateBgLayer","makePlotFramework","initGradients","initPatterns","saveShowSpikeInitial","recalc","calcdata","_fullData","doCalcdata","i","trace","_context","responsive","_responsiveChartHandler","isHidden","resize","window","addEventListener","clearResponsive","oldMargins","extendFlat","_size","drawFrameworkCalls","drawFramework","basePlotModules","_basePlotModules","_glcanvas","_glcontainer","selectAll","key","context","pick","d","enter","append","attr","replace","style","position","top","left","overflow","width","height","regl","Math","floor","_gl","drawingBufferWidth","drawingBufferHeight","msg","error","log","cleanPlot","modebar","orientation","_modebardiv","previousPromises","marginPushers","clearAutoMarginIds","drawMarginPushers","allowAutoMargin","fullData","type","automargin","uid","doAutoMargin","marginPushersAgain","didMarginChange","syncOrAsync","layoutStyles","positionAndAutorange","doAutoRangeAndConstraints","getComponentMethod","_transitioning","saveRangeInitial","drawAxes","draw","seq","insideTickLabelsAutorange","_insideTickLabelsAutorange","relayout","then","undefined","drawData","finalDraw","addLinks","rehover","redrag","saveRangeInitialForInsideTickLabels","plotDone","resolve","emitAfterPlot","_redrawFromAutoMarginCount","emit","setPlotConfig","setBackground","bgColor","_paper","e","opaqueSetBackground","blend","combine","extendDeep","base","_baseUrl","size","location","href","split","keys","Object","plot3dPixelRatio","plotGlPixelRatio","editable","edits","_exportedPlot","staticPlot","autosizable","scrollZoom","doubleClick","showTips","showLink","displayModeBar","_hasZeroHeight","clientHeight","_hasZeroWidth","clientWidth","szIn","szOut","_scrollZoom","cartesian","gl3d","geo","mapbox","parts","redraw","Error","newPlot","purge","positivifyIndices","indices","maxIndex","parentLength","positiveIndices","index","assertIndexArray","arrayName","parseInt","indexOf","checkMoveTracesArgs","currentIndices","newIndices","checkAddTracesArgs","traces","value","assertExtendTracesArgs","update","maxPoints","maxPointsIsObject","getExtendProperties","updateProps","target","prop","insert","maxp","j","get","isArrayOrTypedArray","constructor","spliceTraces","updateArray","undoUpdate","undoPoints","out","set","astr","concatTypedArray","arr0","arr1","arr2","extendTraces","newArray","remainder","isTypedArray","none","both","numberOfItemsFromInsert","subarray","numberOfItemsFromTarget","targetBegin","concat","splice","undo","promise","undoArgs","add","prependTraces","arguments","addTraces","undoFunc","deleteTraces","redoFunc","redoArgs","map","startSequence","moveTraces","stopSequence","deletedTrace","sort","sorterDes","newData","movingTraceMap","newIndex","a","b","restyle","val","_traces","clearPromiseQueue","aobj","changed","coerceTraceIndices","specs","_restyle","flags","calc","clearAxisTypes","fullReplot","markerSize","addAxRangeSequence","doTraceStyle","colorbars","doColorBars","undoit","redoit","eventData","undefinedToNull","makeNP","preGUI","guiEditFlag","container","prefix","np","npSet","fullAttr","storeCurrent","newVal","arrayVal","arrayNew","maxLen","max","objVal","objNew","objBoth","_storeDirectGUIEdit","_guiEditing","layoutNP","_preGUI","extendDeepAll","cleanDeprecatedAttributeKeys","traceFlags","axlist","a0","addToAxlist","axid","axName","id2name","autorangeAttr","rangeAttr","getFullTrace","traceIndex","_input","doextra","forEach","hasParent","extraparam","substr","tracei","_tracePreGUI","_fullInput","allBins","binAttr","arrayBins","vij","ai","vi","cont","contFull","param","oldVal","valObject","charAt","finalPart","prefixDot","innerContFull","getTraceValObject","impliedEdits","impliedKey","relativeAttr","gs","orient","topOrBottom","thicknorm","h","w","thickness","lennorm","len","labelsTo","valuesTo","swapAttrs","_pielayer","remove","traceIs","defaultOrientation","x","y","v","swapXYData","dataArrayContainers","manageArrayContainers","arrayOk","swap","hovermode","xaxis","yaxis","plot","extendDeepNoArrays","oldAxisTitleRegex","counterRegex","colorbarRegex","test","oldAttrStr","newAttrStr","_relayout","layoutReplot","axRangeSupplyDefaultsByPass","legend","doLegend","layoutstyle","axrange","rangesAltered","ticks","doTicksRelayout","doModeBar","camera","doCamera","k","axId","axIn","axOut","autorange","range","slice","cleanRange","_matchGroup","axId2","ax2","axIds","skipTitle","id","ax","getFromId","ticklabelposition","_anchorAxis","_id","id2","AX_RANGE_RE","AX_AUTORANGE_RE","AX_DOMAIN_RE","axes","list","arrayEdits","arrayStr","scene","axisAttr","newkey","_name","layoutFlags","p","recordAlteredAxis","pleafPlus","name2id","plen","pend","pleaf","ptrunk","join","parentIn","parentFull","vOld","getLayoutValObject","oppositeAttr","_initialAutoSize","match","axFull","_inputDomain","domain","toLog","fromLog","r0","r1","LN10","pow","_subplots","polar","_subplot","viewInitial","fullProp","newType","containerArrayMatch","array","propStr","property","updateValObject","editType","isAddVal","isRemoveVal","objEdits","reverse","finished","applyContainerArrayChanges","group","_constraintGroup","groupAxId","_constraintShrinkable","updateAutosize","oldWidth","oldHeight","autosize","plotAutoSize","traceUpdate","layoutUpdate","restyleSpecs","restyleFlags","relayoutSpecs","relayoutFlags","guiEdit","func","wrappedEdit","layoutUIControlPatterns","pattern","traceUIControlPatterns","findUIPattern","patternSpecs","spec","head","getNewRev","revAttr","newRev","pop","uirevision","getFullTraceIndexFromUid","getTraceIndexFromUid","valsMatch","v1","v2","v1IsObj","v1IsArray","JSON","stringify","applyUIRevisions","oldFullData","oldFullLayout","layoutPreGUI","oldRev","preGUIVal","newNP","bothInheritAutorange","newRangeAccepted","axAttr","newAx","allTracePreGUI","tracePreGUI","newTrace","fullInput","fulli","fullTrace","newTracei","react","configChanged","oldConfig","diffConfig","skipUpdateCalc","newFullData","newFullLayout","immutable","datarevision","transition","diffLayout","newDataRevision","diffData","allNames","getOwnPropertyNames","q","name","start","substring","emptyCategories","_emptyCategories","supplyDefaultsUpdateCalc","_transitionData","createTransitionData","anim","transitionFromReact","_skipDefaults","componentType","arrays","drawOne","noop","sameTraceLength","nChanges","nChangesAnim","_module","animatable","diffOpts","getValObject","seenUIDs","hasMakesDataTransform","getDiffFlags","oldContainer","newContainer","outerparts","opts","inArray","arrayIndex","pushUnique","valObjectCanBeDataArray","valType","tickMode","tickmode","_compareAsJSON","canBeDataArray","wasArray","nowArray","inputKey","oldValIn","newValIn","_isLinkedToArray","arrayEditIndices","extraIndices","minLen","min","String","newConfig","animate","frameOrGroupNameOrFrameList","animationOpts","trans","_frameQueue","supplyAnimationDefaults","transitionOpts","frameOpts","frame","_frameWaitingCnt","getTransitionOpts","getFrameOpts","callbackOnNthTime","cb","n","cnt","discardExistingFrames","next","onInterrupt","queueFrames","frameList","computedFrame","computeFrame","duration","nextFrame","onComplete","mode","_lastFrameAt","Infinity","_animationRaf","beginAnimationLoop","stopAnimationLoop","cancelAnimationFrame","_currentFrame","newFrame","shift","stringName","toString","Date","now","_timeToNext","animation","_runningTransitions","doFrame","requestAnimationFrame","configCounter","setTransitionConfig","allFrames","isFrameArray","isSingleFrame","_frames","frameOrName","_frameHash","direction","currentFrame","fromcurrent","idx","filteredFrameList","bigIndex","insertions","_frameHashLocal","lookupName","newName","collisionPresent","supplyFrameDefaults","ops","revops","frameCount","_counter","unshift","modifyFrames","deleteFrames","_container","calcInverseTransform","newBBox","getBoundingClientRect","equalDomRects","_lastBBox","m","_invTransform","inverseTransformMatrix","getFullTransformMatrix","_invScaleX","sqrt","_invScaleY","gd3","_calcInverseTransform","_paperdiv","_toppaper","_modeBar","_hoverpaper","_uid","otherUids","each","randstr","svgAttrs","_defs","_clips","_topdefs","_topclips","_bgLayer","_draggers","layerBelow","_imageLowerLayer","_shapeLowerLayer","_cartesianlayer","_polarlayer","_ternarylayer","_geolayer","_funnelarealayer","_iciclelayer","_treemaplayer","_sunburstlayer","_indicatorlayer","_glimages","layerAbove","_imageUpperLayer","_shapeUpperLayer","_infolayer","_menulayer","_zoomlayer","_hoverlayer","_guiRelayout","_guiRestyle","_guiUpdate"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nvar d3 = require('@plotly/d3');\r\nvar isNumeric = require('fast-isnumeric');\r\nvar hasHover = require('has-hover');\r\n\r\nvar Lib = require('../lib');\r\nvar nestedProperty = Lib.nestedProperty;\r\n\r\nvar Events = require('../lib/events');\r\nvar Queue = require('../lib/queue');\r\n\r\nvar Registry = require('../registry');\r\nvar PlotSchema = require('./plot_schema');\r\nvar Plots = require('../plots/plots');\r\n\r\nvar Axes = require('../plots/cartesian/axes');\r\nvar Drawing = require('../components/drawing');\r\nvar Color = require('../components/color');\r\nvar initInteractions = require('../plots/cartesian/graph_interact').initInteractions;\r\nvar xmlnsNamespaces = require('../constants/xmlns_namespaces');\r\nvar clearSelect = require('../plots/cartesian/select').clearSelect;\r\n\r\nvar dfltConfig = require('./plot_config').dfltConfig;\r\nvar manageArrays = require('./manage_arrays');\r\nvar helpers = require('./helpers');\r\nvar subroutines = require('./subroutines');\r\nvar editTypes = require('./edit_types');\r\n\r\nvar AX_NAME_PATTERN = require('../plots/cartesian/constants').AX_NAME_PATTERN;\r\n\r\nvar numericNameWarningCount = 0;\r\nvar numericNameWarningCountLimit = 5;\r\n\r\n/**\r\n * Internal plot-creation function\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n * @param {array of objects} data\r\n *      array of traces, containing the data and display information for each trace\r\n * @param {object} layout\r\n *      object describing the overall display of the plot,\r\n *      all the stuff that doesn't pertain to any individual trace\r\n * @param {object} config\r\n *      configuration options (see ./plot_config.js for more info)\r\n *\r\n * OR\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n * @param {object} figure\r\n *      object containing `data`, `layout`, `config`, and `frames` members\r\n *\r\n */\r\nfunction _doPlot(gd, data, layout, config) {\r\n    var frames;\r\n\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    // Events.init is idempotent and bails early if gd has already been init'd\r\n    Events.init(gd);\r\n\r\n    if(Lib.isPlainObject(data)) {\r\n        var obj = data;\r\n        data = obj.data;\r\n        layout = obj.layout;\r\n        config = obj.config;\r\n        frames = obj.frames;\r\n    }\r\n\r\n    var okToPlot = Events.triggerHandler(gd, 'plotly_beforeplot', [data, layout, config]);\r\n    if(okToPlot === false) return Promise.reject();\r\n\r\n    // if there's no data or layout, and this isn't yet a plotly plot\r\n    // container, log a warning to help plotly.js users debug\r\n    if(!data && !layout && !Lib.isPlotDiv(gd)) {\r\n        Lib.warn('Calling _doPlot as if redrawing ' +\r\n            'but this container doesn\\'t yet have a plot.', gd);\r\n    }\r\n\r\n    function addFrames() {\r\n        if(frames) {\r\n            return exports.addFrames(gd, frames);\r\n        }\r\n    }\r\n\r\n    // transfer configuration options to gd until we move over to\r\n    // a more OO like model\r\n    setPlotContext(gd, config);\r\n\r\n    if(!layout) layout = {};\r\n\r\n    // hook class for plots main container (in case of plotly.js\r\n    // this won't be #embedded-graph or .js-tab-contents)\r\n    d3.select(gd).classed('js-plotly-plot', true);\r\n\r\n    // off-screen getBoundingClientRect testing space,\r\n    // in #js-plotly-tester (and stored as Drawing.tester)\r\n    // so we can share cached text across tabs\r\n    Drawing.makeTester();\r\n\r\n    // collect promises for any async actions during plotting\r\n    // any part of the plotting code can push to gd._promises, then\r\n    // before we move to the next step, we check that they're all\r\n    // complete, and empty out the promise list again.\r\n    if(!Array.isArray(gd._promises)) gd._promises = [];\r\n\r\n    var graphWasEmpty = ((gd.data || []).length === 0 && Array.isArray(data));\r\n\r\n    // if there is already data on the graph, append the new data\r\n    // if you only want to redraw, pass a non-array for data\r\n    if(Array.isArray(data)) {\r\n        helpers.cleanData(data);\r\n\r\n        if(graphWasEmpty) gd.data = data;\r\n        else gd.data.push.apply(gd.data, data);\r\n\r\n        // for routines outside graph_obj that want a clean tab\r\n        // (rather than appending to an existing one) gd.empty\r\n        // is used to determine whether to make a new tab\r\n        gd.empty = false;\r\n    }\r\n\r\n    if(!gd.layout || graphWasEmpty) {\r\n        gd.layout = helpers.cleanLayout(layout);\r\n    }\r\n\r\n    Plots.supplyDefaults(gd);\r\n\r\n    var fullLayout = gd._fullLayout;\r\n    var hasCartesian = fullLayout._has('cartesian');\r\n\r\n    // so we don't try to re-call _doPlot from inside\r\n    // legend and colorbar, if margins changed\r\n    fullLayout._replotting = true;\r\n\r\n    // make or remake the framework if we need to\r\n    if(graphWasEmpty || fullLayout._shouldCreateBgLayer) {\r\n        makePlotFramework(gd);\r\n\r\n        if(fullLayout._shouldCreateBgLayer) {\r\n            delete fullLayout._shouldCreateBgLayer;\r\n        }\r\n    }\r\n\r\n    // clear gradient and pattern defs on each .plot call, because we know we'll loop through all traces\r\n    Drawing.initGradients(gd);\r\n    Drawing.initPatterns(gd);\r\n\r\n    // save initial show spikes once per graph\r\n    if(graphWasEmpty) Axes.saveShowSpikeInitial(gd);\r\n\r\n    // prepare the data and find the autorange\r\n\r\n    // generate calcdata, if we need to\r\n    // to force redoing calcdata, just delete it before calling _doPlot\r\n    var recalc = !gd.calcdata || gd.calcdata.length !== (gd._fullData || []).length;\r\n    if(recalc) Plots.doCalcdata(gd);\r\n\r\n    // in case it has changed, attach fullData traces to calcdata\r\n    for(var i = 0; i < gd.calcdata.length; i++) {\r\n        gd.calcdata[i][0].trace = gd._fullData[i];\r\n    }\r\n\r\n    // make the figure responsive\r\n    if(gd._context.responsive) {\r\n        if(!gd._responsiveChartHandler) {\r\n            // Keep a reference to the resize handler to purge it down the road\r\n            gd._responsiveChartHandler = function() { if(!Lib.isHidden(gd)) Plots.resize(gd); };\r\n\r\n            // Listen to window resize\r\n            window.addEventListener('resize', gd._responsiveChartHandler);\r\n        }\r\n    } else {\r\n        Lib.clearResponsive(gd);\r\n    }\r\n\r\n    /*\r\n     * start async-friendly code - now we're actually drawing things\r\n     */\r\n\r\n    var oldMargins = Lib.extendFlat({}, fullLayout._size);\r\n\r\n    // draw framework first so that margin-pushing\r\n    // components can position themselves correctly\r\n    var drawFrameworkCalls = 0;\r\n    function drawFramework() {\r\n        var basePlotModules = fullLayout._basePlotModules;\r\n\r\n        for(var i = 0; i < basePlotModules.length; i++) {\r\n            if(basePlotModules[i].drawFramework) {\r\n                basePlotModules[i].drawFramework(gd);\r\n            }\r\n        }\r\n\r\n        if(!fullLayout._glcanvas && fullLayout._has('gl')) {\r\n            fullLayout._glcanvas = fullLayout._glcontainer.selectAll('.gl-canvas').data([{\r\n                key: 'contextLayer',\r\n                context: true,\r\n                pick: false\r\n            }, {\r\n                key: 'focusLayer',\r\n                context: false,\r\n                pick: false\r\n            }, {\r\n                key: 'pickLayer',\r\n                context: false,\r\n                pick: true\r\n            }], function(d) { return d.key; });\r\n\r\n            fullLayout._glcanvas.enter().append('canvas')\r\n                .attr('class', function(d) {\r\n                    return 'gl-canvas gl-canvas-' + d.key.replace('Layer', '');\r\n                })\r\n                .style({\r\n                    position: 'absolute',\r\n                    top: 0,\r\n                    left: 0,\r\n                    overflow: 'visible',\r\n                    'pointer-events': 'none'\r\n                });\r\n        }\r\n\r\n        if(fullLayout._glcanvas) {\r\n            fullLayout._glcanvas\r\n                .attr('width', fullLayout.width)\r\n                .attr('height', fullLayout.height);\r\n\r\n            var regl = fullLayout._glcanvas.data()[0].regl;\r\n            if(regl) {\r\n                // Unfortunately, this can happen when relayouting to large\r\n                // width/height on some browsers.\r\n                if(Math.floor(fullLayout.width) !== regl._gl.drawingBufferWidth ||\r\n                    Math.floor(fullLayout.height) !== regl._gl.drawingBufferHeight\r\n                 ) {\r\n                    var msg = 'WebGL context buffer and canvas dimensions do not match due to browser/WebGL bug.';\r\n                    if(drawFrameworkCalls) {\r\n                        Lib.error(msg);\r\n                    } else {\r\n                        Lib.log(msg + ' Clearing graph and plotting again.');\r\n                        Plots.cleanPlot([], {}, gd._fullData, fullLayout);\r\n                        Plots.supplyDefaults(gd);\r\n                        fullLayout = gd._fullLayout;\r\n                        Plots.doCalcdata(gd);\r\n                        drawFrameworkCalls++;\r\n                        return drawFramework();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if(fullLayout.modebar.orientation === 'h') {\r\n            fullLayout._modebardiv\r\n              .style('height', null)\r\n              .style('width', '100%');\r\n        } else {\r\n            fullLayout._modebardiv\r\n              .style('width', null)\r\n              .style('height', fullLayout.height + 'px');\r\n        }\r\n\r\n        return Plots.previousPromises(gd);\r\n    }\r\n\r\n    // draw anything that can affect margins.\r\n    function marginPushers() {\r\n        // First reset the list of things that are allowed to change the margins\r\n        // So any deleted traces or components will be wiped out of the\r\n        // automargin calculation.\r\n        // This means *every* margin pusher must be listed here, even if it\r\n        // doesn't actually try to push the margins until later.\r\n        Plots.clearAutoMarginIds(gd);\r\n\r\n        subroutines.drawMarginPushers(gd);\r\n        Axes.allowAutoMargin(gd);\r\n\r\n        // TODO can this be moved elsewhere?\r\n        if(fullLayout._has('pie')) {\r\n            var fullData = gd._fullData;\r\n            for(var i = 0; i < fullData.length; i++) {\r\n                var trace = fullData[i];\r\n                if(trace.type === 'pie' && trace.automargin) {\r\n                    Plots.allowAutoMargin(gd, 'pie.' + trace.uid + '.automargin');\r\n                }\r\n            }\r\n        }\r\n\r\n        Plots.doAutoMargin(gd);\r\n        return Plots.previousPromises(gd);\r\n    }\r\n\r\n    // in case the margins changed, draw margin pushers again\r\n    function marginPushersAgain() {\r\n        if(!Plots.didMarginChange(oldMargins, fullLayout._size)) return;\r\n\r\n        return Lib.syncOrAsync([\r\n            marginPushers,\r\n            subroutines.layoutStyles\r\n        ], gd);\r\n    }\r\n\r\n    function positionAndAutorange() {\r\n        if(!recalc) {\r\n            doAutoRangeAndConstraints();\r\n            return;\r\n        }\r\n\r\n        // TODO: autosize extra for text markers and images\r\n        // see https://github.com/plotly/plotly.js/issues/1111\r\n        return Lib.syncOrAsync([\r\n            Registry.getComponentMethod('shapes', 'calcAutorange'),\r\n            Registry.getComponentMethod('annotations', 'calcAutorange'),\r\n            doAutoRangeAndConstraints\r\n        ], gd);\r\n    }\r\n\r\n    function doAutoRangeAndConstraints() {\r\n        if(gd._transitioning) return;\r\n\r\n        subroutines.doAutoRangeAndConstraints(gd);\r\n\r\n        // store initial ranges *after* enforcing constraints, otherwise\r\n        // we will never look like we're at the initial ranges\r\n        if(graphWasEmpty) Axes.saveRangeInitial(gd);\r\n\r\n        // this one is different from shapes/annotations calcAutorange\r\n        // the others incorporate those components into ax._extremes,\r\n        // this one actually sets the ranges in rangesliders.\r\n        Registry.getComponentMethod('rangeslider', 'calcAutorange')(gd);\r\n    }\r\n\r\n    // draw ticks, titles, and calculate axis scaling (._b, ._m)\r\n    function drawAxes() {\r\n        return Axes.draw(gd, graphWasEmpty ? '' : 'redraw');\r\n    }\r\n\r\n    var seq = [\r\n        Plots.previousPromises,\r\n        addFrames,\r\n        drawFramework,\r\n        marginPushers,\r\n        marginPushersAgain\r\n    ];\r\n\r\n    if(hasCartesian) seq.push(positionAndAutorange);\r\n\r\n    seq.push(subroutines.layoutStyles);\r\n    if(hasCartesian) {\r\n        seq.push(\r\n            drawAxes,\r\n            function insideTickLabelsAutorange(gd) {\r\n                if(gd._fullLayout._insideTickLabelsAutorange) {\r\n                    relayout(gd, gd._fullLayout._insideTickLabelsAutorange).then(function() {\r\n                        gd._fullLayout._insideTickLabelsAutorange = undefined;\r\n                    });\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    seq.push(\r\n        subroutines.drawData,\r\n        subroutines.finalDraw,\r\n        initInteractions,\r\n        Plots.addLinks,\r\n        Plots.rehover,\r\n        Plots.redrag,\r\n        // TODO: doAutoMargin is only needed here for axis automargin, which\r\n        // happens outside of marginPushers where all the other automargins are\r\n        // calculated. Would be much better to separate margin calculations from\r\n        // component drawing - see https://github.com/plotly/plotly.js/issues/2704\r\n        Plots.doAutoMargin,\r\n        saveRangeInitialForInsideTickLabels,\r\n        Plots.previousPromises\r\n    );\r\n\r\n    function saveRangeInitialForInsideTickLabels(gd) {\r\n        if(gd._fullLayout._insideTickLabelsAutorange) {\r\n            if(graphWasEmpty) Axes.saveRangeInitial(gd, true);\r\n        }\r\n    }\r\n\r\n    // even if everything we did was synchronous, return a promise\r\n    // so that the caller doesn't care which route we took\r\n    var plotDone = Lib.syncOrAsync(seq, gd);\r\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();\r\n\r\n    return plotDone.then(function() {\r\n        emitAfterPlot(gd);\r\n        return gd;\r\n    });\r\n}\r\n\r\nfunction emitAfterPlot(gd) {\r\n    var fullLayout = gd._fullLayout;\r\n\r\n    if(fullLayout._redrawFromAutoMarginCount) {\r\n        fullLayout._redrawFromAutoMarginCount--;\r\n    } else {\r\n        gd.emit('plotly_afterplot');\r\n    }\r\n}\r\n\r\nfunction setPlotConfig(obj) {\r\n    return Lib.extendFlat(dfltConfig, obj);\r\n}\r\n\r\nfunction setBackground(gd, bgColor) {\r\n    try {\r\n        gd._fullLayout._paper.style('background', bgColor);\r\n    } catch(e) {\r\n        Lib.error(e);\r\n    }\r\n}\r\n\r\nfunction opaqueSetBackground(gd, bgColor) {\r\n    var blend = Color.combine(bgColor, 'white');\r\n    setBackground(gd, blend);\r\n}\r\n\r\nfunction setPlotContext(gd, config) {\r\n    if(!gd._context) {\r\n        gd._context = Lib.extendDeep({}, dfltConfig);\r\n\r\n        // stash <base> href, used to make robust clipPath URLs\r\n        var base = d3.select('base');\r\n        gd._context._baseUrl = base.size() && base.attr('href') ?\r\n            window.location.href.split('#')[0] :\r\n            '';\r\n    }\r\n\r\n    var context = gd._context;\r\n\r\n    var i, keys, key;\r\n\r\n    if(config) {\r\n        keys = Object.keys(config);\r\n        for(i = 0; i < keys.length; i++) {\r\n            key = keys[i];\r\n            if(key === 'editable' || key === 'edits') continue;\r\n            if(key in context) {\r\n                if(key === 'setBackground' && config[key] === 'opaque') {\r\n                    context[key] = opaqueSetBackground;\r\n                } else {\r\n                    context[key] = config[key];\r\n                }\r\n            }\r\n        }\r\n\r\n        // map plot3dPixelRatio to plotGlPixelRatio for backward compatibility\r\n        if(config.plot3dPixelRatio && !context.plotGlPixelRatio) {\r\n            context.plotGlPixelRatio = context.plot3dPixelRatio;\r\n        }\r\n\r\n        // now deal with editable and edits - first editable overrides\r\n        // everything, then edits refines\r\n        var editable = config.editable;\r\n        if(editable !== undefined) {\r\n            // we're not going to *use* context.editable, we're only going to\r\n            // use context.edits... but keep it for the record\r\n            context.editable = editable;\r\n\r\n            keys = Object.keys(context.edits);\r\n            for(i = 0; i < keys.length; i++) {\r\n                context.edits[keys[i]] = editable;\r\n            }\r\n        }\r\n        if(config.edits) {\r\n            keys = Object.keys(config.edits);\r\n            for(i = 0; i < keys.length; i++) {\r\n                key = keys[i];\r\n                if(key in context.edits) {\r\n                    context.edits[key] = config.edits[key];\r\n                }\r\n            }\r\n        }\r\n\r\n        // not part of the user-facing config options\r\n        context._exportedPlot = config._exportedPlot;\r\n    }\r\n\r\n    // staticPlot forces a bunch of others:\r\n    if(context.staticPlot) {\r\n        context.editable = false;\r\n        context.edits = {};\r\n        context.autosizable = false;\r\n        context.scrollZoom = false;\r\n        context.doubleClick = false;\r\n        context.showTips = false;\r\n        context.showLink = false;\r\n        context.displayModeBar = false;\r\n    }\r\n\r\n    // make sure hover-only devices have mode bar visible\r\n    if(context.displayModeBar === 'hover' && !hasHover) {\r\n        context.displayModeBar = true;\r\n    }\r\n\r\n    // default and fallback for setBackground\r\n    if(context.setBackground === 'transparent' || typeof context.setBackground !== 'function') {\r\n        context.setBackground = setBackground;\r\n    }\r\n\r\n    // Check if gd has a specified widht/height to begin with\r\n    context._hasZeroHeight = context._hasZeroHeight || gd.clientHeight === 0;\r\n    context._hasZeroWidth = context._hasZeroWidth || gd.clientWidth === 0;\r\n\r\n    // fill context._scrollZoom helper to help manage scrollZoom flaglist\r\n    var szIn = context.scrollZoom;\r\n    var szOut = context._scrollZoom = {};\r\n    if(szIn === true) {\r\n        szOut.cartesian = 1;\r\n        szOut.gl3d = 1;\r\n        szOut.geo = 1;\r\n        szOut.mapbox = 1;\r\n    } else if(typeof szIn === 'string') {\r\n        var parts = szIn.split('+');\r\n        for(i = 0; i < parts.length; i++) {\r\n            szOut[parts[i]] = 1;\r\n        }\r\n    } else if(szIn !== false) {\r\n        szOut.gl3d = 1;\r\n        szOut.geo = 1;\r\n        szOut.mapbox = 1;\r\n    }\r\n}\r\n\r\n\r\n// convenience function to force a full redraw, mostly for use by plotly.js\r\nfunction redraw(gd) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    if(!Lib.isPlotDiv(gd)) {\r\n        throw new Error('This element is not a Plotly plot: ' + gd);\r\n    }\r\n\r\n    helpers.cleanData(gd.data);\r\n    helpers.cleanLayout(gd.layout);\r\n\r\n    gd.calcdata = undefined;\r\n    return exports._doPlot(gd).then(function() {\r\n        gd.emit('plotly_redraw');\r\n        return gd;\r\n    });\r\n}\r\n\r\n/**\r\n * Convenience function to make idempotent plot option obvious to users.\r\n *\r\n * @param gd\r\n * @param {Object[]} data\r\n * @param {Object} layout\r\n * @param {Object} config\r\n */\r\nfunction newPlot(gd, data, layout, config) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    // remove gl contexts\r\n    Plots.cleanPlot([], {}, gd._fullData || [], gd._fullLayout || {});\r\n\r\n    Plots.purge(gd);\r\n    return exports._doPlot(gd, data, layout, config);\r\n}\r\n\r\n/**\r\n * Wrap negative indicies to their positive counterparts.\r\n *\r\n * @param {Number[]} indices An array of indices\r\n * @param {Number} maxIndex The maximum index allowable (arr.length - 1)\r\n */\r\nfunction positivifyIndices(indices, maxIndex) {\r\n    var parentLength = maxIndex + 1;\r\n    var positiveIndices = [];\r\n    var i;\r\n    var index;\r\n\r\n    for(i = 0; i < indices.length; i++) {\r\n        index = indices[i];\r\n        if(index < 0) {\r\n            positiveIndices.push(parentLength + index);\r\n        } else {\r\n            positiveIndices.push(index);\r\n        }\r\n    }\r\n    return positiveIndices;\r\n}\r\n\r\n/**\r\n * Ensures that an index array for manipulating gd.data is valid.\r\n *\r\n * Intended for use with addTraces, deleteTraces, and moveTraces.\r\n *\r\n * @param gd\r\n * @param indices\r\n * @param arrayName\r\n */\r\nfunction assertIndexArray(gd, indices, arrayName) {\r\n    var i,\r\n        index;\r\n\r\n    for(i = 0; i < indices.length; i++) {\r\n        index = indices[i];\r\n\r\n        // validate that indices are indeed integers\r\n        if(index !== parseInt(index, 10)) {\r\n            throw new Error('all values in ' + arrayName + ' must be integers');\r\n        }\r\n\r\n        // check that all indices are in bounds for given gd.data array length\r\n        if(index >= gd.data.length || index < -gd.data.length) {\r\n            throw new Error(arrayName + ' must be valid indices for gd.data.');\r\n        }\r\n\r\n        // check that indices aren't repeated\r\n        if(indices.indexOf(index, i + 1) > -1 ||\r\n                index >= 0 && indices.indexOf(-gd.data.length + index) > -1 ||\r\n                index < 0 && indices.indexOf(gd.data.length + index) > -1) {\r\n            throw new Error('each index in ' + arrayName + ' must be unique.');\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Private function used by Plotly.moveTraces to check input args\r\n *\r\n * @param gd\r\n * @param currentIndices\r\n * @param newIndices\r\n */\r\nfunction checkMoveTracesArgs(gd, currentIndices, newIndices) {\r\n    // check that gd has attribute 'data' and 'data' is array\r\n    if(!Array.isArray(gd.data)) {\r\n        throw new Error('gd.data must be an array.');\r\n    }\r\n\r\n    // validate currentIndices array\r\n    if(typeof currentIndices === 'undefined') {\r\n        throw new Error('currentIndices is a required argument.');\r\n    } else if(!Array.isArray(currentIndices)) {\r\n        currentIndices = [currentIndices];\r\n    }\r\n    assertIndexArray(gd, currentIndices, 'currentIndices');\r\n\r\n    // validate newIndices array if it exists\r\n    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\r\n        newIndices = [newIndices];\r\n    }\r\n    if(typeof newIndices !== 'undefined') {\r\n        assertIndexArray(gd, newIndices, 'newIndices');\r\n    }\r\n\r\n    // check currentIndices and newIndices are the same length if newIdices exists\r\n    if(typeof newIndices !== 'undefined' && currentIndices.length !== newIndices.length) {\r\n        throw new Error('current and new indices must be of equal length.');\r\n    }\r\n}\r\n/**\r\n * A private function to reduce the type checking clutter in addTraces.\r\n *\r\n * @param gd\r\n * @param traces\r\n * @param newIndices\r\n */\r\nfunction checkAddTracesArgs(gd, traces, newIndices) {\r\n    var i, value;\r\n\r\n    // check that gd has attribute 'data' and 'data' is array\r\n    if(!Array.isArray(gd.data)) {\r\n        throw new Error('gd.data must be an array.');\r\n    }\r\n\r\n    // make sure traces exists\r\n    if(typeof traces === 'undefined') {\r\n        throw new Error('traces must be defined.');\r\n    }\r\n\r\n    // make sure traces is an array\r\n    if(!Array.isArray(traces)) {\r\n        traces = [traces];\r\n    }\r\n\r\n    // make sure each value in traces is an object\r\n    for(i = 0; i < traces.length; i++) {\r\n        value = traces[i];\r\n        if(typeof value !== 'object' || (Array.isArray(value) || value === null)) {\r\n            throw new Error('all values in traces array must be non-array objects');\r\n        }\r\n    }\r\n\r\n    // make sure we have an index for each trace\r\n    if(typeof newIndices !== 'undefined' && !Array.isArray(newIndices)) {\r\n        newIndices = [newIndices];\r\n    }\r\n    if(typeof newIndices !== 'undefined' && newIndices.length !== traces.length) {\r\n        throw new Error(\r\n            'if indices is specified, traces.length must equal indices.length'\r\n        );\r\n    }\r\n}\r\n\r\n/**\r\n * A private function to reduce the type checking clutter in spliceTraces.\r\n * Get all update Properties from gd.data. Validate inputs and outputs.\r\n * Used by prependTrace and extendTraces\r\n *\r\n * @param gd\r\n * @param update\r\n * @param indices\r\n * @param maxPoints\r\n */\r\nfunction assertExtendTracesArgs(gd, update, indices, maxPoints) {\r\n    var maxPointsIsObject = Lib.isPlainObject(maxPoints);\r\n\r\n    if(!Array.isArray(gd.data)) {\r\n        throw new Error('gd.data must be an array');\r\n    }\r\n    if(!Lib.isPlainObject(update)) {\r\n        throw new Error('update must be a key:value object');\r\n    }\r\n\r\n    if(typeof indices === 'undefined') {\r\n        throw new Error('indices must be an integer or array of integers');\r\n    }\r\n\r\n    assertIndexArray(gd, indices, 'indices');\r\n\r\n    for(var key in update) {\r\n        /*\r\n         * Verify that the attribute to be updated contains as many trace updates\r\n         * as indices. Failure must result in throw and no-op\r\n         */\r\n        if(!Array.isArray(update[key]) || update[key].length !== indices.length) {\r\n            throw new Error('attribute ' + key + ' must be an array of length equal to indices array length');\r\n        }\r\n\r\n        /*\r\n         * if maxPoints is an object it must match keys and array lengths of 'update' 1:1\r\n         */\r\n        if(maxPointsIsObject &&\r\n            (!(key in maxPoints) || !Array.isArray(maxPoints[key]) ||\r\n            maxPoints[key].length !== update[key].length)) {\r\n            throw new Error('when maxPoints is set as a key:value object it must contain a 1:1 ' +\r\n                            'corrispondence with the keys and number of traces in the update object');\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * A private function to reduce the type checking clutter in spliceTraces.\r\n *\r\n * @param {Object|HTMLDivElement} gd\r\n * @param {Object} update\r\n * @param {Number[]} indices\r\n * @param {Number||Object} maxPoints\r\n * @return {Object[]}\r\n */\r\nfunction getExtendProperties(gd, update, indices, maxPoints) {\r\n    var maxPointsIsObject = Lib.isPlainObject(maxPoints);\r\n    var updateProps = [];\r\n    var trace, target, prop, insert, maxp;\r\n\r\n    // allow scalar index to represent a single trace position\r\n    if(!Array.isArray(indices)) indices = [indices];\r\n\r\n    // negative indices are wrapped around to their positive value. Equivalent to python indexing.\r\n    indices = positivifyIndices(indices, gd.data.length - 1);\r\n\r\n    // loop through all update keys and traces and harvest validated data.\r\n    for(var key in update) {\r\n        for(var j = 0; j < indices.length; j++) {\r\n            /*\r\n             * Choose the trace indexed by the indices map argument and get the prop setter-getter\r\n             * instance that references the key and value for this particular trace.\r\n             */\r\n            trace = gd.data[indices[j]];\r\n            prop = nestedProperty(trace, key);\r\n\r\n            /*\r\n             * Target is the existing gd.data.trace.dataArray value like \"x\" or \"marker.size\"\r\n             * Target must exist as an Array to allow the extend operation to be performed.\r\n             */\r\n            target = prop.get();\r\n            insert = update[key][j];\r\n\r\n            if(!Lib.isArrayOrTypedArray(insert)) {\r\n                throw new Error('attribute: ' + key + ' index: ' + j + ' must be an array');\r\n            }\r\n            if(!Lib.isArrayOrTypedArray(target)) {\r\n                throw new Error('cannot extend missing or non-array attribute: ' + key);\r\n            }\r\n            if(target.constructor !== insert.constructor) {\r\n                throw new Error('cannot extend array with an array of a different type: ' + key);\r\n            }\r\n\r\n            /*\r\n             * maxPoints may be an object map or a scalar. If object select the key:value, else\r\n             * Use the scalar maxPoints for all key and trace combinations.\r\n             */\r\n            maxp = maxPointsIsObject ? maxPoints[key][j] : maxPoints;\r\n\r\n            // could have chosen null here, -1 just tells us to not take a window\r\n            if(!isNumeric(maxp)) maxp = -1;\r\n\r\n            /*\r\n             * Wrap the nestedProperty in an object containing required data\r\n             * for lengthening and windowing this particular trace - key combination.\r\n             * Flooring maxp mirrors the behaviour of floats in the Array.slice JSnative function.\r\n             */\r\n            updateProps.push({\r\n                prop: prop,\r\n                target: target,\r\n                insert: insert,\r\n                maxp: Math.floor(maxp)\r\n            });\r\n        }\r\n    }\r\n\r\n    // all target and insertion data now validated\r\n    return updateProps;\r\n}\r\n\r\n/**\r\n * A private function to key Extend and Prepend traces DRY\r\n *\r\n * @param {Object|HTMLDivElement} gd\r\n * @param {Object} update\r\n * @param {Number[]} indices\r\n * @param {Number||Object} maxPoints\r\n * @param {Function} updateArray\r\n * @return {Object}\r\n */\r\nfunction spliceTraces(gd, update, indices, maxPoints, updateArray) {\r\n    assertExtendTracesArgs(gd, update, indices, maxPoints);\r\n\r\n    var updateProps = getExtendProperties(gd, update, indices, maxPoints);\r\n    var undoUpdate = {};\r\n    var undoPoints = {};\r\n\r\n    for(var i = 0; i < updateProps.length; i++) {\r\n        var prop = updateProps[i].prop;\r\n        var maxp = updateProps[i].maxp;\r\n\r\n        // return new array and remainder\r\n        var out = updateArray(updateProps[i].target, updateProps[i].insert, maxp);\r\n        prop.set(out[0]);\r\n\r\n        // build the inverse update object for the undo operation\r\n        if(!Array.isArray(undoUpdate[prop.astr])) undoUpdate[prop.astr] = [];\r\n        undoUpdate[prop.astr].push(out[1]);\r\n\r\n         // build the matching maxPoints undo object containing original trace lengths\r\n        if(!Array.isArray(undoPoints[prop.astr])) undoPoints[prop.astr] = [];\r\n        undoPoints[prop.astr].push(updateProps[i].target.length);\r\n    }\r\n\r\n    return {update: undoUpdate, maxPoints: undoPoints};\r\n}\r\n\r\nfunction concatTypedArray(arr0, arr1) {\r\n    var arr2 = new arr0.constructor(arr0.length + arr1.length);\r\n    arr2.set(arr0);\r\n    arr2.set(arr1, arr0.length);\r\n    return arr2;\r\n}\r\n\r\n/**\r\n * extend && prepend traces at indices with update arrays, window trace lengths to maxPoints\r\n *\r\n * Extend and Prepend have identical APIs. Prepend inserts an array at the head while Extend\r\n * inserts an array off the tail. Prepend truncates the tail of the array - counting maxPoints\r\n * from the head, whereas Extend truncates the head of the array, counting backward maxPoints\r\n * from the tail.\r\n *\r\n * If maxPoints is undefined, nonNumeric, negative or greater than extended trace length no\r\n * truncation / windowing will be performed. If its zero, well the whole trace is truncated.\r\n *\r\n * @param {Object|HTMLDivElement} gd The graph div\r\n * @param {Object} update The key:array map of target attributes to extend\r\n * @param {Number|Number[]} indices The locations of traces to be extended\r\n * @param {Number|Object} [maxPoints] Number of points for trace window after lengthening.\r\n *\r\n */\r\nfunction extendTraces(gd, update, indices, maxPoints) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    function updateArray(target, insert, maxp) {\r\n        var newArray, remainder;\r\n\r\n        if(Lib.isTypedArray(target)) {\r\n            if(maxp < 0) {\r\n                var none = new target.constructor(0);\r\n                var both = concatTypedArray(target, insert);\r\n\r\n                if(maxp < 0) {\r\n                    newArray = both;\r\n                    remainder = none;\r\n                } else {\r\n                    newArray = none;\r\n                    remainder = both;\r\n                }\r\n            } else {\r\n                newArray = new target.constructor(maxp);\r\n                remainder = new target.constructor(target.length + insert.length - maxp);\r\n\r\n                if(maxp === insert.length) {\r\n                    newArray.set(insert);\r\n                    remainder.set(target);\r\n                } else if(maxp < insert.length) {\r\n                    var numberOfItemsFromInsert = insert.length - maxp;\r\n\r\n                    newArray.set(insert.subarray(numberOfItemsFromInsert));\r\n                    remainder.set(target);\r\n                    remainder.set(insert.subarray(0, numberOfItemsFromInsert), target.length);\r\n                } else {\r\n                    var numberOfItemsFromTarget = maxp - insert.length;\r\n                    var targetBegin = target.length - numberOfItemsFromTarget;\r\n\r\n                    newArray.set(target.subarray(targetBegin));\r\n                    newArray.set(insert, numberOfItemsFromTarget);\r\n                    remainder.set(target.subarray(0, targetBegin));\r\n                }\r\n            }\r\n        } else {\r\n            newArray = target.concat(insert);\r\n            remainder = (maxp >= 0 && maxp < newArray.length) ?\r\n                newArray.splice(0, newArray.length - maxp) :\r\n                [];\r\n        }\r\n\r\n        return [newArray, remainder];\r\n    }\r\n\r\n    var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\r\n    var promise = exports.redraw(gd);\r\n    var undoArgs = [gd, undo.update, indices, undo.maxPoints];\r\n    Queue.add(gd, exports.prependTraces, undoArgs, extendTraces, arguments);\r\n\r\n    return promise;\r\n}\r\n\r\nfunction prependTraces(gd, update, indices, maxPoints) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    function updateArray(target, insert, maxp) {\r\n        var newArray, remainder;\r\n\r\n        if(Lib.isTypedArray(target)) {\r\n            if(maxp <= 0) {\r\n                var none = new target.constructor(0);\r\n                var both = concatTypedArray(insert, target);\r\n\r\n                if(maxp < 0) {\r\n                    newArray = both;\r\n                    remainder = none;\r\n                } else {\r\n                    newArray = none;\r\n                    remainder = both;\r\n                }\r\n            } else {\r\n                newArray = new target.constructor(maxp);\r\n                remainder = new target.constructor(target.length + insert.length - maxp);\r\n\r\n                if(maxp === insert.length) {\r\n                    newArray.set(insert);\r\n                    remainder.set(target);\r\n                } else if(maxp < insert.length) {\r\n                    var numberOfItemsFromInsert = insert.length - maxp;\r\n\r\n                    newArray.set(insert.subarray(0, numberOfItemsFromInsert));\r\n                    remainder.set(insert.subarray(numberOfItemsFromInsert));\r\n                    remainder.set(target, numberOfItemsFromInsert);\r\n                } else {\r\n                    var numberOfItemsFromTarget = maxp - insert.length;\r\n\r\n                    newArray.set(insert);\r\n                    newArray.set(target.subarray(0, numberOfItemsFromTarget), insert.length);\r\n                    remainder.set(target.subarray(numberOfItemsFromTarget));\r\n                }\r\n            }\r\n        } else {\r\n            newArray = insert.concat(target);\r\n            remainder = (maxp >= 0 && maxp < newArray.length) ?\r\n                newArray.splice(maxp, newArray.length) :\r\n                [];\r\n        }\r\n\r\n        return [newArray, remainder];\r\n    }\r\n\r\n    var undo = spliceTraces(gd, update, indices, maxPoints, updateArray);\r\n    var promise = exports.redraw(gd);\r\n    var undoArgs = [gd, undo.update, indices, undo.maxPoints];\r\n    Queue.add(gd, exports.extendTraces, undoArgs, prependTraces, arguments);\r\n\r\n    return promise;\r\n}\r\n\r\n/**\r\n * Add data traces to an existing graph div.\r\n *\r\n * @param {Object|HTMLDivElement} gd The graph div\r\n * @param {Object[]} gd.data The array of traces we're adding to\r\n * @param {Object[]|Object} traces The object or array of objects to add\r\n * @param {Number[]|Number} [newIndices=[gd.data.length]] Locations to add traces\r\n *\r\n */\r\nfunction addTraces(gd, traces, newIndices) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    var currentIndices = [];\r\n    var undoFunc = exports.deleteTraces;\r\n    var redoFunc = addTraces;\r\n    var undoArgs = [gd, currentIndices];\r\n    var redoArgs = [gd, traces];  // no newIndices here\r\n    var i;\r\n    var promise;\r\n\r\n    // all validation is done elsewhere to remove clutter here\r\n    checkAddTracesArgs(gd, traces, newIndices);\r\n\r\n    // make sure traces is an array\r\n    if(!Array.isArray(traces)) {\r\n        traces = [traces];\r\n    }\r\n\r\n    // make sure traces do not repeat existing ones\r\n    traces = traces.map(function(trace) {\r\n        return Lib.extendFlat({}, trace);\r\n    });\r\n\r\n    helpers.cleanData(traces);\r\n\r\n    // add the traces to gd.data (no redrawing yet!)\r\n    for(i = 0; i < traces.length; i++) {\r\n        gd.data.push(traces[i]);\r\n    }\r\n\r\n    // to continue, we need to call moveTraces which requires currentIndices\r\n    for(i = 0; i < traces.length; i++) {\r\n        currentIndices.push(-traces.length + i);\r\n    }\r\n\r\n    // if the user didn't define newIndices, they just want the traces appended\r\n    // i.e., we can simply redraw and be done\r\n    if(typeof newIndices === 'undefined') {\r\n        promise = exports.redraw(gd);\r\n        Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\r\n        return promise;\r\n    }\r\n\r\n    // make sure indices is property defined\r\n    if(!Array.isArray(newIndices)) {\r\n        newIndices = [newIndices];\r\n    }\r\n\r\n    try {\r\n        // this is redundant, but necessary to not catch later possible errors!\r\n        checkMoveTracesArgs(gd, currentIndices, newIndices);\r\n    } catch(error) {\r\n        // something went wrong, reset gd to be safe and rethrow error\r\n        gd.data.splice(gd.data.length - traces.length, traces.length);\r\n        throw error;\r\n    }\r\n\r\n    // if we're here, the user has defined specific places to place the new traces\r\n    // this requires some extra work that moveTraces will do\r\n    Queue.startSequence(gd);\r\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\r\n    promise = exports.moveTraces(gd, currentIndices, newIndices);\r\n    Queue.stopSequence(gd);\r\n    return promise;\r\n}\r\n\r\n/**\r\n * Delete traces at `indices` from gd.data array.\r\n *\r\n * @param {Object|HTMLDivElement} gd The graph div\r\n * @param {Object[]} gd.data The array of traces we're removing from\r\n * @param {Number|Number[]} indices The indices\r\n */\r\nfunction deleteTraces(gd, indices) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    var traces = [];\r\n    var undoFunc = exports.addTraces;\r\n    var redoFunc = deleteTraces;\r\n    var undoArgs = [gd, traces, indices];\r\n    var redoArgs = [gd, indices];\r\n    var i;\r\n    var deletedTrace;\r\n\r\n    // make sure indices are defined\r\n    if(typeof indices === 'undefined') {\r\n        throw new Error('indices must be an integer or array of integers.');\r\n    } else if(!Array.isArray(indices)) {\r\n        indices = [indices];\r\n    }\r\n    assertIndexArray(gd, indices, 'indices');\r\n\r\n    // convert negative indices to positive indices\r\n    indices = positivifyIndices(indices, gd.data.length - 1);\r\n\r\n    // we want descending here so that splicing later doesn't affect indexing\r\n    indices.sort(Lib.sorterDes);\r\n    for(i = 0; i < indices.length; i += 1) {\r\n        deletedTrace = gd.data.splice(indices[i], 1)[0];\r\n        traces.push(deletedTrace);\r\n    }\r\n\r\n    var promise = exports.redraw(gd);\r\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\r\n\r\n    return promise;\r\n}\r\n\r\n/**\r\n * Move traces at currentIndices array to locations in newIndices array.\r\n *\r\n * If newIndices is omitted, currentIndices will be moved to the end. E.g.,\r\n * these are equivalent:\r\n *\r\n * Plotly.moveTraces(gd, [1, 2, 3], [-3, -2, -1])\r\n * Plotly.moveTraces(gd, [1, 2, 3])\r\n *\r\n * @param {Object|HTMLDivElement} gd The graph div\r\n * @param {Object[]} gd.data The array of traces we're removing from\r\n * @param {Number|Number[]} currentIndices The locations of traces to be moved\r\n * @param {Number|Number[]} [newIndices] The locations to move traces to\r\n *\r\n * Example calls:\r\n *\r\n *      // move trace i to location x\r\n *      Plotly.moveTraces(gd, i, x)\r\n *\r\n *      // move trace i to end of array\r\n *      Plotly.moveTraces(gd, i)\r\n *\r\n *      // move traces i, j, k to end of array (i != j != k)\r\n *      Plotly.moveTraces(gd, [i, j, k])\r\n *\r\n *      // move traces [i, j, k] to [x, y, z] (i != j != k) (x != y != z)\r\n *      Plotly.moveTraces(gd, [i, j, k], [x, y, z])\r\n *\r\n *      // reorder all traces (assume there are 5--a, b, c, d, e)\r\n *      Plotly.moveTraces(gd, [b, d, e, a, c])  // same as 'move to end'\r\n */\r\nfunction moveTraces(gd, currentIndices, newIndices) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    var newData = [];\r\n    var movingTraceMap = [];\r\n    var undoFunc = moveTraces;\r\n    var redoFunc = moveTraces;\r\n    var undoArgs = [gd, newIndices, currentIndices];\r\n    var redoArgs = [gd, currentIndices, newIndices];\r\n    var i;\r\n\r\n    // to reduce complexity here, check args elsewhere\r\n    // this throws errors where appropriate\r\n    checkMoveTracesArgs(gd, currentIndices, newIndices);\r\n\r\n    // make sure currentIndices is an array\r\n    currentIndices = Array.isArray(currentIndices) ? currentIndices : [currentIndices];\r\n\r\n    // if undefined, define newIndices to point to the end of gd.data array\r\n    if(typeof newIndices === 'undefined') {\r\n        newIndices = [];\r\n        for(i = 0; i < currentIndices.length; i++) {\r\n            newIndices.push(-currentIndices.length + i);\r\n        }\r\n    }\r\n\r\n    // make sure newIndices is an array if it's user-defined\r\n    newIndices = Array.isArray(newIndices) ? newIndices : [newIndices];\r\n\r\n    // convert negative indices to positive indices (they're the same length)\r\n    currentIndices = positivifyIndices(currentIndices, gd.data.length - 1);\r\n    newIndices = positivifyIndices(newIndices, gd.data.length - 1);\r\n\r\n    // at this point, we've coerced the index arrays into predictable forms\r\n\r\n    // get the traces that aren't being moved around\r\n    for(i = 0; i < gd.data.length; i++) {\r\n        // if index isn't in currentIndices, include it in ignored!\r\n        if(currentIndices.indexOf(i) === -1) {\r\n            newData.push(gd.data[i]);\r\n        }\r\n    }\r\n\r\n    // get a mapping of indices to moving traces\r\n    for(i = 0; i < currentIndices.length; i++) {\r\n        movingTraceMap.push({newIndex: newIndices[i], trace: gd.data[currentIndices[i]]});\r\n    }\r\n\r\n    // reorder this mapping by newIndex, ascending\r\n    movingTraceMap.sort(function(a, b) {\r\n        return a.newIndex - b.newIndex;\r\n    });\r\n\r\n    // now, add the moving traces back in, in order!\r\n    for(i = 0; i < movingTraceMap.length; i += 1) {\r\n        newData.splice(movingTraceMap[i].newIndex, 0, movingTraceMap[i].trace);\r\n    }\r\n\r\n    gd.data = newData;\r\n\r\n    var promise = exports.redraw(gd);\r\n    Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\r\n\r\n    return promise;\r\n}\r\n\r\n/**\r\n * restyle: update trace attributes of an existing plot\r\n *\r\n * Can be called two ways.\r\n *\r\n * Signature 1:\r\n * @param {String | HTMLDivElement} gd\r\n *  the id or DOM element of the graph container div\r\n * @param {String} astr\r\n *  attribute string (like `'marker.symbol'`) to update\r\n * @param {*} val\r\n *  value to give this attribute\r\n * @param {Number[] | Number} [traces]\r\n *  integer or array of integers for the traces to alter (all if omitted)\r\n *\r\n * Signature 2:\r\n * @param {String | HTMLDivElement} gd\r\n *  (as in signature 1)\r\n * @param {Object} aobj\r\n *  attribute object `{astr1: val1, astr2: val2 ...}`\r\n *  allows setting multiple attributes simultaneously\r\n * @param {Number[] | Number} [traces]\r\n *  (as in signature 1)\r\n *\r\n * `val` (or `val1`, `val2` ... in the object form) can be an array,\r\n * to apply different values to each trace.\r\n *\r\n * If the array is too short, it will wrap around (useful for\r\n * style files that want to specify cyclical default values).\r\n */\r\nfunction restyle(gd, astr, val, _traces) {\r\n    gd = Lib.getGraphDiv(gd);\r\n    helpers.clearPromiseQueue(gd);\r\n\r\n    var aobj = {};\r\n    if(typeof astr === 'string') aobj[astr] = val;\r\n    else if(Lib.isPlainObject(astr)) {\r\n        // the 3-arg form\r\n        aobj = Lib.extendFlat({}, astr);\r\n        if(_traces === undefined) _traces = val;\r\n    } else {\r\n        Lib.warn('Restyle fail.', astr, val, _traces);\r\n        return Promise.reject();\r\n    }\r\n\r\n    if(Object.keys(aobj).length) gd.changed = true;\r\n\r\n    var traces = helpers.coerceTraceIndices(gd, _traces);\r\n\r\n    var specs = _restyle(gd, aobj, traces);\r\n    var flags = specs.flags;\r\n\r\n    // clear calcdata and/or axis types if required so they get regenerated\r\n    if(flags.calc) gd.calcdata = undefined;\r\n    if(flags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, {});\r\n\r\n    // fill in redraw sequence\r\n    var seq = [];\r\n\r\n    if(flags.fullReplot) {\r\n        seq.push(exports._doPlot);\r\n    } else {\r\n        seq.push(Plots.previousPromises);\r\n\r\n        // maybe only call Plots.supplyDataDefaults in the splom case,\r\n        // to skip over long and slow axes defaults\r\n        Plots.supplyDefaults(gd);\r\n\r\n        if(flags.markerSize) {\r\n            Plots.doCalcdata(gd);\r\n            addAxRangeSequence(seq);\r\n\r\n            // TODO\r\n            // if all axes have autorange:false, then\r\n            // proceed to subroutines.doTraceStyle(),\r\n            // otherwise we must go through addAxRangeSequence,\r\n            // which in general must redraws 'all' axes\r\n        }\r\n\r\n        if(flags.style) seq.push(subroutines.doTraceStyle);\r\n        if(flags.colorbars) seq.push(subroutines.doColorBars);\r\n\r\n        seq.push(emitAfterPlot);\r\n    }\r\n\r\n    seq.push(Plots.rehover, Plots.redrag);\r\n\r\n    Queue.add(gd,\r\n        restyle, [gd, specs.undoit, specs.traces],\r\n        restyle, [gd, specs.redoit, specs.traces]\r\n    );\r\n\r\n    var plotDone = Lib.syncOrAsync(seq, gd);\r\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve();\r\n\r\n    return plotDone.then(function() {\r\n        gd.emit('plotly_restyle', specs.eventData);\r\n        return gd;\r\n    });\r\n}\r\n\r\n// for undo: undefined initial vals must be turned into nulls\r\n// so that we unset rather than ignore them\r\nfunction undefinedToNull(val) {\r\n    if(val === undefined) return null;\r\n    return val;\r\n}\r\n\r\n/**\r\n * Factory function to wrap nestedProperty with GUI edits if necessary\r\n * with GUI edits we add an optional prefix to the nestedProperty constructor\r\n * to prepend to the attribute string in the preGUI store.\r\n */\r\nfunction makeNP(preGUI, guiEditFlag) {\r\n    if(!guiEditFlag) return nestedProperty;\r\n\r\n    return function(container, attr, prefix) {\r\n        var np = nestedProperty(container, attr);\r\n        var npSet = np.set;\r\n        np.set = function(val) {\r\n            var fullAttr = (prefix || '') + attr;\r\n            storeCurrent(fullAttr, np.get(), val, preGUI);\r\n            npSet(val);\r\n        };\r\n        return np;\r\n    };\r\n}\r\n\r\nfunction storeCurrent(attr, val, newVal, preGUI) {\r\n    if(Array.isArray(val) || Array.isArray(newVal)) {\r\n        var arrayVal = Array.isArray(val) ? val : [];\r\n        var arrayNew = Array.isArray(newVal) ? newVal : [];\r\n        var maxLen = Math.max(arrayVal.length, arrayNew.length);\r\n        for(var i = 0; i < maxLen; i++) {\r\n            storeCurrent(attr + '[' + i + ']', arrayVal[i], arrayNew[i], preGUI);\r\n        }\r\n    } else if(Lib.isPlainObject(val) || Lib.isPlainObject(newVal)) {\r\n        var objVal = Lib.isPlainObject(val) ? val : {};\r\n        var objNew = Lib.isPlainObject(newVal) ? newVal : {};\r\n        var objBoth = Lib.extendFlat({}, objVal, objNew);\r\n        for(var key in objBoth) {\r\n            storeCurrent(attr + '.' + key, objVal[key], objNew[key], preGUI);\r\n        }\r\n    } else if(preGUI[attr] === undefined) {\r\n        preGUI[attr] = undefinedToNull(val);\r\n    }\r\n}\r\n\r\n/**\r\n * storeDirectGUIEdit: for routines that skip restyle/relayout and mock it\r\n * by emitting a plotly_restyle or plotly_relayout event, this routine\r\n * keeps track of the initial state in _preGUI for use by uirevision\r\n * Does *not* apply these changes to data/layout - that's the responsibility\r\n * of the calling routine.\r\n *\r\n * @param {object} container: the input attributes container (eg `layout` or a `trace`)\r\n * @param {object} preGUI: where original values should be stored, either\r\n *     `layout._preGUI` or `layout._tracePreGUI[uid]`\r\n * @param {object} edits: the {attr: val} object as normally passed to `relayout` etc\r\n */\r\nfunction _storeDirectGUIEdit(container, preGUI, edits) {\r\n    for(var attr in edits) {\r\n        var np = nestedProperty(container, attr);\r\n        storeCurrent(attr, np.get(), edits[attr], preGUI);\r\n    }\r\n}\r\n\r\nfunction _restyle(gd, aobj, traces) {\r\n    var fullLayout = gd._fullLayout;\r\n    var fullData = gd._fullData;\r\n    var data = gd.data;\r\n    var guiEditFlag = fullLayout._guiEditing;\r\n    var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\r\n    var eventData = Lib.extendDeepAll({}, aobj);\r\n    var i;\r\n\r\n    cleanDeprecatedAttributeKeys(aobj);\r\n\r\n    // initialize flags\r\n    var flags = editTypes.traceFlags();\r\n\r\n    // copies of the change (and previous values of anything affected)\r\n    // for the undo / redo queue\r\n    var redoit = {};\r\n    var undoit = {};\r\n    var axlist;\r\n\r\n    // make a new empty vals array for undoit\r\n    function a0() { return traces.map(function() { return undefined; }); }\r\n\r\n    // for autoranging multiple axes\r\n    function addToAxlist(axid) {\r\n        var axName = Axes.id2name(axid);\r\n        if(axlist.indexOf(axName) === -1) axlist.push(axName);\r\n    }\r\n\r\n    function autorangeAttr(axName) { return 'LAYOUT' + axName + '.autorange'; }\r\n\r\n    function rangeAttr(axName) { return 'LAYOUT' + axName + '.range'; }\r\n\r\n    function getFullTrace(traceIndex) {\r\n        // usually fullData maps 1:1 onto data, but with groupby transforms\r\n        // the fullData index can be greater. Take the *first* matching trace.\r\n        for(var j = traceIndex; j < fullData.length; j++) {\r\n            if(fullData[j]._input === data[traceIndex]) return fullData[j];\r\n        }\r\n        // should never get here - and if we *do* it should cause an error\r\n        // later on undefined fullTrace is passed to nestedProperty.\r\n    }\r\n\r\n    // for attrs that interact (like scales & autoscales), save the\r\n    // old vals before making the change\r\n    // val=undefined will not set a value, just record what the value was.\r\n    // val=null will delete the attribute\r\n    // attr can be an array to set several at once (all to the same val)\r\n    function doextra(attr, val, i) {\r\n        if(Array.isArray(attr)) {\r\n            attr.forEach(function(a) { doextra(a, val, i); });\r\n            return;\r\n        }\r\n        // quit if explicitly setting this elsewhere\r\n        if(attr in aobj || helpers.hasParent(aobj, attr)) return;\r\n\r\n        var extraparam;\r\n        if(attr.substr(0, 6) === 'LAYOUT') {\r\n            extraparam = layoutNP(gd.layout, attr.replace('LAYOUT', ''));\r\n        } else {\r\n            var tracei = traces[i];\r\n            var preGUI = fullLayout._tracePreGUI[getFullTrace(tracei)._fullInput.uid];\r\n            extraparam = makeNP(preGUI, guiEditFlag)(data[tracei], attr);\r\n        }\r\n\r\n        if(!(attr in undoit)) {\r\n            undoit[attr] = a0();\r\n        }\r\n        if(undoit[attr][i] === undefined) {\r\n            undoit[attr][i] = undefinedToNull(extraparam.get());\r\n        }\r\n        if(val !== undefined) {\r\n            extraparam.set(val);\r\n        }\r\n    }\r\n\r\n    function allBins(binAttr) {\r\n        return function(j) {\r\n            return fullData[j][binAttr];\r\n        };\r\n    }\r\n\r\n    function arrayBins(binAttr) {\r\n        return function(vij, j) {\r\n            return vij === false ? fullData[traces[j]][binAttr] : null;\r\n        };\r\n    }\r\n\r\n    // now make the changes to gd.data (and occasionally gd.layout)\r\n    // and figure out what kind of graphics update we need to do\r\n    for(var ai in aobj) {\r\n        if(helpers.hasParent(aobj, ai)) {\r\n            throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\r\n        }\r\n\r\n        var vi = aobj[ai];\r\n        var cont;\r\n        var contFull;\r\n        var param;\r\n        var oldVal;\r\n        var newVal;\r\n        var valObject;\r\n\r\n        // Backward compatibility shim for turning histogram autobin on,\r\n        // or freezing previous autobinned values.\r\n        // Replace obsolete `autobin(x|y): true` with `(x|y)bins: null`\r\n        // and `autobin(x|y): false` with the `(x|y)bins` in `fullData`\r\n        if(ai === 'autobinx' || ai === 'autobiny') {\r\n            ai = ai.charAt(ai.length - 1) + 'bins';\r\n            if(Array.isArray(vi)) vi = vi.map(arrayBins(ai));\r\n            else if(vi === false) vi = traces.map(allBins(ai));\r\n            else vi = null;\r\n        }\r\n\r\n        redoit[ai] = vi;\r\n\r\n        if(ai.substr(0, 6) === 'LAYOUT') {\r\n            param = layoutNP(gd.layout, ai.replace('LAYOUT', ''));\r\n            undoit[ai] = [undefinedToNull(param.get())];\r\n            // since we're allowing val to be an array, allow it here too,\r\n            // even though that's meaningless\r\n            param.set(Array.isArray(vi) ? vi[0] : vi);\r\n            // ironically, the layout attrs in restyle only require replot,\r\n            // not relayout\r\n            flags.calc = true;\r\n            continue;\r\n        }\r\n\r\n        // set attribute in gd.data\r\n        undoit[ai] = a0();\r\n        for(i = 0; i < traces.length; i++) {\r\n            cont = data[traces[i]];\r\n            contFull = getFullTrace(traces[i]);\r\n            var preGUI = fullLayout._tracePreGUI[contFull._fullInput.uid];\r\n            param = makeNP(preGUI, guiEditFlag)(cont, ai);\r\n            oldVal = param.get();\r\n            newVal = Array.isArray(vi) ? vi[i % vi.length] : vi;\r\n\r\n            if(newVal === undefined) continue;\r\n\r\n            var finalPart = param.parts[param.parts.length - 1];\r\n            var prefix = ai.substr(0, ai.length - finalPart.length - 1);\r\n            var prefixDot = prefix ? prefix + '.' : '';\r\n            var innerContFull = prefix ?\r\n                nestedProperty(contFull, prefix).get() : contFull;\r\n\r\n            valObject = PlotSchema.getTraceValObject(contFull, param.parts);\r\n\r\n            if(valObject && valObject.impliedEdits && newVal !== null) {\r\n                for(var impliedKey in valObject.impliedEdits) {\r\n                    doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey], i);\r\n                }\r\n            } else if((finalPart === 'thicknessmode' || finalPart === 'lenmode') &&\r\n                    oldVal !== newVal &&\r\n                    (newVal === 'fraction' || newVal === 'pixels') &&\r\n                    innerContFull\r\n            ) {\r\n                // changing colorbar size modes,\r\n                // make the resulting size not change\r\n                // note that colorbar fractional sizing is based on the\r\n                // original plot size, before anything (like a colorbar)\r\n                // increases the margins\r\n\r\n                var gs = fullLayout._size;\r\n                var orient = innerContFull.orient;\r\n                var topOrBottom = (orient === 'top') || (orient === 'bottom');\r\n                if(finalPart === 'thicknessmode') {\r\n                    var thicknorm = topOrBottom ? gs.h : gs.w;\r\n                    doextra(prefixDot + 'thickness', innerContFull.thickness *\r\n                        (newVal === 'fraction' ? 1 / thicknorm : thicknorm), i);\r\n                } else {\r\n                    var lennorm = topOrBottom ? gs.w : gs.h;\r\n                    doextra(prefixDot + 'len', innerContFull.len *\r\n                        (newVal === 'fraction' ? 1 / lennorm : lennorm), i);\r\n                }\r\n            } else if(ai === 'type' && (\r\n                (newVal === 'pie') !== (oldVal === 'pie') ||\r\n                (newVal === 'funnelarea') !== (oldVal === 'funnelarea')\r\n            )) {\r\n                var labelsTo = 'x';\r\n                var valuesTo = 'y';\r\n                if((newVal === 'bar' || oldVal === 'bar') && cont.orientation === 'h') {\r\n                    labelsTo = 'y';\r\n                    valuesTo = 'x';\r\n                }\r\n                Lib.swapAttrs(cont, ['?', '?src'], 'labels', labelsTo);\r\n                Lib.swapAttrs(cont, ['d?', '?0'], 'label', labelsTo);\r\n                Lib.swapAttrs(cont, ['?', '?src'], 'values', valuesTo);\r\n\r\n                if(oldVal === 'pie' || oldVal === 'funnelarea') {\r\n                    nestedProperty(cont, 'marker.color')\r\n                        .set(nestedProperty(cont, 'marker.colors').get());\r\n\r\n                    // super kludgy - but if all pies are gone we won't remove them otherwise\r\n                    fullLayout._pielayer.selectAll('g.trace').remove();\r\n                } else if(Registry.traceIs(cont, 'cartesian')) {\r\n                    nestedProperty(cont, 'marker.colors')\r\n                        .set(nestedProperty(cont, 'marker.color').get());\r\n                }\r\n            }\r\n\r\n            undoit[ai][i] = undefinedToNull(oldVal);\r\n            // set the new value - if val is an array, it's one el per trace\r\n            // first check for attributes that get more complex alterations\r\n            var swapAttrs = [\r\n                'swapxy', 'swapxyaxes', 'orientation', 'orientationaxes'\r\n            ];\r\n            if(swapAttrs.indexOf(ai) !== -1) {\r\n                // setting an orientation: make sure it's changing\r\n                // before we swap everything else\r\n                if(ai === 'orientation') {\r\n                    param.set(newVal);\r\n                    // obnoxious that we need this level of coupling... but in order to\r\n                    // properly handle setting orientation to `null` we need to mimic\r\n                    // the logic inside Bars.supplyDefaults for default orientation\r\n                    var defaultOrientation = (cont.x && !cont.y) ? 'h' : 'v';\r\n                    if((param.get() || defaultOrientation) === contFull.orientation) {\r\n                        continue;\r\n                    }\r\n                } else if(ai === 'orientationaxes') {\r\n                    // orientationaxes has no value,\r\n                    // it flips everything and the axes\r\n\r\n                    cont.orientation =\r\n                        {v: 'h', h: 'v'}[contFull.orientation];\r\n                }\r\n                helpers.swapXYData(cont);\r\n                flags.calc = flags.clearAxisTypes = true;\r\n            } else if(Plots.dataArrayContainers.indexOf(param.parts[0]) !== -1) {\r\n                // TODO: use manageArrays.applyContainerArrayChanges here too\r\n                helpers.manageArrayContainers(param, newVal, undoit);\r\n                flags.calc = true;\r\n            } else {\r\n                if(valObject) {\r\n                    // must redo calcdata when restyling array values of arrayOk attributes\r\n                    // ... but no need to this for regl-based traces\r\n                    if(valObject.arrayOk &&\r\n                        !Registry.traceIs(contFull, 'regl') &&\r\n                        (Lib.isArrayOrTypedArray(newVal) || Lib.isArrayOrTypedArray(oldVal))\r\n                    ) {\r\n                        flags.calc = true;\r\n                    } else editTypes.update(flags, valObject);\r\n                } else {\r\n                    /*\r\n                     * if we couldn't find valObject,  assume a full recalc.\r\n                     * This can happen if you're changing type and making\r\n                     * some other edits too, so the modules we're\r\n                     * looking at don't have these attributes in them.\r\n                     */\r\n                    flags.calc = true;\r\n                }\r\n\r\n                // all the other ones, just modify that one attribute\r\n                param.set(newVal);\r\n            }\r\n        }\r\n\r\n        // swap the data attributes of the relevant x and y axes?\r\n        if(['swapxyaxes', 'orientationaxes'].indexOf(ai) !== -1) {\r\n            Axes.swap(gd, traces);\r\n        }\r\n\r\n        // swap hovermode if set to \"compare x/y data\"\r\n        if(ai === 'orientationaxes') {\r\n            var hovermode = nestedProperty(gd.layout, 'hovermode');\r\n            var h = hovermode.get();\r\n            if(h === 'x') {\r\n                hovermode.set('y');\r\n            } else if(h === 'y') {\r\n                hovermode.set('x');\r\n            } else if(h === 'x unified') {\r\n                hovermode.set('y unified');\r\n            } else if(h === 'y unified') {\r\n                hovermode.set('x unified');\r\n            }\r\n        }\r\n\r\n        // Major enough changes deserve autoscale and\r\n        // non-reversed axes so people don't get confused\r\n        //\r\n        // Note: autobin (or its new analog bin clearing) is not included here\r\n        // since we're not pushing bins back to gd.data, so if we have bin\r\n        // info it was explicitly provided by the user.\r\n        if(['orientation', 'type'].indexOf(ai) !== -1) {\r\n            axlist = [];\r\n            for(i = 0; i < traces.length; i++) {\r\n                var trace = data[traces[i]];\r\n\r\n                if(Registry.traceIs(trace, 'cartesian')) {\r\n                    addToAxlist(trace.xaxis || 'x');\r\n                    addToAxlist(trace.yaxis || 'y');\r\n                }\r\n            }\r\n\r\n            doextra(axlist.map(autorangeAttr), true, 0);\r\n            doextra(axlist.map(rangeAttr), [0, 1], 0);\r\n        }\r\n    }\r\n\r\n    if(flags.calc || flags.plot) {\r\n        flags.fullReplot = true;\r\n    }\r\n\r\n    return {\r\n        flags: flags,\r\n        undoit: undoit,\r\n        redoit: redoit,\r\n        traces: traces,\r\n        eventData: Lib.extendDeepNoArrays([], [eventData, traces])\r\n    };\r\n}\r\n\r\n/**\r\n * Converts deprecated attribute keys to\r\n * the current API to ensure backwards compatibility.\r\n *\r\n * This is needed for the update mechanism to determine which\r\n * subroutines to run based on the actual attribute\r\n * definitions (that don't include the deprecated ones).\r\n *\r\n * E.g. Maps {'xaxis.title': 'A chart'} to {'xaxis.title.text': 'A chart'}\r\n * and {titlefont: {...}} to {'title.font': {...}}.\r\n *\r\n * @param aobj\r\n */\r\nfunction cleanDeprecatedAttributeKeys(aobj) {\r\n    var oldAxisTitleRegex = Lib.counterRegex('axis', '\\.title', false, false);\r\n    var colorbarRegex = /colorbar\\.title$/;\r\n    var keys = Object.keys(aobj);\r\n    var i, key, value;\r\n\r\n    for(i = 0; i < keys.length; i++) {\r\n        key = keys[i];\r\n        value = aobj[key];\r\n\r\n        if((key === 'title' || oldAxisTitleRegex.test(key) || colorbarRegex.test(key)) &&\r\n          (typeof value === 'string' || typeof value === 'number')) {\r\n            replace(key, key.replace('title', 'title.text'));\r\n        } else if(key.indexOf('titlefont') > -1) {\r\n            replace(key, key.replace('titlefont', 'title.font'));\r\n        } else if(key.indexOf('titleposition') > -1) {\r\n            replace(key, key.replace('titleposition', 'title.position'));\r\n        } else if(key.indexOf('titleside') > -1) {\r\n            replace(key, key.replace('titleside', 'title.side'));\r\n        } else if(key.indexOf('titleoffset') > -1) {\r\n            replace(key, key.replace('titleoffset', 'title.offset'));\r\n        }\r\n    }\r\n\r\n    function replace(oldAttrStr, newAttrStr) {\r\n        aobj[newAttrStr] = aobj[oldAttrStr];\r\n        delete aobj[oldAttrStr];\r\n    }\r\n}\r\n\r\n/**\r\n * relayout: update layout attributes of an existing plot\r\n *\r\n * Can be called two ways:\r\n *\r\n * Signature 1:\r\n * @param {String | HTMLDivElement} gd\r\n *  the id or dom element of the graph container div\r\n * @param {String} astr\r\n *  attribute string (like `'xaxis.range[0]'`) to update\r\n * @param {*} val\r\n *  value to give this attribute\r\n *\r\n * Signature 2:\r\n * @param {String | HTMLDivElement} gd\r\n *  (as in signature 1)\r\n * @param {Object} aobj\r\n *  attribute object `{astr1: val1, astr2: val2 ...}`\r\n *  allows setting multiple attributes simultaneously\r\n */\r\nfunction relayout(gd, astr, val) {\r\n    gd = Lib.getGraphDiv(gd);\r\n    helpers.clearPromiseQueue(gd);\r\n\r\n    var aobj = {};\r\n    if(typeof astr === 'string') {\r\n        aobj[astr] = val;\r\n    } else if(Lib.isPlainObject(astr)) {\r\n        aobj = Lib.extendFlat({}, astr);\r\n    } else {\r\n        Lib.warn('Relayout fail.', astr, val);\r\n        return Promise.reject();\r\n    }\r\n\r\n    if(Object.keys(aobj).length) gd.changed = true;\r\n\r\n    var specs = _relayout(gd, aobj);\r\n    var flags = specs.flags;\r\n\r\n    // clear calcdata if required\r\n    if(flags.calc) gd.calcdata = undefined;\r\n\r\n    // fill in redraw sequence\r\n\r\n    // even if we don't have anything left in aobj,\r\n    // something may have happened within relayout that we\r\n    // need to wait for\r\n    var seq = [Plots.previousPromises];\r\n\r\n    if(flags.layoutReplot) {\r\n        seq.push(subroutines.layoutReplot);\r\n    } else if(Object.keys(aobj).length) {\r\n        axRangeSupplyDefaultsByPass(gd, flags, specs) || Plots.supplyDefaults(gd);\r\n\r\n        if(flags.legend) seq.push(subroutines.doLegend);\r\n        if(flags.layoutstyle) seq.push(subroutines.layoutStyles);\r\n        if(flags.axrange) addAxRangeSequence(seq, specs.rangesAltered);\r\n        if(flags.ticks) seq.push(subroutines.doTicksRelayout);\r\n        if(flags.modebar) seq.push(subroutines.doModeBar);\r\n        if(flags.camera) seq.push(subroutines.doCamera);\r\n        if(flags.colorbars) seq.push(subroutines.doColorBars);\r\n\r\n        seq.push(emitAfterPlot);\r\n    }\r\n\r\n    seq.push(Plots.rehover, Plots.redrag);\r\n\r\n    Queue.add(gd,\r\n        relayout, [gd, specs.undoit],\r\n        relayout, [gd, specs.redoit]\r\n    );\r\n\r\n    var plotDone = Lib.syncOrAsync(seq, gd);\r\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\r\n\r\n    return plotDone.then(function() {\r\n        gd.emit('plotly_relayout', specs.eventData);\r\n        return gd;\r\n    });\r\n}\r\n\r\n// Optimization mostly for large splom traces where\r\n// Plots.supplyDefaults can take > 100ms\r\nfunction axRangeSupplyDefaultsByPass(gd, flags, specs) {\r\n    var fullLayout = gd._fullLayout;\r\n\r\n    if(!flags.axrange) return false;\r\n\r\n    for(var k in flags) {\r\n        if(k !== 'axrange' && flags[k]) return false;\r\n    }\r\n\r\n    for(var axId in specs.rangesAltered) {\r\n        var axName = Axes.id2name(axId);\r\n        var axIn = gd.layout[axName];\r\n        var axOut = fullLayout[axName];\r\n        axOut.autorange = axIn.autorange;\r\n        if(axIn.range) {\r\n            axOut.range = axIn.range.slice();\r\n        }\r\n        axOut.cleanRange();\r\n\r\n        if(axOut._matchGroup) {\r\n            for(var axId2 in axOut._matchGroup) {\r\n                if(axId2 !== axId) {\r\n                    var ax2 = fullLayout[Axes.id2name(axId2)];\r\n                    ax2.autorange = axOut.autorange;\r\n                    ax2.range = axOut.range.slice();\r\n                    ax2._input.range = axOut.range.slice();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nfunction addAxRangeSequence(seq, rangesAltered) {\r\n    // N.B. leave as sequence of subroutines (for now) instead of\r\n    // subroutine of its own so that finalDraw always gets\r\n    // executed after drawData\r\n    var drawAxes = rangesAltered ?\r\n        function(gd) {\r\n            var axIds = [];\r\n            var skipTitle = true;\r\n\r\n            for(var id in rangesAltered) {\r\n                var ax = Axes.getFromId(gd, id);\r\n                axIds.push(id);\r\n\r\n                if((ax.ticklabelposition || '').indexOf('inside') !== -1) {\r\n                    if(ax._anchorAxis) {\r\n                        axIds.push(ax._anchorAxis._id);\r\n                    }\r\n                }\r\n\r\n                if(ax._matchGroup) {\r\n                    for(var id2 in ax._matchGroup) {\r\n                        if(!rangesAltered[id2]) {\r\n                            axIds.push(id2);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(ax.automargin) skipTitle = false;\r\n            }\r\n\r\n            return Axes.draw(gd, axIds, {skipTitle: skipTitle});\r\n        } :\r\n        function(gd) {\r\n            return Axes.draw(gd, 'redraw');\r\n        };\r\n\r\n    seq.push(\r\n        clearSelect,\r\n        subroutines.doAutoRangeAndConstraints,\r\n        drawAxes,\r\n        subroutines.drawData,\r\n        subroutines.finalDraw\r\n    );\r\n}\r\n\r\nvar AX_RANGE_RE = /^[xyz]axis[0-9]*\\.range(\\[[0|1]\\])?$/;\r\nvar AX_AUTORANGE_RE = /^[xyz]axis[0-9]*\\.autorange$/;\r\nvar AX_DOMAIN_RE = /^[xyz]axis[0-9]*\\.domain(\\[[0|1]\\])?$/;\r\n\r\nfunction _relayout(gd, aobj) {\r\n    var layout = gd.layout;\r\n    var fullLayout = gd._fullLayout;\r\n    var guiEditFlag = fullLayout._guiEditing;\r\n    var layoutNP = makeNP(fullLayout._preGUI, guiEditFlag);\r\n    var keys = Object.keys(aobj);\r\n    var axes = Axes.list(gd);\r\n    var eventData = Lib.extendDeepAll({}, aobj);\r\n    var arrayEdits = {};\r\n\r\n    var arrayStr, i, j;\r\n\r\n    cleanDeprecatedAttributeKeys(aobj);\r\n    keys = Object.keys(aobj);\r\n\r\n    // look for 'allaxes', split out into all axes\r\n    // in case of 3D the axis are nested within a scene which is held in _id\r\n    for(i = 0; i < keys.length; i++) {\r\n        if(keys[i].indexOf('allaxes') === 0) {\r\n            for(j = 0; j < axes.length; j++) {\r\n                var scene = axes[j]._id.substr(1);\r\n                var axisAttr = (scene.indexOf('scene') !== -1) ? (scene + '.') : '';\r\n                var newkey = keys[i].replace('allaxes', axisAttr + axes[j]._name);\r\n\r\n                if(!aobj[newkey]) aobj[newkey] = aobj[keys[i]];\r\n            }\r\n\r\n            delete aobj[keys[i]];\r\n        }\r\n    }\r\n\r\n    // initialize flags\r\n    var flags = editTypes.layoutFlags();\r\n\r\n    // copies of the change (and previous values of anything affected)\r\n    // for the undo / redo queue\r\n    var redoit = {};\r\n    var undoit = {};\r\n\r\n    // for attrs that interact (like scales & autoscales), save the\r\n    // old vals before making the change\r\n    // val=undefined will not set a value, just record what the value was.\r\n    // attr can be an array to set several at once (all to the same val)\r\n    function doextra(attr, val) {\r\n        if(Array.isArray(attr)) {\r\n            attr.forEach(function(a) { doextra(a, val); });\r\n            return;\r\n        }\r\n\r\n        // if we have another value for this attribute (explicitly or\r\n        // via a parent) do not override with this auto-generated extra\r\n        if(attr in aobj || helpers.hasParent(aobj, attr)) return;\r\n\r\n        var p = layoutNP(layout, attr);\r\n        if(!(attr in undoit)) {\r\n            undoit[attr] = undefinedToNull(p.get());\r\n        }\r\n        if(val !== undefined) p.set(val);\r\n    }\r\n\r\n    // for constraint enforcement: keep track of all axes (as {id: name})\r\n    // we're editing the (auto)range of, so we can tell the others constrained\r\n    // to scale with them that it's OK for them to shrink\r\n    var rangesAltered = {};\r\n    var ax;\r\n\r\n    function recordAlteredAxis(pleafPlus) {\r\n        var axId = Axes.name2id(pleafPlus.split('.')[0]);\r\n        rangesAltered[axId] = 1;\r\n        return axId;\r\n    }\r\n\r\n    // alter gd.layout\r\n    for(var ai in aobj) {\r\n        if(helpers.hasParent(aobj, ai)) {\r\n            throw new Error('cannot set ' + ai + ' and a parent attribute simultaneously');\r\n        }\r\n\r\n        var p = layoutNP(layout, ai);\r\n        var vi = aobj[ai];\r\n        var plen = p.parts.length;\r\n        // p.parts may end with an index integer if the property is an array\r\n        var pend = plen - 1;\r\n        while(pend > 0 && typeof p.parts[pend] !== 'string') pend--;\r\n        // last property in chain (leaf node)\r\n        var pleaf = p.parts[pend];\r\n        // leaf plus immediate parent\r\n        var pleafPlus = p.parts[pend - 1] + '.' + pleaf;\r\n        // trunk nodes (everything except the leaf)\r\n        var ptrunk = p.parts.slice(0, pend).join('.');\r\n        var parentIn = nestedProperty(gd.layout, ptrunk).get();\r\n        var parentFull = nestedProperty(fullLayout, ptrunk).get();\r\n        var vOld = p.get();\r\n\r\n        if(vi === undefined) continue;\r\n\r\n        redoit[ai] = vi;\r\n\r\n        // axis reverse is special - it is its own inverse\r\n        // op and has no flag.\r\n        undoit[ai] = (pleaf === 'reverse') ? vi : undefinedToNull(vOld);\r\n\r\n        var valObject = PlotSchema.getLayoutValObject(fullLayout, p.parts);\r\n\r\n        if(valObject && valObject.impliedEdits && vi !== null) {\r\n            for(var impliedKey in valObject.impliedEdits) {\r\n                doextra(Lib.relativeAttr(ai, impliedKey), valObject.impliedEdits[impliedKey]);\r\n            }\r\n        }\r\n\r\n        // Setting width or height to null must reset the graph's width / height\r\n        // back to its initial value as computed during the first pass in Plots.plotAutoSize.\r\n        //\r\n        // To do so, we must manually set them back here using the _initialAutoSize cache.\r\n        // can't use impliedEdits for this because behavior depends on vi\r\n        if(['width', 'height'].indexOf(ai) !== -1) {\r\n            if(vi) {\r\n                doextra('autosize', null);\r\n                // currently we don't support autosize one dim only - so\r\n                // explicitly set the other one. Note that doextra will\r\n                // ignore this if the same relayout call also provides oppositeAttr\r\n                var oppositeAttr = ai === 'height' ? 'width' : 'height';\r\n                doextra(oppositeAttr, fullLayout[oppositeAttr]);\r\n            } else {\r\n                fullLayout[ai] = gd._initialAutoSize[ai];\r\n            }\r\n        } else if(ai === 'autosize') {\r\n            // depends on vi here too, so again can't use impliedEdits\r\n            doextra('width', vi ? null : fullLayout.width);\r\n            doextra('height', vi ? null : fullLayout.height);\r\n        } else if(pleafPlus.match(AX_RANGE_RE)) {\r\n            // check autorange vs range\r\n\r\n            recordAlteredAxis(pleafPlus);\r\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\r\n        } else if(pleafPlus.match(AX_AUTORANGE_RE)) {\r\n            recordAlteredAxis(pleafPlus);\r\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\r\n            var axFull = nestedProperty(fullLayout, ptrunk).get();\r\n            if(axFull._inputDomain) {\r\n                // if we're autoranging and this axis has a constrained domain,\r\n                // reset it so we don't get locked into a shrunken size\r\n                axFull._input.domain = axFull._inputDomain.slice();\r\n            }\r\n        } else if(pleafPlus.match(AX_DOMAIN_RE)) {\r\n            nestedProperty(fullLayout, ptrunk + '._inputDomain').set(null);\r\n        }\r\n\r\n        // toggling axis type between log and linear: we need to convert\r\n        // positions for components that are still using linearized values,\r\n        // not data values like newer components.\r\n        // previously we did this for log <-> not-log, but now only do it\r\n        // for log <-> linear\r\n        if(pleaf === 'type') {\r\n            ax = parentIn;\r\n            var toLog = parentFull.type === 'linear' && vi === 'log';\r\n            var fromLog = parentFull.type === 'log' && vi === 'linear';\r\n\r\n            if(toLog || fromLog) {\r\n                if(!ax || !ax.range) {\r\n                    // 2D never gets here, but 3D does\r\n                    // I don't think this is needed, but left here in case there\r\n                    // are edge cases I'm not thinking of.\r\n                    doextra(ptrunk + '.autorange', true);\r\n                } else if(!parentFull.autorange) {\r\n                    // toggling log without autorange: need to also recalculate ranges\r\n                    // because log axes use linearized values for range endpoints\r\n                    var r0 = ax.range[0];\r\n                    var r1 = ax.range[1];\r\n                    if(toLog) {\r\n                        // if both limits are negative, autorange\r\n                        if(r0 <= 0 && r1 <= 0) {\r\n                            doextra(ptrunk + '.autorange', true);\r\n                        }\r\n                        // if one is negative, set it 6 orders below the other.\r\n                        if(r0 <= 0) r0 = r1 / 1e6;\r\n                        else if(r1 <= 0) r1 = r0 / 1e6;\r\n                        // now set the range values as appropriate\r\n                        doextra(ptrunk + '.range[0]', Math.log(r0) / Math.LN10);\r\n                        doextra(ptrunk + '.range[1]', Math.log(r1) / Math.LN10);\r\n                    } else {\r\n                        doextra(ptrunk + '.range[0]', Math.pow(10, r0));\r\n                        doextra(ptrunk + '.range[1]', Math.pow(10, r1));\r\n                    }\r\n                } else if(toLog) {\r\n                    // just make sure the range is positive and in the right\r\n                    // order, it'll get recalculated later\r\n                    ax.range = (ax.range[1] > ax.range[0]) ? [1, 2] : [2, 1];\r\n                }\r\n\r\n                // clear polar view initial stash for radial range so that\r\n                // value get recomputed in correct units\r\n                if(Array.isArray(fullLayout._subplots.polar) &&\r\n                    fullLayout._subplots.polar.length &&\r\n                    fullLayout[p.parts[0]] &&\r\n                    p.parts[1] === 'radialaxis'\r\n                ) {\r\n                    delete fullLayout[p.parts[0]]._subplot.viewInitial['radialaxis.range'];\r\n                }\r\n\r\n                // Annotations and images also need to convert to/from linearized coords\r\n                // Shapes do not need this :)\r\n                Registry.getComponentMethod('annotations', 'convertCoords')(gd, parentFull, vi, doextra);\r\n                Registry.getComponentMethod('images', 'convertCoords')(gd, parentFull, vi, doextra);\r\n            } else {\r\n                // any other type changes: the range from the previous type\r\n                // will not make sense, so autorange it.\r\n                doextra(ptrunk + '.autorange', true);\r\n                doextra(ptrunk + '.range', null);\r\n            }\r\n            nestedProperty(fullLayout, ptrunk + '._inputRange').set(null);\r\n        } else if(pleaf.match(AX_NAME_PATTERN)) {\r\n            var fullProp = nestedProperty(fullLayout, ai).get();\r\n            var newType = (vi || {}).type;\r\n\r\n            // This can potentially cause strange behavior if the autotype is not\r\n            // numeric (linear, because we don't auto-log) but the previous type\r\n            // was log. That's a very strange edge case though\r\n            if(!newType || newType === '-') newType = 'linear';\r\n            Registry.getComponentMethod('annotations', 'convertCoords')(gd, fullProp, newType, doextra);\r\n            Registry.getComponentMethod('images', 'convertCoords')(gd, fullProp, newType, doextra);\r\n        }\r\n\r\n        // alter gd.layout\r\n\r\n        // collect array component edits for execution all together\r\n        // so we can ensure consistent behavior adding/removing items\r\n        // and order-independence for add/remove/edit all together in\r\n        // one relayout call\r\n        var containerArrayMatch = manageArrays.containerArrayMatch(ai);\r\n        if(containerArrayMatch) {\r\n            arrayStr = containerArrayMatch.array;\r\n            i = containerArrayMatch.index;\r\n            var propStr = containerArrayMatch.property;\r\n            var updateValObject = valObject || {editType: 'calc'};\r\n\r\n            if(i !== '' && propStr === '') {\r\n                // special handling of undoit if we're adding or removing an element\r\n                // ie 'annotations[2]' which can be {...} (add) or null,\r\n                // does not work when replacing the entire array\r\n                if(manageArrays.isAddVal(vi)) {\r\n                    undoit[ai] = null;\r\n                } else if(manageArrays.isRemoveVal(vi)) {\r\n                    undoit[ai] = (nestedProperty(layout, arrayStr).get() || [])[i];\r\n                } else {\r\n                    Lib.warn('unrecognized full object value', aobj);\r\n                }\r\n            }\r\n            editTypes.update(flags, updateValObject);\r\n\r\n            // prepare the edits object we'll send to applyContainerArrayChanges\r\n            if(!arrayEdits[arrayStr]) arrayEdits[arrayStr] = {};\r\n            var objEdits = arrayEdits[arrayStr][i];\r\n            if(!objEdits) objEdits = arrayEdits[arrayStr][i] = {};\r\n            objEdits[propStr] = vi;\r\n\r\n            delete aobj[ai];\r\n        } else if(pleaf === 'reverse') {\r\n            // handle axis reversal explicitly, as there's no 'reverse' attribute\r\n\r\n            if(parentIn.range) parentIn.range.reverse();\r\n            else {\r\n                doextra(ptrunk + '.autorange', true);\r\n                parentIn.range = [1, 0];\r\n            }\r\n\r\n            if(parentFull.autorange) flags.calc = true;\r\n            else flags.plot = true;\r\n        } else {\r\n            if((fullLayout._has('scatter-like') && fullLayout._has('regl')) &&\r\n                (ai === 'dragmode' &&\r\n                (vi === 'lasso' || vi === 'select') &&\r\n                !(vOld === 'lasso' || vOld === 'select'))\r\n            ) {\r\n                flags.plot = true;\r\n            } else if(fullLayout._has('gl2d')) {\r\n                flags.plot = true;\r\n            } else if(valObject) editTypes.update(flags, valObject);\r\n            else flags.calc = true;\r\n\r\n            p.set(vi);\r\n        }\r\n    }\r\n\r\n    // now we've collected component edits - execute them all together\r\n    for(arrayStr in arrayEdits) {\r\n        var finished = manageArrays.applyContainerArrayChanges(gd,\r\n            layoutNP(layout, arrayStr), arrayEdits[arrayStr], flags, layoutNP);\r\n        if(!finished) flags.plot = true;\r\n    }\r\n\r\n    // figure out if we need to recalculate axis constraints\r\n    for(var axId in rangesAltered) {\r\n        ax = Axes.getFromId(gd, axId);\r\n        var group = ax && ax._constraintGroup;\r\n        if(group) {\r\n            // Always recalc if we're changing constrained ranges.\r\n            // Otherwise it's possible to violate the constraints by\r\n            // specifying arbitrary ranges for all axes in the group.\r\n            // this way some ranges may expand beyond what's specified,\r\n            // as they do at first draw, to satisfy the constraints.\r\n            flags.calc = true;\r\n            for(var groupAxId in group) {\r\n                if(!rangesAltered[groupAxId]) {\r\n                    Axes.getFromId(gd, groupAxId)._constraintShrinkable = true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // If the autosize changed or height or width was explicitly specified,\r\n    // this triggers a redraw\r\n    // TODO: do we really need special aobj.height/width handling here?\r\n    // couldn't editType do this?\r\n    if(updateAutosize(gd) || aobj.height || aobj.width) flags.plot = true;\r\n\r\n    if(flags.plot || flags.calc) {\r\n        flags.layoutReplot = true;\r\n    }\r\n\r\n    // now all attribute mods are done, as are\r\n    // redo and undo so we can save them\r\n\r\n    return {\r\n        flags: flags,\r\n        rangesAltered: rangesAltered,\r\n        undoit: undoit,\r\n        redoit: redoit,\r\n        eventData: eventData\r\n    };\r\n}\r\n\r\n/*\r\n * updateAutosize: we made a change, does it change the autosize result?\r\n * puts the new size into fullLayout\r\n * returns true if either height or width changed\r\n */\r\nfunction updateAutosize(gd) {\r\n    var fullLayout = gd._fullLayout;\r\n    var oldWidth = fullLayout.width;\r\n    var oldHeight = fullLayout.height;\r\n\r\n    // calculate autosizing\r\n    if(gd.layout.autosize) Plots.plotAutoSize(gd, gd.layout, fullLayout);\r\n\r\n    return (fullLayout.width !== oldWidth) || (fullLayout.height !== oldHeight);\r\n}\r\n\r\n/**\r\n * update: update trace and layout attributes of an existing plot\r\n *\r\n * @param {String | HTMLDivElement} gd\r\n *  the id or DOM element of the graph container div\r\n * @param {Object} traceUpdate\r\n *  attribute object `{astr1: val1, astr2: val2 ...}`\r\n *  corresponding to updates in the plot's traces\r\n * @param {Object} layoutUpdate\r\n *  attribute object `{astr1: val1, astr2: val2 ...}`\r\n *  corresponding to updates in the plot's layout\r\n * @param {Number[] | Number} [traces]\r\n *  integer or array of integers for the traces to alter (all if omitted)\r\n *\r\n */\r\nfunction update(gd, traceUpdate, layoutUpdate, _traces) {\r\n    gd = Lib.getGraphDiv(gd);\r\n    helpers.clearPromiseQueue(gd);\r\n\r\n    if(!Lib.isPlainObject(traceUpdate)) traceUpdate = {};\r\n    if(!Lib.isPlainObject(layoutUpdate)) layoutUpdate = {};\r\n\r\n    if(Object.keys(traceUpdate).length) gd.changed = true;\r\n    if(Object.keys(layoutUpdate).length) gd.changed = true;\r\n\r\n    var traces = helpers.coerceTraceIndices(gd, _traces);\r\n\r\n    var restyleSpecs = _restyle(gd, Lib.extendFlat({}, traceUpdate), traces);\r\n    var restyleFlags = restyleSpecs.flags;\r\n\r\n    var relayoutSpecs = _relayout(gd, Lib.extendFlat({}, layoutUpdate));\r\n    var relayoutFlags = relayoutSpecs.flags;\r\n\r\n    // clear calcdata and/or axis types if required\r\n    if(restyleFlags.calc || relayoutFlags.calc) gd.calcdata = undefined;\r\n    if(restyleFlags.clearAxisTypes) helpers.clearAxisTypes(gd, traces, layoutUpdate);\r\n\r\n    // fill in redraw sequence\r\n    var seq = [];\r\n\r\n    if(relayoutFlags.layoutReplot) {\r\n        // N.B. works fine when both\r\n        // relayoutFlags.layoutReplot and restyleFlags.fullReplot are true\r\n        seq.push(subroutines.layoutReplot);\r\n    } else if(restyleFlags.fullReplot) {\r\n        seq.push(exports._doPlot);\r\n    } else {\r\n        seq.push(Plots.previousPromises);\r\n        axRangeSupplyDefaultsByPass(gd, relayoutFlags, relayoutSpecs) || Plots.supplyDefaults(gd);\r\n\r\n        if(restyleFlags.style) seq.push(subroutines.doTraceStyle);\r\n        if(restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\r\n        if(relayoutFlags.legend) seq.push(subroutines.doLegend);\r\n        if(relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\r\n        if(relayoutFlags.axrange) addAxRangeSequence(seq, relayoutSpecs.rangesAltered);\r\n        if(relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\r\n        if(relayoutFlags.modebar) seq.push(subroutines.doModeBar);\r\n        if(relayoutFlags.camera) seq.push(subroutines.doCamera);\r\n\r\n        seq.push(emitAfterPlot);\r\n    }\r\n\r\n    seq.push(Plots.rehover, Plots.redrag);\r\n\r\n    Queue.add(gd,\r\n        update, [gd, restyleSpecs.undoit, relayoutSpecs.undoit, restyleSpecs.traces],\r\n        update, [gd, restyleSpecs.redoit, relayoutSpecs.redoit, restyleSpecs.traces]\r\n    );\r\n\r\n    var plotDone = Lib.syncOrAsync(seq, gd);\r\n    if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\r\n\r\n    return plotDone.then(function() {\r\n        gd.emit('plotly_update', {\r\n            data: restyleSpecs.eventData,\r\n            layout: relayoutSpecs.eventData\r\n        });\r\n\r\n        return gd;\r\n    });\r\n}\r\n\r\n/*\r\n * internal-use-only restyle/relayout/update variants that record the initial\r\n * values in (fullLayout|fullTrace)._preGUI so changes can be persisted across\r\n * Plotly.react data updates, dependent on uirevision attributes\r\n */\r\nfunction guiEdit(func) {\r\n    return function wrappedEdit(gd) {\r\n        gd._fullLayout._guiEditing = true;\r\n        var p = func.apply(null, arguments);\r\n        gd._fullLayout._guiEditing = false;\r\n        return p;\r\n    };\r\n}\r\n\r\n// For connecting edited layout attributes to uirevision attrs\r\n// If no `attr` we use `match[1] + '.uirevision'`\r\n// Ordered by most common edits first, to minimize our search time\r\nvar layoutUIControlPatterns = [\r\n    {pattern: /^hiddenlabels/, attr: 'legend.uirevision'},\r\n    {pattern: /^((x|y)axis\\d*)\\.((auto)?range|title\\.text)/},\r\n\r\n    // showspikes and modes include those nested inside scenes\r\n    {pattern: /axis\\d*\\.showspikes$/, attr: 'modebar.uirevision'},\r\n    {pattern: /(hover|drag)mode$/, attr: 'modebar.uirevision'},\r\n\r\n    {pattern: /^(scene\\d*)\\.camera/},\r\n    {pattern: /^(geo\\d*)\\.(projection|center|fitbounds)/},\r\n    {pattern: /^(ternary\\d*\\.[abc]axis)\\.(min|title\\.text)$/},\r\n    {pattern: /^(polar\\d*\\.radialaxis)\\.((auto)?range|angle|title\\.text)/},\r\n    {pattern: /^(polar\\d*\\.angularaxis)\\.rotation/},\r\n    {pattern: /^(mapbox\\d*)\\.(center|zoom|bearing|pitch)/},\r\n\r\n    {pattern: /^legend\\.(x|y)$/, attr: 'editrevision'},\r\n    {pattern: /^(shapes|annotations)/, attr: 'editrevision'},\r\n    {pattern: /^title\\.text$/, attr: 'editrevision'}\r\n];\r\n\r\n// same for trace attributes: if `attr` is given it's in layout,\r\n// or with no `attr` we use `trace.uirevision`\r\nvar traceUIControlPatterns = [\r\n    {pattern: /^selectedpoints$/, attr: 'selectionrevision'},\r\n    // \"visible\" includes trace.transforms[i].styles[j].value.visible\r\n    {pattern: /(^|value\\.)visible$/, attr: 'legend.uirevision'},\r\n    {pattern: /^dimensions\\[\\d+\\]\\.constraintrange/},\r\n    {pattern: /^node\\.(x|y|groups)/}, // for Sankey nodes\r\n    {pattern: /^level$/}, // for Sunburst, Treemap and Icicle traces\r\n\r\n    // below this you must be in editable: true mode\r\n    // TODO: I still put name and title with `trace.uirevision`\r\n    // reasonable or should these be `editrevision`?\r\n    // Also applies to axis titles up in the layout section\r\n\r\n    // \"name\" also includes transform.styles\r\n    {pattern: /(^|value\\.)name$/},\r\n    // including nested colorbar attributes (ie marker.colorbar)\r\n    {pattern: /colorbar\\.title\\.text$/},\r\n    {pattern: /colorbar\\.(x|y)$/, attr: 'editrevision'}\r\n];\r\n\r\nfunction findUIPattern(key, patternSpecs) {\r\n    for(var i = 0; i < patternSpecs.length; i++) {\r\n        var spec = patternSpecs[i];\r\n        var match = key.match(spec.pattern);\r\n        if(match) {\r\n            return {head: match[1], attr: spec.attr};\r\n        }\r\n    }\r\n}\r\n\r\n// We're finding the new uirevision before supplyDefaults, so do the\r\n// inheritance manually. Note that only `undefined` inherits - other\r\n// falsy values are returned.\r\nfunction getNewRev(revAttr, container) {\r\n    var newRev = nestedProperty(container, revAttr).get();\r\n    if(newRev !== undefined) return newRev;\r\n\r\n    var parts = revAttr.split('.');\r\n    parts.pop();\r\n    while(parts.length > 1) {\r\n        parts.pop();\r\n        newRev = nestedProperty(container, parts.join('.') + '.uirevision').get();\r\n        if(newRev !== undefined) return newRev;\r\n    }\r\n\r\n    return container.uirevision;\r\n}\r\n\r\nfunction getFullTraceIndexFromUid(uid, fullData) {\r\n    for(var i = 0; i < fullData.length; i++) {\r\n        if(fullData[i]._fullInput.uid === uid) return i;\r\n    }\r\n    return -1;\r\n}\r\n\r\nfunction getTraceIndexFromUid(uid, data, tracei) {\r\n    for(var i = 0; i < data.length; i++) {\r\n        if(data[i].uid === uid) return i;\r\n    }\r\n    // fall back on trace order, but only if user didn't provide a uid for that trace\r\n    return (!data[tracei] || data[tracei].uid) ? -1 : tracei;\r\n}\r\n\r\nfunction valsMatch(v1, v2) {\r\n    var v1IsObj = Lib.isPlainObject(v1);\r\n    var v1IsArray = Array.isArray(v1);\r\n    if(v1IsObj || v1IsArray) {\r\n        return (\r\n            (v1IsObj && Lib.isPlainObject(v2)) ||\r\n            (v1IsArray && Array.isArray(v2))\r\n        ) && JSON.stringify(v1) === JSON.stringify(v2);\r\n    }\r\n    return v1 === v2;\r\n}\r\n\r\nfunction applyUIRevisions(data, layout, oldFullData, oldFullLayout) {\r\n    var layoutPreGUI = oldFullLayout._preGUI;\r\n    var key, revAttr, oldRev, newRev, match, preGUIVal, newNP, newVal;\r\n    var bothInheritAutorange = [];\r\n    var newRangeAccepted = {};\r\n    for(key in layoutPreGUI) {\r\n        match = findUIPattern(key, layoutUIControlPatterns);\r\n        if(match) {\r\n            revAttr = match.attr || (match.head + '.uirevision');\r\n            oldRev = nestedProperty(oldFullLayout, revAttr).get();\r\n            newRev = oldRev && getNewRev(revAttr, layout);\r\n            if(newRev && (newRev === oldRev)) {\r\n                preGUIVal = layoutPreGUI[key];\r\n                if(preGUIVal === null) preGUIVal = undefined;\r\n                newNP = nestedProperty(layout, key);\r\n                newVal = newNP.get();\r\n                if(valsMatch(newVal, preGUIVal)) {\r\n                    if(newVal === undefined && key.substr(key.length - 9) === 'autorange') {\r\n                        bothInheritAutorange.push(key.substr(0, key.length - 10));\r\n                    }\r\n                    newNP.set(undefinedToNull(nestedProperty(oldFullLayout, key).get()));\r\n                    continue;\r\n                }\r\n            }\r\n        } else {\r\n            Lib.warn('unrecognized GUI edit: ' + key);\r\n        }\r\n        // if we got this far, the new value was accepted as the new starting\r\n        // point (either because it changed or revision changed)\r\n        // so remove it from _preGUI for next time.\r\n        delete layoutPreGUI[key];\r\n\r\n        if(key.substr(key.length - 8, 6) === 'range[') {\r\n            newRangeAccepted[key.substr(0, key.length - 9)] = 1;\r\n        }\r\n    }\r\n\r\n    // Special logic for `autorange`, since it interacts with `range`:\r\n    // If the new figure's matching `range` was kept, and `autorange`\r\n    // wasn't supplied explicitly in either the original or the new figure,\r\n    // we shouldn't alter that - but we may just have done that, so fix it.\r\n    for(var i = 0; i < bothInheritAutorange.length; i++) {\r\n        var axAttr = bothInheritAutorange[i];\r\n        if(newRangeAccepted[axAttr]) {\r\n            var newAx = nestedProperty(layout, axAttr).get();\r\n            if(newAx) delete newAx.autorange;\r\n        }\r\n    }\r\n\r\n    // Now traces - try to match them up by uid (in case we added/deleted in\r\n    // the middle), then fall back on index.\r\n    var allTracePreGUI = oldFullLayout._tracePreGUI;\r\n    for(var uid in allTracePreGUI) {\r\n        var tracePreGUI = allTracePreGUI[uid];\r\n        var newTrace = null;\r\n        var fullInput;\r\n        for(key in tracePreGUI) {\r\n            // wait until we know we have preGUI values to look for traces\r\n            // but if we don't find both, stop looking at this uid\r\n            if(!newTrace) {\r\n                var fulli = getFullTraceIndexFromUid(uid, oldFullData);\r\n                if(fulli < 0) {\r\n                    // Somehow we didn't even have this trace in oldFullData...\r\n                    // I guess this could happen with `deleteTraces` or something\r\n                    delete allTracePreGUI[uid];\r\n                    break;\r\n                }\r\n                var fullTrace = oldFullData[fulli];\r\n                fullInput = fullTrace._fullInput;\r\n\r\n                var newTracei = getTraceIndexFromUid(uid, data, fullInput.index);\r\n                if(newTracei < 0) {\r\n                    // No match in new data\r\n                    delete allTracePreGUI[uid];\r\n                    break;\r\n                }\r\n                newTrace = data[newTracei];\r\n            }\r\n\r\n            match = findUIPattern(key, traceUIControlPatterns);\r\n            if(match) {\r\n                if(match.attr) {\r\n                    oldRev = nestedProperty(oldFullLayout, match.attr).get();\r\n                    newRev = oldRev && getNewRev(match.attr, layout);\r\n                } else {\r\n                    oldRev = fullInput.uirevision;\r\n                    // inheritance for trace.uirevision is simple, just layout.uirevision\r\n                    newRev = newTrace.uirevision;\r\n                    if(newRev === undefined) newRev = layout.uirevision;\r\n                }\r\n\r\n                if(newRev && newRev === oldRev) {\r\n                    preGUIVal = tracePreGUI[key];\r\n                    if(preGUIVal === null) preGUIVal = undefined;\r\n                    newNP = nestedProperty(newTrace, key);\r\n                    newVal = newNP.get();\r\n                    if(valsMatch(newVal, preGUIVal)) {\r\n                        newNP.set(undefinedToNull(nestedProperty(fullInput, key).get()));\r\n                        continue;\r\n                    }\r\n                }\r\n            } else {\r\n                Lib.warn('unrecognized GUI edit: ' + key + ' in trace uid ' + uid);\r\n            }\r\n            delete tracePreGUI[key];\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Plotly.react:\r\n * A plot/update method that takes the full plot state (same API as plot/newPlot)\r\n * and diffs to determine the minimal update pathway\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n * @param {array of objects} data\r\n *      array of traces, containing the data and display information for each trace\r\n * @param {object} layout\r\n *      object describing the overall display of the plot,\r\n *      all the stuff that doesn't pertain to any individual trace\r\n * @param {object} config\r\n *      configuration options (see ./plot_config.js for more info)\r\n *\r\n * OR\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n * @param {object} figure\r\n *      object containing `data`, `layout`, `config`, and `frames` members\r\n *\r\n */\r\nfunction react(gd, data, layout, config) {\r\n    var frames, plotDone;\r\n\r\n    function addFrames() { return exports.addFrames(gd, frames); }\r\n\r\n    gd = Lib.getGraphDiv(gd);\r\n    helpers.clearPromiseQueue(gd);\r\n\r\n    var oldFullData = gd._fullData;\r\n    var oldFullLayout = gd._fullLayout;\r\n\r\n    // you can use this as the initial draw as well as to update\r\n    if(!Lib.isPlotDiv(gd) || !oldFullData || !oldFullLayout) {\r\n        plotDone = exports.newPlot(gd, data, layout, config);\r\n    } else {\r\n        if(Lib.isPlainObject(data)) {\r\n            var obj = data;\r\n            data = obj.data;\r\n            layout = obj.layout;\r\n            config = obj.config;\r\n            frames = obj.frames;\r\n        }\r\n\r\n        var configChanged = false;\r\n        // assume that if there's a config at all, we're reacting to it too,\r\n        // and completely replace the previous config\r\n        if(config) {\r\n            var oldConfig = Lib.extendDeep({}, gd._context);\r\n            gd._context = undefined;\r\n            setPlotContext(gd, config);\r\n            configChanged = diffConfig(oldConfig, gd._context);\r\n        }\r\n\r\n        gd.data = data || [];\r\n        helpers.cleanData(gd.data);\r\n        gd.layout = layout || {};\r\n        helpers.cleanLayout(gd.layout);\r\n\r\n        applyUIRevisions(gd.data, gd.layout, oldFullData, oldFullLayout);\r\n\r\n        // \"true\" skips updating calcdata and remapping arrays from calcTransforms,\r\n        // which supplyDefaults usually does at the end, but we may need to NOT do\r\n        // if the diff (which we haven't determined yet) says we'll recalc\r\n        Plots.supplyDefaults(gd, {skipUpdateCalc: true});\r\n\r\n        var newFullData = gd._fullData;\r\n        var newFullLayout = gd._fullLayout;\r\n        var immutable = newFullLayout.datarevision === undefined;\r\n        var transition = newFullLayout.transition;\r\n\r\n        var relayoutFlags = diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition);\r\n        var newDataRevision = relayoutFlags.newDataRevision;\r\n        var restyleFlags = diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision);\r\n\r\n        // TODO: how to translate this part of relayout to Plotly.react?\r\n        // // Setting width or height to null must reset the graph's width / height\r\n        // // back to its initial value as computed during the first pass in Plots.plotAutoSize.\r\n        // //\r\n        // // To do so, we must manually set them back here using the _initialAutoSize cache.\r\n        // if(['width', 'height'].indexOf(ai) !== -1 && vi === null) {\r\n        //     fullLayout[ai] = gd._initialAutoSize[ai];\r\n        // }\r\n\r\n        if(updateAutosize(gd)) relayoutFlags.layoutReplot = true;\r\n\r\n        // clear calcdata and empty categories if required\r\n        if(restyleFlags.calc || relayoutFlags.calc) {\r\n            gd.calcdata = undefined;\r\n            var allNames = Object.getOwnPropertyNames(newFullLayout);\r\n            for(var q = 0; q < allNames.length; q++) {\r\n                var name = allNames[q];\r\n                var start = name.substring(0, 5);\r\n                if(start === 'xaxis' || start === 'yaxis') {\r\n                    var emptyCategories = newFullLayout[name]._emptyCategories;\r\n                    if(emptyCategories) emptyCategories();\r\n                }\r\n            }\r\n        // otherwise do the calcdata updates and calcTransform array remaps that we skipped earlier\r\n        } else {\r\n            Plots.supplyDefaultsUpdateCalc(gd.calcdata, newFullData);\r\n        }\r\n\r\n        // Note: what restyle/relayout use impliedEdits and clearAxisTypes for\r\n        // must be handled by the user when using Plotly.react.\r\n\r\n        // fill in redraw sequence\r\n        var seq = [];\r\n\r\n        if(frames) {\r\n            gd._transitionData = {};\r\n            Plots.createTransitionData(gd);\r\n            seq.push(addFrames);\r\n        }\r\n\r\n        // Transition pathway,\r\n        // only used when 'transition' is set by user and\r\n        // when at least one animatable attribute has changed,\r\n        // N.B. config changed aren't animatable\r\n        if(newFullLayout.transition && !configChanged && (restyleFlags.anim || relayoutFlags.anim)) {\r\n            if(relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\r\n\r\n            Plots.doCalcdata(gd);\r\n            subroutines.doAutoRangeAndConstraints(gd);\r\n\r\n            seq.push(function() {\r\n                return Plots.transitionFromReact(gd, restyleFlags, relayoutFlags, oldFullLayout);\r\n            });\r\n        } else if(restyleFlags.fullReplot || relayoutFlags.layoutReplot || configChanged) {\r\n            gd._fullLayout._skipDefaults = true;\r\n            seq.push(exports._doPlot);\r\n        } else {\r\n            for(var componentType in relayoutFlags.arrays) {\r\n                var indices = relayoutFlags.arrays[componentType];\r\n                if(indices.length) {\r\n                    var drawOne = Registry.getComponentMethod(componentType, 'drawOne');\r\n                    if(drawOne !== Lib.noop) {\r\n                        for(var i = 0; i < indices.length; i++) {\r\n                            drawOne(gd, indices[i]);\r\n                        }\r\n                    } else {\r\n                        var draw = Registry.getComponentMethod(componentType, 'draw');\r\n                        if(draw === Lib.noop) {\r\n                            throw new Error('cannot draw components: ' + componentType);\r\n                        }\r\n                        draw(gd);\r\n                    }\r\n                }\r\n            }\r\n\r\n            seq.push(Plots.previousPromises);\r\n            if(restyleFlags.style) seq.push(subroutines.doTraceStyle);\r\n            if(restyleFlags.colorbars || relayoutFlags.colorbars) seq.push(subroutines.doColorBars);\r\n            if(relayoutFlags.legend) seq.push(subroutines.doLegend);\r\n            if(relayoutFlags.layoutstyle) seq.push(subroutines.layoutStyles);\r\n            if(relayoutFlags.axrange) addAxRangeSequence(seq);\r\n            if(relayoutFlags.ticks) seq.push(subroutines.doTicksRelayout);\r\n            if(relayoutFlags.modebar) seq.push(subroutines.doModeBar);\r\n            if(relayoutFlags.camera) seq.push(subroutines.doCamera);\r\n            seq.push(emitAfterPlot);\r\n        }\r\n\r\n        seq.push(Plots.rehover, Plots.redrag);\r\n\r\n        plotDone = Lib.syncOrAsync(seq, gd);\r\n        if(!plotDone || !plotDone.then) plotDone = Promise.resolve(gd);\r\n    }\r\n\r\n    return plotDone.then(function() {\r\n        gd.emit('plotly_react', {\r\n            data: data,\r\n            layout: layout\r\n        });\r\n\r\n        return gd;\r\n    });\r\n}\r\n\r\nfunction diffData(gd, oldFullData, newFullData, immutable, transition, newDataRevision) {\r\n    var sameTraceLength = oldFullData.length === newFullData.length;\r\n\r\n    if(!transition && !sameTraceLength) {\r\n        return {\r\n            fullReplot: true,\r\n            calc: true\r\n        };\r\n    }\r\n\r\n    var flags = editTypes.traceFlags();\r\n    flags.arrays = {};\r\n    flags.nChanges = 0;\r\n    flags.nChangesAnim = 0;\r\n\r\n    var i, trace;\r\n\r\n    function getTraceValObject(parts) {\r\n        var out = PlotSchema.getTraceValObject(trace, parts);\r\n        if(!trace._module.animatable && out.anim) {\r\n            out.anim = false;\r\n        }\r\n        return out;\r\n    }\r\n\r\n    var diffOpts = {\r\n        getValObject: getTraceValObject,\r\n        flags: flags,\r\n        immutable: immutable,\r\n        transition: transition,\r\n        newDataRevision: newDataRevision,\r\n        gd: gd\r\n    };\r\n\r\n    var seenUIDs = {};\r\n\r\n    for(i = 0; i < oldFullData.length; i++) {\r\n        if(newFullData[i]) {\r\n            trace = newFullData[i]._fullInput;\r\n            if(Plots.hasMakesDataTransform(trace)) trace = newFullData[i];\r\n            if(seenUIDs[trace.uid]) continue;\r\n            seenUIDs[trace.uid] = 1;\r\n\r\n            getDiffFlags(oldFullData[i]._fullInput, trace, [], diffOpts);\r\n        }\r\n    }\r\n\r\n    if(flags.calc || flags.plot) {\r\n        flags.fullReplot = true;\r\n    }\r\n\r\n    if(transition && flags.nChanges && flags.nChangesAnim) {\r\n        flags.anim = (flags.nChanges === flags.nChangesAnim) && sameTraceLength ? 'all' : 'some';\r\n    }\r\n\r\n    return flags;\r\n}\r\n\r\nfunction diffLayout(gd, oldFullLayout, newFullLayout, immutable, transition) {\r\n    var flags = editTypes.layoutFlags();\r\n    flags.arrays = {};\r\n    flags.rangesAltered = {};\r\n    flags.nChanges = 0;\r\n    flags.nChangesAnim = 0;\r\n\r\n    function getLayoutValObject(parts) {\r\n        return PlotSchema.getLayoutValObject(newFullLayout, parts);\r\n    }\r\n\r\n    var diffOpts = {\r\n        getValObject: getLayoutValObject,\r\n        flags: flags,\r\n        immutable: immutable,\r\n        transition: transition,\r\n        gd: gd\r\n    };\r\n\r\n    getDiffFlags(oldFullLayout, newFullLayout, [], diffOpts);\r\n\r\n    if(flags.plot || flags.calc) {\r\n        flags.layoutReplot = true;\r\n    }\r\n\r\n    if(transition && flags.nChanges && flags.nChangesAnim) {\r\n        flags.anim = flags.nChanges === flags.nChangesAnim ? 'all' : 'some';\r\n    }\r\n\r\n    return flags;\r\n}\r\n\r\nfunction getDiffFlags(oldContainer, newContainer, outerparts, opts) {\r\n    var valObject, key, astr;\r\n\r\n    var getValObject = opts.getValObject;\r\n    var flags = opts.flags;\r\n    var immutable = opts.immutable;\r\n    var inArray = opts.inArray;\r\n    var arrayIndex = opts.arrayIndex;\r\n\r\n    function changed() {\r\n        var editType = valObject.editType;\r\n        if(inArray && editType.indexOf('arraydraw') !== -1) {\r\n            Lib.pushUnique(flags.arrays[inArray], arrayIndex);\r\n            return;\r\n        }\r\n        editTypes.update(flags, valObject);\r\n\r\n        if(editType !== 'none') {\r\n            flags.nChanges++;\r\n        }\r\n\r\n        // track animatable changes\r\n        if(opts.transition && valObject.anim) {\r\n            flags.nChangesAnim++;\r\n        }\r\n\r\n        // track cartesian axes with altered ranges\r\n        if(AX_RANGE_RE.test(astr) || AX_AUTORANGE_RE.test(astr)) {\r\n            flags.rangesAltered[outerparts[0]] = 1;\r\n        }\r\n\r\n        // clear _inputDomain on cartesian axes with altered domains\r\n        if(AX_DOMAIN_RE.test(astr)) {\r\n            nestedProperty(newContainer, '_inputDomain').set(null);\r\n        }\r\n\r\n        // track datarevision changes\r\n        if(key === 'datarevision') {\r\n            flags.newDataRevision = 1;\r\n        }\r\n    }\r\n\r\n    function valObjectCanBeDataArray(valObject) {\r\n        return valObject.valType === 'data_array' || valObject.arrayOk;\r\n    }\r\n\r\n    for(key in oldContainer) {\r\n        // short-circuit based on previous calls or previous keys that already maximized the pathway\r\n        if(flags.calc && !opts.transition) return;\r\n\r\n        var oldVal = oldContainer[key];\r\n        var newVal = newContainer[key];\r\n        var parts = outerparts.concat(key);\r\n        astr = parts.join('.');\r\n\r\n        if(key.charAt(0) === '_' || typeof oldVal === 'function' || oldVal === newVal) continue;\r\n\r\n        // FIXME: ax.tick0 and dtick get filled in during plotting (except for geo subplots),\r\n        // and unlike other auto values they don't make it back into the input,\r\n        // so newContainer won't have them.\r\n        if((key === 'tick0' || key === 'dtick') && outerparts[0] !== 'geo') {\r\n            var tickMode = newContainer.tickmode;\r\n            if(tickMode === 'auto' || tickMode === 'array' || !tickMode) continue;\r\n        }\r\n        // FIXME: Similarly for axis ranges for 3D\r\n        // contourcarpet doesn't HAVE zmin/zmax, they're just auto-added. It needs them.\r\n        if(key === 'range' && newContainer.autorange) continue;\r\n        if((key === 'zmin' || key === 'zmax') && newContainer.type === 'contourcarpet') continue;\r\n\r\n        valObject = getValObject(parts);\r\n\r\n        // in case type changed, we may not even *have* a valObject.\r\n        if(!valObject) continue;\r\n\r\n        if(valObject._compareAsJSON && JSON.stringify(oldVal) === JSON.stringify(newVal)) continue;\r\n\r\n        var valType = valObject.valType;\r\n        var i;\r\n\r\n        var canBeDataArray = valObjectCanBeDataArray(valObject);\r\n        var wasArray = Array.isArray(oldVal);\r\n        var nowArray = Array.isArray(newVal);\r\n\r\n        // hack for traces that modify the data in supplyDefaults, like\r\n        // converting 1D to 2D arrays, which will always create new objects\r\n        if(wasArray && nowArray) {\r\n            var inputKey = '_input_' + key;\r\n            var oldValIn = oldContainer[inputKey];\r\n            var newValIn = newContainer[inputKey];\r\n            if(Array.isArray(oldValIn) && oldValIn === newValIn) continue;\r\n        }\r\n\r\n        if(newVal === undefined) {\r\n            if(canBeDataArray && wasArray) flags.calc = true;\r\n            else changed();\r\n        } else if(valObject._isLinkedToArray) {\r\n            var arrayEditIndices = [];\r\n            var extraIndices = false;\r\n            if(!inArray) flags.arrays[key] = arrayEditIndices;\r\n\r\n            var minLen = Math.min(oldVal.length, newVal.length);\r\n            var maxLen = Math.max(oldVal.length, newVal.length);\r\n            if(minLen !== maxLen) {\r\n                if(valObject.editType === 'arraydraw') {\r\n                    extraIndices = true;\r\n                } else {\r\n                    changed();\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            for(i = 0; i < minLen; i++) {\r\n                getDiffFlags(oldVal[i], newVal[i], parts.concat(i),\r\n                    // add array indices, but not if we're already in an array\r\n                    Lib.extendFlat({inArray: key, arrayIndex: i}, opts));\r\n            }\r\n\r\n            // put this at the end so that we know our collected array indices are sorted\r\n            // but the check for length changes happens up front so we can short-circuit\r\n            // diffing if appropriate\r\n            if(extraIndices) {\r\n                for(i = minLen; i < maxLen; i++) {\r\n                    arrayEditIndices.push(i);\r\n                }\r\n            }\r\n        } else if(!valType && Lib.isPlainObject(oldVal)) {\r\n            getDiffFlags(oldVal, newVal, parts, opts);\r\n        } else if(canBeDataArray) {\r\n            if(wasArray && nowArray) {\r\n                // don't try to diff two data arrays. If immutable we know the data changed,\r\n                // if not, assume it didn't and let `layout.datarevision` tell us if it did\r\n                if(immutable) {\r\n                    flags.calc = true;\r\n                }\r\n\r\n                // look for animatable attributes when the data changed\r\n                if(immutable || opts.newDataRevision) {\r\n                    changed();\r\n                }\r\n            } else if(wasArray !== nowArray) {\r\n                flags.calc = true;\r\n            } else changed();\r\n        } else if(wasArray && nowArray) {\r\n            // info array, colorscale, 'any' - these are short, just stringify.\r\n            // I don't *think* that covers up any real differences post-validation, does it?\r\n            // otherwise we need to dive in 1 (info_array) or 2 (colorscale) levels and compare\r\n            // all elements.\r\n            if(oldVal.length !== newVal.length || String(oldVal) !== String(newVal)) {\r\n                changed();\r\n            }\r\n        } else {\r\n            changed();\r\n        }\r\n    }\r\n\r\n    for(key in newContainer) {\r\n        if(!(key in oldContainer || key.charAt(0) === '_' || typeof newContainer[key] === 'function')) {\r\n            valObject = getValObject(outerparts.concat(key));\r\n\r\n            if(valObjectCanBeDataArray(valObject) && Array.isArray(newContainer[key])) {\r\n                flags.calc = true;\r\n                return;\r\n            } else changed();\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\n * simple diff for config - for now, just treat all changes as equivalent\r\n */\r\nfunction diffConfig(oldConfig, newConfig) {\r\n    var key;\r\n\r\n    for(key in oldConfig) {\r\n        if(key.charAt(0) === '_') continue;\r\n        var oldVal = oldConfig[key];\r\n        var newVal = newConfig[key];\r\n        if(oldVal !== newVal) {\r\n            if(Lib.isPlainObject(oldVal) && Lib.isPlainObject(newVal)) {\r\n                if(diffConfig(oldVal, newVal)) {\r\n                    return true;\r\n                }\r\n            } else if(Array.isArray(oldVal) && Array.isArray(newVal)) {\r\n                if(oldVal.length !== newVal.length) {\r\n                    return true;\r\n                }\r\n                for(var i = 0; i < oldVal.length; i++) {\r\n                    if(oldVal[i] !== newVal[i]) {\r\n                        if(Lib.isPlainObject(oldVal[i]) && Lib.isPlainObject(newVal[i])) {\r\n                            if(diffConfig(oldVal[i], newVal[i])) {\r\n                                return true;\r\n                            }\r\n                        } else {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Animate to a frame, sequence of frame, frame group, or frame definition\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n *\r\n * @param {string or object or array of strings or array of objects} frameOrGroupNameOrFrameList\r\n *      a single frame, array of frames, or group to which to animate. The intent is\r\n *      inferred by the type of the input. Valid inputs are:\r\n *\r\n *      - string, e.g. 'groupname': animate all frames of a given `group` in the order\r\n *            in which they are defined via `Plotly.addFrames`.\r\n *\r\n *      - array of strings, e.g. ['frame1', frame2']: a list of frames by name to which\r\n *            to animate in sequence\r\n *\r\n *      - object: {data: ...}: a frame definition to which to animate. The frame is not\r\n *            and does not need to be added via `Plotly.addFrames`. It may contain any of\r\n *            the properties of a frame, including `data`, `layout`, and `traces`. The\r\n *            frame is used as provided and does not use the `baseframe` property.\r\n *\r\n *      - array of objects, e.g. [{data: ...}, {data: ...}]: a list of frame objects,\r\n *            each following the same rules as a single `object`.\r\n *\r\n * @param {object} animationOpts\r\n *      configuration for the animation\r\n */\r\nfunction animate(gd, frameOrGroupNameOrFrameList, animationOpts) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    if(!Lib.isPlotDiv(gd)) {\r\n        throw new Error(\r\n            'This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' +\r\n            'to create a plot before animating it. For more details, see ' +\r\n            'https://plotly.com/javascript/animations/'\r\n        );\r\n    }\r\n\r\n    var trans = gd._transitionData;\r\n\r\n    // This is the queue of frames that will be animated as soon as possible. They\r\n    // are popped immediately upon the *start* of a transition:\r\n    if(!trans._frameQueue) {\r\n        trans._frameQueue = [];\r\n    }\r\n\r\n    animationOpts = Plots.supplyAnimationDefaults(animationOpts);\r\n    var transitionOpts = animationOpts.transition;\r\n    var frameOpts = animationOpts.frame;\r\n\r\n    // Since frames are popped immediately, an empty queue only means all frames have\r\n    // *started* to transition, not that the animation is complete. To solve that,\r\n    // track a separate counter that increments at the same time as frames are added\r\n    // to the queue, but decrements only when the transition is complete.\r\n    if(trans._frameWaitingCnt === undefined) {\r\n        trans._frameWaitingCnt = 0;\r\n    }\r\n\r\n    function getTransitionOpts(i) {\r\n        if(Array.isArray(transitionOpts)) {\r\n            if(i >= transitionOpts.length) {\r\n                return transitionOpts[0];\r\n            } else {\r\n                return transitionOpts[i];\r\n            }\r\n        } else {\r\n            return transitionOpts;\r\n        }\r\n    }\r\n\r\n    function getFrameOpts(i) {\r\n        if(Array.isArray(frameOpts)) {\r\n            if(i >= frameOpts.length) {\r\n                return frameOpts[0];\r\n            } else {\r\n                return frameOpts[i];\r\n            }\r\n        } else {\r\n            return frameOpts;\r\n        }\r\n    }\r\n\r\n    // Execute a callback after the wrapper function has been called n times.\r\n    // This is used to defer the resolution until a transition has resolved *and*\r\n    // the frame has completed. If it's not done this way, then we get a race\r\n    // condition in which the animation might resolve before a transition is complete\r\n    // or vice versa.\r\n    function callbackOnNthTime(cb, n) {\r\n        var cnt = 0;\r\n        return function() {\r\n            if(cb && ++cnt === n) {\r\n                return cb();\r\n            }\r\n        };\r\n    }\r\n\r\n    return new Promise(function(resolve, reject) {\r\n        function discardExistingFrames() {\r\n            if(trans._frameQueue.length === 0) {\r\n                return;\r\n            }\r\n\r\n            while(trans._frameQueue.length) {\r\n                var next = trans._frameQueue.pop();\r\n                if(next.onInterrupt) {\r\n                    next.onInterrupt();\r\n                }\r\n            }\r\n\r\n            gd.emit('plotly_animationinterrupted', []);\r\n        }\r\n\r\n        function queueFrames(frameList) {\r\n            if(frameList.length === 0) return;\r\n\r\n            for(var i = 0; i < frameList.length; i++) {\r\n                var computedFrame;\r\n\r\n                if(frameList[i].type === 'byname') {\r\n                    // If it's a named frame, compute it:\r\n                    computedFrame = Plots.computeFrame(gd, frameList[i].name);\r\n                } else {\r\n                    // Otherwise we must have been given a simple object, so treat\r\n                    // the input itself as the computed frame.\r\n                    computedFrame = frameList[i].data;\r\n                }\r\n\r\n                var frameOpts = getFrameOpts(i);\r\n                var transitionOpts = getTransitionOpts(i);\r\n\r\n                // It doesn't make much sense for the transition duration to be greater than\r\n                // the frame duration, so limit it:\r\n                transitionOpts.duration = Math.min(transitionOpts.duration, frameOpts.duration);\r\n\r\n                var nextFrame = {\r\n                    frame: computedFrame,\r\n                    name: frameList[i].name,\r\n                    frameOpts: frameOpts,\r\n                    transitionOpts: transitionOpts,\r\n                };\r\n                if(i === frameList.length - 1) {\r\n                    // The last frame in this .animate call stores the promise resolve\r\n                    // and reject callbacks. This is how we ensure that the animation\r\n                    // loop (which may exist as a result of a *different* .animate call)\r\n                    // still resolves or rejecdts this .animate call's promise. once it's\r\n                    // complete.\r\n                    nextFrame.onComplete = callbackOnNthTime(resolve, 2);\r\n                    nextFrame.onInterrupt = reject;\r\n                }\r\n\r\n                trans._frameQueue.push(nextFrame);\r\n            }\r\n\r\n            // Set it as never having transitioned to a frame. This will cause the animation\r\n            // loop to immediately transition to the next frame (which, for immediate mode,\r\n            // is the first frame in the list since all others would have been discarded\r\n            // below)\r\n            if(animationOpts.mode === 'immediate') {\r\n                trans._lastFrameAt = -Infinity;\r\n            }\r\n\r\n            // Only it's not already running, start a RAF loop. This could be avoided in the\r\n            // case that there's only one frame, but it significantly complicated the logic\r\n            // and only sped things up by about 5% or so for a lorenz attractor simulation.\r\n            // It would be a fine thing to implement, but the benefit of that optimization\r\n            // doesn't seem worth the extra complexity.\r\n            if(!trans._animationRaf) {\r\n                beginAnimationLoop();\r\n            }\r\n        }\r\n\r\n        function stopAnimationLoop() {\r\n            gd.emit('plotly_animated');\r\n\r\n            // Be sure to unset also since it's how we know whether a loop is already running:\r\n            window.cancelAnimationFrame(trans._animationRaf);\r\n            trans._animationRaf = null;\r\n        }\r\n\r\n        function nextFrame() {\r\n            if(trans._currentFrame && trans._currentFrame.onComplete) {\r\n                // Execute the callback and unset it to ensure it doesn't\r\n                // accidentally get called twice\r\n                trans._currentFrame.onComplete();\r\n            }\r\n\r\n            var newFrame = trans._currentFrame = trans._frameQueue.shift();\r\n\r\n            if(newFrame) {\r\n                // Since it's sometimes necessary to do deep digging into frame data,\r\n                // we'll consider it not 100% impossible for nulls or numbers to sneak through,\r\n                // so check when casting the name, just to be absolutely certain:\r\n                var stringName = newFrame.name ? newFrame.name.toString() : null;\r\n                gd._fullLayout._currentFrame = stringName;\r\n\r\n                trans._lastFrameAt = Date.now();\r\n                trans._timeToNext = newFrame.frameOpts.duration;\r\n\r\n                // This is simply called and it's left to .transition to decide how to manage\r\n                // interrupting current transitions. That means we don't need to worry about\r\n                // how it resolves or what happens after this:\r\n                Plots.transition(gd,\r\n                    newFrame.frame.data,\r\n                    newFrame.frame.layout,\r\n                    helpers.coerceTraceIndices(gd, newFrame.frame.traces),\r\n                    newFrame.frameOpts,\r\n                    newFrame.transitionOpts\r\n                ).then(function() {\r\n                    if(newFrame.onComplete) {\r\n                        newFrame.onComplete();\r\n                    }\r\n                });\r\n\r\n                gd.emit('plotly_animatingframe', {\r\n                    name: stringName,\r\n                    frame: newFrame.frame,\r\n                    animation: {\r\n                        frame: newFrame.frameOpts,\r\n                        transition: newFrame.transitionOpts,\r\n                    }\r\n                });\r\n            } else {\r\n                // If there are no more frames, then stop the RAF loop:\r\n                stopAnimationLoop();\r\n            }\r\n        }\r\n\r\n        function beginAnimationLoop() {\r\n            gd.emit('plotly_animating');\r\n\r\n            // If no timer is running, then set last frame = long ago so that the next\r\n            // frame is immediately transitioned:\r\n            trans._lastFrameAt = -Infinity;\r\n            trans._timeToNext = 0;\r\n            trans._runningTransitions = 0;\r\n            trans._currentFrame = null;\r\n\r\n            var doFrame = function() {\r\n                // This *must* be requested before nextFrame since nextFrame may decide\r\n                // to cancel it if there's nothing more to animated:\r\n                trans._animationRaf = window.requestAnimationFrame(doFrame);\r\n\r\n                // Check if we're ready for a new frame:\r\n                if(Date.now() - trans._lastFrameAt > trans._timeToNext) {\r\n                    nextFrame();\r\n                }\r\n            };\r\n\r\n            doFrame();\r\n        }\r\n\r\n        // This is an animate-local counter that helps match up option input list\r\n        // items with the particular frame.\r\n        var configCounter = 0;\r\n        function setTransitionConfig(frame) {\r\n            if(Array.isArray(transitionOpts)) {\r\n                if(configCounter >= transitionOpts.length) {\r\n                    frame.transitionOpts = transitionOpts[configCounter];\r\n                } else {\r\n                    frame.transitionOpts = transitionOpts[0];\r\n                }\r\n            } else {\r\n                frame.transitionOpts = transitionOpts;\r\n            }\r\n            configCounter++;\r\n            return frame;\r\n        }\r\n\r\n        // Disambiguate what's sort of frames have been received\r\n        var i, frame;\r\n        var frameList = [];\r\n        var allFrames = frameOrGroupNameOrFrameList === undefined || frameOrGroupNameOrFrameList === null;\r\n        var isFrameArray = Array.isArray(frameOrGroupNameOrFrameList);\r\n        var isSingleFrame = !allFrames && !isFrameArray && Lib.isPlainObject(frameOrGroupNameOrFrameList);\r\n\r\n        if(isSingleFrame) {\r\n            // In this case, a simple object has been passed to animate.\r\n            frameList.push({\r\n                type: 'object',\r\n                data: setTransitionConfig(Lib.extendFlat({}, frameOrGroupNameOrFrameList))\r\n            });\r\n        } else if(allFrames || ['string', 'number'].indexOf(typeof frameOrGroupNameOrFrameList) !== -1) {\r\n            // In this case, null or undefined has been passed so that we want to\r\n            // animate *all* currently defined frames\r\n            for(i = 0; i < trans._frames.length; i++) {\r\n                frame = trans._frames[i];\r\n\r\n                if(!frame) continue;\r\n\r\n                if(allFrames || String(frame.group) === String(frameOrGroupNameOrFrameList)) {\r\n                    frameList.push({\r\n                        type: 'byname',\r\n                        name: String(frame.name),\r\n                        data: setTransitionConfig({name: frame.name})\r\n                    });\r\n                }\r\n            }\r\n        } else if(isFrameArray) {\r\n            for(i = 0; i < frameOrGroupNameOrFrameList.length; i++) {\r\n                var frameOrName = frameOrGroupNameOrFrameList[i];\r\n                if(['number', 'string'].indexOf(typeof frameOrName) !== -1) {\r\n                    frameOrName = String(frameOrName);\r\n                    // In this case, there's an array and this frame is a string name:\r\n                    frameList.push({\r\n                        type: 'byname',\r\n                        name: frameOrName,\r\n                        data: setTransitionConfig({name: frameOrName})\r\n                    });\r\n                } else if(Lib.isPlainObject(frameOrName)) {\r\n                    frameList.push({\r\n                        type: 'object',\r\n                        data: setTransitionConfig(Lib.extendFlat({}, frameOrName))\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Verify that all of these frames actually exist; return and reject if not:\r\n        for(i = 0; i < frameList.length; i++) {\r\n            frame = frameList[i];\r\n            if(frame.type === 'byname' && !trans._frameHash[frame.data.name]) {\r\n                Lib.warn('animate failure: frame not found: \"' + frame.data.name + '\"');\r\n                reject();\r\n                return;\r\n            }\r\n        }\r\n\r\n        // If the mode is either next or immediate, then all currently queued frames must\r\n        // be dumped and the corresponding .animate promises rejected.\r\n        if(['next', 'immediate'].indexOf(animationOpts.mode) !== -1) {\r\n            discardExistingFrames();\r\n        }\r\n\r\n        if(animationOpts.direction === 'reverse') {\r\n            frameList.reverse();\r\n        }\r\n\r\n        var currentFrame = gd._fullLayout._currentFrame;\r\n        if(currentFrame && animationOpts.fromcurrent) {\r\n            var idx = -1;\r\n            for(i = 0; i < frameList.length; i++) {\r\n                frame = frameList[i];\r\n                if(frame.type === 'byname' && frame.name === currentFrame) {\r\n                    idx = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if(idx > 0 && idx < frameList.length - 1) {\r\n                var filteredFrameList = [];\r\n                for(i = 0; i < frameList.length; i++) {\r\n                    frame = frameList[i];\r\n                    if(frameList[i].type !== 'byname' || i > idx) {\r\n                        filteredFrameList.push(frame);\r\n                    }\r\n                }\r\n                frameList = filteredFrameList;\r\n            }\r\n        }\r\n\r\n        if(frameList.length > 0) {\r\n            queueFrames(frameList);\r\n        } else {\r\n            // This is the case where there were simply no frames. It's a little strange\r\n            // since there's not much to do:\r\n            gd.emit('plotly_animated');\r\n            resolve();\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Register new frames\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n *\r\n * @param {array of objects} frameList\r\n *      list of frame definitions, in which each object includes any of:\r\n *      - name: {string} name of frame to add\r\n *      - data: {array of objects} trace data\r\n *      - layout {object} layout definition\r\n *      - traces {array} trace indices\r\n *      - baseframe {string} name of frame from which this frame gets defaults\r\n *\r\n *  @param {array of integers} indices\r\n *      an array of integer indices matching the respective frames in `frameList`. If not\r\n *      provided, an index will be provided in serial order. If already used, the frame\r\n *      will be overwritten.\r\n */\r\nfunction addFrames(gd, frameList, indices) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    if(frameList === null || frameList === undefined) {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    if(!Lib.isPlotDiv(gd)) {\r\n        throw new Error(\r\n            'This element is not a Plotly plot: ' + gd + '. It\\'s likely that you\\'ve failed ' +\r\n            'to create a plot before adding frames. For more details, see ' +\r\n            'https://plotly.com/javascript/animations/'\r\n        );\r\n    }\r\n\r\n    var i, frame, j, idx;\r\n    var _frames = gd._transitionData._frames;\r\n    var _frameHash = gd._transitionData._frameHash;\r\n\r\n\r\n    if(!Array.isArray(frameList)) {\r\n        throw new Error('addFrames failure: frameList must be an Array of frame definitions' + frameList);\r\n    }\r\n\r\n    // Create a sorted list of insertions since we run into lots of problems if these\r\n    // aren't in ascending order of index:\r\n    //\r\n    // Strictly for sorting. Make sure this is guaranteed to never collide with any\r\n    // already-exisisting indices:\r\n    var bigIndex = _frames.length + frameList.length * 2;\r\n\r\n    var insertions = [];\r\n    var _frameHashLocal = {};\r\n    for(i = frameList.length - 1; i >= 0; i--) {\r\n        if(!Lib.isPlainObject(frameList[i])) continue;\r\n\r\n        // The entire logic for checking for this type of name collision can be removed once we migrate to ES6 and\r\n        // use a Map instead of an Object instance, as Map keys aren't converted to strings.\r\n        var lookupName = frameList[i].name;\r\n        var name = (_frameHash[lookupName] || _frameHashLocal[lookupName] || {}).name;\r\n        var newName = frameList[i].name;\r\n        var collisionPresent = _frameHash[name] || _frameHashLocal[name];\r\n\r\n        if(name && newName && typeof newName === 'number' && collisionPresent && numericNameWarningCount < numericNameWarningCountLimit) {\r\n            numericNameWarningCount++;\r\n\r\n            Lib.warn('addFrames: overwriting frame \"' + (_frameHash[name] || _frameHashLocal[name]).name +\r\n                '\" with a frame whose name of type \"number\" also equates to \"' +\r\n                name + '\". This is valid but may potentially lead to unexpected ' +\r\n                'behavior since all plotly.js frame names are stored internally ' +\r\n                'as strings.');\r\n\r\n            if(numericNameWarningCount === numericNameWarningCountLimit) {\r\n                Lib.warn('addFrames: This API call has yielded too many of these warnings. ' +\r\n                    'For the rest of this call, further warnings about numeric frame ' +\r\n                    'names will be suppressed.');\r\n            }\r\n        }\r\n\r\n        _frameHashLocal[lookupName] = {name: lookupName};\r\n\r\n        insertions.push({\r\n            frame: Plots.supplyFrameDefaults(frameList[i]),\r\n            index: (indices && indices[i] !== undefined && indices[i] !== null) ? indices[i] : bigIndex + i\r\n        });\r\n    }\r\n\r\n    // Sort this, taking note that undefined insertions end up at the end:\r\n    insertions.sort(function(a, b) {\r\n        if(a.index > b.index) return -1;\r\n        if(a.index < b.index) return 1;\r\n        return 0;\r\n    });\r\n\r\n    var ops = [];\r\n    var revops = [];\r\n    var frameCount = _frames.length;\r\n\r\n    for(i = insertions.length - 1; i >= 0; i--) {\r\n        frame = insertions[i].frame;\r\n\r\n        if(typeof frame.name === 'number') {\r\n            Lib.warn('Warning: addFrames accepts frames with numeric names, but the numbers are' +\r\n                'implicitly cast to strings');\r\n        }\r\n\r\n        if(!frame.name) {\r\n            // Repeatedly assign a default name, incrementing the counter each time until\r\n            // we get a name that's not in the hashed lookup table:\r\n            while(_frameHash[(frame.name = 'frame ' + gd._transitionData._counter++)]);\r\n        }\r\n\r\n        if(_frameHash[frame.name]) {\r\n            // If frame is present, overwrite its definition:\r\n            for(j = 0; j < _frames.length; j++) {\r\n                if((_frames[j] || {}).name === frame.name) break;\r\n            }\r\n            ops.push({type: 'replace', index: j, value: frame});\r\n            revops.unshift({type: 'replace', index: j, value: _frames[j]});\r\n        } else {\r\n            // Otherwise insert it at the end of the list:\r\n            idx = Math.max(0, Math.min(insertions[i].index, frameCount));\r\n\r\n            ops.push({type: 'insert', index: idx, value: frame});\r\n            revops.unshift({type: 'delete', index: idx});\r\n            frameCount++;\r\n        }\r\n    }\r\n\r\n    var undoFunc = Plots.modifyFrames;\r\n    var redoFunc = Plots.modifyFrames;\r\n    var undoArgs = [gd, revops];\r\n    var redoArgs = [gd, ops];\r\n\r\n    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\r\n\r\n    return Plots.modifyFrames(gd, ops);\r\n}\r\n\r\n/**\r\n * Delete frame\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n *\r\n * @param {array of integers} frameList\r\n *      list of integer indices of frames to be deleted\r\n */\r\nfunction deleteFrames(gd, frameList) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    if(!Lib.isPlotDiv(gd)) {\r\n        throw new Error('This element is not a Plotly plot: ' + gd);\r\n    }\r\n\r\n    var i, idx;\r\n    var _frames = gd._transitionData._frames;\r\n    var ops = [];\r\n    var revops = [];\r\n\r\n    if(!frameList) {\r\n        frameList = [];\r\n        for(i = 0; i < _frames.length; i++) {\r\n            frameList.push(i);\r\n        }\r\n    }\r\n\r\n    frameList = frameList.slice();\r\n    frameList.sort();\r\n\r\n    for(i = frameList.length - 1; i >= 0; i--) {\r\n        idx = frameList[i];\r\n        ops.push({type: 'delete', index: idx});\r\n        revops.unshift({type: 'insert', index: idx, value: _frames[idx]});\r\n    }\r\n\r\n    var undoFunc = Plots.modifyFrames;\r\n    var redoFunc = Plots.modifyFrames;\r\n    var undoArgs = [gd, revops];\r\n    var redoArgs = [gd, ops];\r\n\r\n    if(Queue) Queue.add(gd, undoFunc, undoArgs, redoFunc, redoArgs);\r\n\r\n    return Plots.modifyFrames(gd, ops);\r\n}\r\n\r\n/**\r\n * Purge a graph container div back to its initial pre-_doPlot state\r\n *\r\n * @param {string id or DOM element} gd\r\n *      the id or DOM element of the graph container div\r\n */\r\nfunction purge(gd) {\r\n    gd = Lib.getGraphDiv(gd);\r\n\r\n    var fullLayout = gd._fullLayout || {};\r\n    var fullData = gd._fullData || [];\r\n\r\n    // remove gl contexts\r\n    Plots.cleanPlot([], {}, fullData, fullLayout);\r\n\r\n    // purge properties\r\n    Plots.purge(gd);\r\n\r\n    // purge event emitter methods\r\n    Events.purge(gd);\r\n\r\n    // remove plot container\r\n    if(fullLayout._container) fullLayout._container.remove();\r\n\r\n    // in contrast to _doPlots.purge which does NOT clear _context!\r\n    delete gd._context;\r\n\r\n    return gd;\r\n}\r\n\r\n// determines if the graph div requires a recalculation of its inverse matrix transforms by comparing old + new bounding boxes.\r\nfunction calcInverseTransform(gd) {\r\n    var fullLayout = gd._fullLayout;\r\n\r\n    var newBBox = gd.getBoundingClientRect();\r\n    if(Lib.equalDomRects(newBBox, fullLayout._lastBBox)) return;\r\n\r\n    var m = fullLayout._invTransform = Lib.inverseTransformMatrix(Lib.getFullTransformMatrix(gd));\r\n    fullLayout._invScaleX = Math.sqrt(m[0][0] * m[0][0] + m[0][1] * m[0][1] + m[0][2] * m[0][2]);\r\n    fullLayout._invScaleY = Math.sqrt(m[1][0] * m[1][0] + m[1][1] * m[1][1] + m[1][2] * m[1][2]);\r\n    fullLayout._lastBBox = newBBox;\r\n}\r\n\r\n// -------------------------------------------------------\r\n// makePlotFramework: Create the plot container and axes\r\n// -------------------------------------------------------\r\nfunction makePlotFramework(gd) {\r\n    var gd3 = d3.select(gd);\r\n    var fullLayout = gd._fullLayout;\r\n\r\n    fullLayout._calcInverseTransform = calcInverseTransform;\r\n    fullLayout._calcInverseTransform(gd);\r\n\r\n    // Plot container\r\n    fullLayout._container = gd3.selectAll('.plot-container').data([0]);\r\n    fullLayout._container.enter()\r\n        .insert('div', ':first-child')\r\n        .classed('plot-container', true)\r\n        .classed('plotly', true);\r\n\r\n    // Make the svg container\r\n    fullLayout._paperdiv = fullLayout._container.selectAll('.svg-container').data([0]);\r\n    fullLayout._paperdiv.enter().append('div')\r\n        .classed('user-select-none', true)\r\n        .classed('svg-container', true)\r\n        .style('position', 'relative');\r\n\r\n    // Make the graph containers\r\n    // start fresh each time we get here, so we know the order comes out\r\n    // right, rather than enter/exit which can muck up the order\r\n    // TODO: sort out all the ordering so we don't have to\r\n    // explicitly delete anything\r\n    // FIXME: parcoords reuses this object, not the best pattern\r\n    fullLayout._glcontainer = fullLayout._paperdiv.selectAll('.gl-container')\r\n        .data([{}]);\r\n\r\n    fullLayout._glcontainer.enter().append('div')\r\n        .classed('gl-container', true);\r\n\r\n    fullLayout._paperdiv.selectAll('.main-svg').remove();\r\n    fullLayout._paperdiv.select('.modebar-container').remove();\r\n\r\n    fullLayout._paper = fullLayout._paperdiv.insert('svg', ':first-child')\r\n        .classed('main-svg', true);\r\n\r\n    fullLayout._toppaper = fullLayout._paperdiv.append('svg')\r\n        .classed('main-svg', true);\r\n\r\n    fullLayout._modebardiv = fullLayout._paperdiv.append('div');\r\n    delete fullLayout._modeBar;\r\n\r\n    fullLayout._hoverpaper = fullLayout._paperdiv.append('svg')\r\n        .classed('main-svg', true);\r\n\r\n    if(!fullLayout._uid) {\r\n        var otherUids = {};\r\n        d3.selectAll('defs').each(function() {\r\n            if(this.id) otherUids[this.id.split('-')[1]] = 1;\r\n        });\r\n        fullLayout._uid = Lib.randstr(otherUids);\r\n    }\r\n\r\n    fullLayout._paperdiv.selectAll('.main-svg')\r\n        .attr(xmlnsNamespaces.svgAttrs);\r\n\r\n    fullLayout._defs = fullLayout._paper.append('defs')\r\n        .attr('id', 'defs-' + fullLayout._uid);\r\n\r\n    fullLayout._clips = fullLayout._defs.append('g')\r\n        .classed('clips', true);\r\n\r\n    fullLayout._topdefs = fullLayout._toppaper.append('defs')\r\n        .attr('id', 'topdefs-' + fullLayout._uid);\r\n\r\n    fullLayout._topclips = fullLayout._topdefs.append('g')\r\n        .classed('clips', true);\r\n\r\n    fullLayout._bgLayer = fullLayout._paper.append('g')\r\n        .classed('bglayer', true);\r\n\r\n    fullLayout._draggers = fullLayout._paper.append('g')\r\n        .classed('draglayer', true);\r\n\r\n    // lower shape/image layer - note that this is behind\r\n    // all subplots data/grids but above the backgrounds\r\n    // except inset subplots, whose backgrounds are drawn\r\n    // inside their own group so that they appear above\r\n    // the data for the main subplot\r\n    // lower shapes and images which are fully referenced to\r\n    // a subplot still get drawn within the subplot's group\r\n    // so they will work correctly on insets\r\n    var layerBelow = fullLayout._paper.append('g')\r\n        .classed('layer-below', true);\r\n    fullLayout._imageLowerLayer = layerBelow.append('g')\r\n        .classed('imagelayer', true);\r\n    fullLayout._shapeLowerLayer = layerBelow.append('g')\r\n        .classed('shapelayer', true);\r\n\r\n    // single cartesian layer for the whole plot\r\n    fullLayout._cartesianlayer = fullLayout._paper.append('g').classed('cartesianlayer', true);\r\n\r\n    // single polar layer for the whole plot\r\n    fullLayout._polarlayer = fullLayout._paper.append('g').classed('polarlayer', true);\r\n\r\n    // single ternary layer for the whole plot\r\n    fullLayout._ternarylayer = fullLayout._paper.append('g').classed('ternarylayer', true);\r\n\r\n    // single geo layer for the whole plot\r\n    fullLayout._geolayer = fullLayout._paper.append('g').classed('geolayer', true);\r\n\r\n    // single funnelarea layer for the whole plot\r\n    fullLayout._funnelarealayer = fullLayout._paper.append('g').classed('funnelarealayer', true);\r\n\r\n    // single pie layer for the whole plot\r\n    fullLayout._pielayer = fullLayout._paper.append('g').classed('pielayer', true);\r\n\r\n    // single treemap layer for the whole plot\r\n    fullLayout._iciclelayer = fullLayout._paper.append('g').classed('iciclelayer', true);\r\n\r\n    // single treemap layer for the whole plot\r\n    fullLayout._treemaplayer = fullLayout._paper.append('g').classed('treemaplayer', true);\r\n\r\n    // single sunburst layer for the whole plot\r\n    fullLayout._sunburstlayer = fullLayout._paper.append('g').classed('sunburstlayer', true);\r\n\r\n    // single indicator layer for the whole plot\r\n    fullLayout._indicatorlayer = fullLayout._toppaper.append('g').classed('indicatorlayer', true);\r\n\r\n    // fill in image server scrape-svg\r\n    fullLayout._glimages = fullLayout._paper.append('g').classed('glimages', true);\r\n\r\n    // lastly upper shapes, info (legend, annotations) and hover layers go on top\r\n    // these are in a different svg element normally, but get collapsed into a single\r\n    // svg when exporting (after inserting 3D)\r\n    // upper shapes/images are only those drawn above the whole plot, including subplots\r\n    var layerAbove = fullLayout._toppaper.append('g')\r\n        .classed('layer-above', true);\r\n    fullLayout._imageUpperLayer = layerAbove.append('g')\r\n        .classed('imagelayer', true);\r\n    fullLayout._shapeUpperLayer = layerAbove.append('g')\r\n        .classed('shapelayer', true);\r\n\r\n    fullLayout._infolayer = fullLayout._toppaper.append('g').classed('infolayer', true);\r\n    fullLayout._menulayer = fullLayout._toppaper.append('g').classed('menulayer', true);\r\n    fullLayout._zoomlayer = fullLayout._toppaper.append('g').classed('zoomlayer', true);\r\n    fullLayout._hoverlayer = fullLayout._hoverpaper.append('g').classed('hoverlayer', true);\r\n\r\n    // Make the modebar container\r\n    fullLayout._modebardiv\r\n        .classed('modebar-container', true)\r\n        .style('position', 'absolute')\r\n        .style('top', '0px')\r\n        .style('right', '0px');\r\n\r\n    gd.emit('plotly_framework');\r\n}\r\n\r\nexports.animate = animate;\r\nexports.addFrames = addFrames;\r\nexports.deleteFrames = deleteFrames;\r\n\r\nexports.addTraces = addTraces;\r\nexports.deleteTraces = deleteTraces;\r\nexports.extendTraces = extendTraces;\r\nexports.moveTraces = moveTraces;\r\nexports.prependTraces = prependTraces;\r\n\r\nexports.newPlot = newPlot;\r\nexports._doPlot = _doPlot;\r\nexports.purge = purge;\r\n\r\nexports.react = react;\r\nexports.redraw = redraw;\r\nexports.relayout = relayout;\r\nexports.restyle = restyle;\r\n\r\nexports.setPlotConfig = setPlotConfig;\r\n\r\nexports.update = update;\r\n\r\nexports._guiRelayout = guiEdit(relayout);\r\nexports._guiRestyle = guiEdit(restyle);\r\nexports._guiUpdate = guiEdit(update);\r\n\r\nexports._storeDirectGUIEdit = _storeDirectGUIEdit;\r\n"]},"metadata":{},"sourceType":"script"}
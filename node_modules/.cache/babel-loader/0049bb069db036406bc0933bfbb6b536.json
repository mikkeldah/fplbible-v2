{"ast":null,"code":"'use strict';\n/**\r\n * Error bar computing function generator\r\n *\r\n * N.B. The generated function does not clean the dataPt entries. Non-numeric\r\n * entries result in undefined error magnitudes.\r\n *\r\n * @param {object} opts error bar attributes\r\n *\r\n * @return {function} :\r\n *      @param {numeric} dataPt data point from where to compute the error magnitude\r\n *      @param {number} index index of dataPt in its corresponding data array\r\n *      @return {array}\r\n *        - error[0] : error magnitude in the negative direction\r\n *        - error[1] : \" \" \" \" positive \"\r\n */\n\nmodule.exports = function makeComputeError(opts) {\n  var type = opts.type;\n  var symmetric = opts.symmetric;\n\n  if (type === 'data') {\n    var array = opts.array || [];\n\n    if (symmetric) {\n      return function computeError(dataPt, index) {\n        var val = +array[index];\n        return [val, val];\n      };\n    } else {\n      var arrayminus = opts.arrayminus || [];\n      return function computeError(dataPt, index) {\n        var val = +array[index];\n        var valMinus = +arrayminus[index]; // in case one is present and the other is missing, fill in 0\n        // so we still see the present one. Mostly useful during manual\n        // data entry.\n\n        if (!isNaN(val) || !isNaN(valMinus)) {\n          return [valMinus || 0, val || 0];\n        }\n\n        return [NaN, NaN];\n      };\n    }\n  } else {\n    var computeErrorValue = makeComputeErrorValue(type, opts.value);\n    var computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);\n\n    if (symmetric || opts.valueminus === undefined) {\n      return function computeError(dataPt) {\n        var val = computeErrorValue(dataPt);\n        return [val, val];\n      };\n    } else {\n      return function computeError(dataPt) {\n        return [computeErrorValueMinus(dataPt), computeErrorValue(dataPt)];\n      };\n    }\n  }\n};\n/**\r\n * Compute error bar magnitude (for all types except data)\r\n *\r\n * @param {string} type error bar type\r\n * @param {numeric} value error bar value\r\n *\r\n * @return {function} :\r\n *      @param {numeric} dataPt\r\n */\n\n\nfunction makeComputeErrorValue(type, value) {\n  if (type === 'percent') {\n    return function (dataPt) {\n      return Math.abs(dataPt * value / 100);\n    };\n  }\n\n  if (type === 'constant') {\n    return function () {\n      return Math.abs(value);\n    };\n  }\n\n  if (type === 'sqrt') {\n    return function (dataPt) {\n      return Math.sqrt(Math.abs(dataPt));\n    };\n  }\n}","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/plotly.js/src/components/errorbars/compute_error.js"],"names":["module","exports","makeComputeError","opts","type","symmetric","array","computeError","dataPt","index","val","arrayminus","valMinus","isNaN","NaN","computeErrorValue","makeComputeErrorValue","value","computeErrorValueMinus","valueminus","undefined","Math","abs","sqrt"],"mappings":"AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAA,MAAM,CAACC,OAAP,GAAiB,SAASC,gBAAT,CAA0BC,IAA1B,EAAgC;AAC7C,MAAIC,IAAI,GAAGD,IAAI,CAACC,IAAhB;AACA,MAAIC,SAAS,GAAGF,IAAI,CAACE,SAArB;;AAEA,MAAGD,IAAI,KAAK,MAAZ,EAAoB;AAChB,QAAIE,KAAK,GAAGH,IAAI,CAACG,KAAL,IAAc,EAA1B;;AAEA,QAAGD,SAAH,EAAc;AACV,aAAO,SAASE,YAAT,CAAsBC,MAAtB,EAA8BC,KAA9B,EAAqC;AACxC,YAAIC,GAAG,GAAG,CAAEJ,KAAK,CAACG,KAAD,CAAjB;AACA,eAAO,CAACC,GAAD,EAAMA,GAAN,CAAP;AACH,OAHD;AAIH,KALD,MAKO;AACH,UAAIC,UAAU,GAAGR,IAAI,CAACQ,UAAL,IAAmB,EAApC;AACA,aAAO,SAASJ,YAAT,CAAsBC,MAAtB,EAA8BC,KAA9B,EAAqC;AACxC,YAAIC,GAAG,GAAG,CAACJ,KAAK,CAACG,KAAD,CAAhB;AACA,YAAIG,QAAQ,GAAG,CAACD,UAAU,CAACF,KAAD,CAA1B,CAFwC,CAGxC;AACA;AACA;;AACA,YAAG,CAACI,KAAK,CAACH,GAAD,CAAN,IAAe,CAACG,KAAK,CAACD,QAAD,CAAxB,EAAoC;AAChC,iBAAO,CAACA,QAAQ,IAAI,CAAb,EAAgBF,GAAG,IAAI,CAAvB,CAAP;AACH;;AACD,eAAO,CAACI,GAAD,EAAMA,GAAN,CAAP;AACH,OAVD;AAWH;AACJ,GAtBD,MAsBO;AACH,QAAIC,iBAAiB,GAAGC,qBAAqB,CAACZ,IAAD,EAAOD,IAAI,CAACc,KAAZ,CAA7C;AACA,QAAIC,sBAAsB,GAAGF,qBAAqB,CAACZ,IAAD,EAAOD,IAAI,CAACgB,UAAZ,CAAlD;;AAEA,QAAGd,SAAS,IAAIF,IAAI,CAACgB,UAAL,KAAoBC,SAApC,EAA+C;AAC3C,aAAO,SAASb,YAAT,CAAsBC,MAAtB,EAA8B;AACjC,YAAIE,GAAG,GAAGK,iBAAiB,CAACP,MAAD,CAA3B;AACA,eAAO,CAACE,GAAD,EAAMA,GAAN,CAAP;AACH,OAHD;AAIH,KALD,MAKO;AACH,aAAO,SAASH,YAAT,CAAsBC,MAAtB,EAA8B;AACjC,eAAO,CACHU,sBAAsB,CAACV,MAAD,CADnB,EAEHO,iBAAiB,CAACP,MAAD,CAFd,CAAP;AAIH,OALD;AAMH;AACJ;AACJ,CA5CD;AA8CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASQ,qBAAT,CAA+BZ,IAA/B,EAAqCa,KAArC,EAA4C;AACxC,MAAGb,IAAI,KAAK,SAAZ,EAAuB;AACnB,WAAO,UAASI,MAAT,EAAiB;AACpB,aAAOa,IAAI,CAACC,GAAL,CAASd,MAAM,GAAGS,KAAT,GAAiB,GAA1B,CAAP;AACH,KAFD;AAGH;;AACD,MAAGb,IAAI,KAAK,UAAZ,EAAwB;AACpB,WAAO,YAAW;AACd,aAAOiB,IAAI,CAACC,GAAL,CAASL,KAAT,CAAP;AACH,KAFD;AAGH;;AACD,MAAGb,IAAI,KAAK,MAAZ,EAAoB;AAChB,WAAO,UAASI,MAAT,EAAiB;AACpB,aAAOa,IAAI,CAACE,IAAL,CAAUF,IAAI,CAACC,GAAL,CAASd,MAAT,CAAV,CAAP;AACH,KAFD;AAGH;AACJ","sourcesContent":["'use strict';\r\n\r\n\r\n/**\r\n * Error bar computing function generator\r\n *\r\n * N.B. The generated function does not clean the dataPt entries. Non-numeric\r\n * entries result in undefined error magnitudes.\r\n *\r\n * @param {object} opts error bar attributes\r\n *\r\n * @return {function} :\r\n *      @param {numeric} dataPt data point from where to compute the error magnitude\r\n *      @param {number} index index of dataPt in its corresponding data array\r\n *      @return {array}\r\n *        - error[0] : error magnitude in the negative direction\r\n *        - error[1] : \" \" \" \" positive \"\r\n */\r\nmodule.exports = function makeComputeError(opts) {\r\n    var type = opts.type;\r\n    var symmetric = opts.symmetric;\r\n\r\n    if(type === 'data') {\r\n        var array = opts.array || [];\r\n\r\n        if(symmetric) {\r\n            return function computeError(dataPt, index) {\r\n                var val = +(array[index]);\r\n                return [val, val];\r\n            };\r\n        } else {\r\n            var arrayminus = opts.arrayminus || [];\r\n            return function computeError(dataPt, index) {\r\n                var val = +array[index];\r\n                var valMinus = +arrayminus[index];\r\n                // in case one is present and the other is missing, fill in 0\r\n                // so we still see the present one. Mostly useful during manual\r\n                // data entry.\r\n                if(!isNaN(val) || !isNaN(valMinus)) {\r\n                    return [valMinus || 0, val || 0];\r\n                }\r\n                return [NaN, NaN];\r\n            };\r\n        }\r\n    } else {\r\n        var computeErrorValue = makeComputeErrorValue(type, opts.value);\r\n        var computeErrorValueMinus = makeComputeErrorValue(type, opts.valueminus);\r\n\r\n        if(symmetric || opts.valueminus === undefined) {\r\n            return function computeError(dataPt) {\r\n                var val = computeErrorValue(dataPt);\r\n                return [val, val];\r\n            };\r\n        } else {\r\n            return function computeError(dataPt) {\r\n                return [\r\n                    computeErrorValueMinus(dataPt),\r\n                    computeErrorValue(dataPt)\r\n                ];\r\n            };\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Compute error bar magnitude (for all types except data)\r\n *\r\n * @param {string} type error bar type\r\n * @param {numeric} value error bar value\r\n *\r\n * @return {function} :\r\n *      @param {numeric} dataPt\r\n */\r\nfunction makeComputeErrorValue(type, value) {\r\n    if(type === 'percent') {\r\n        return function(dataPt) {\r\n            return Math.abs(dataPt * value / 100);\r\n        };\r\n    }\r\n    if(type === 'constant') {\r\n        return function() {\r\n            return Math.abs(value);\r\n        };\r\n    }\r\n    if(type === 'sqrt') {\r\n        return function(dataPt) {\r\n            return Math.sqrt(Math.abs(dataPt));\r\n        };\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}
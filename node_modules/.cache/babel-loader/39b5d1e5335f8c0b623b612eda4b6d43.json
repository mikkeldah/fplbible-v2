{"ast":null,"code":"'use strict';\n\nvar Font = require('css-font');\n\nvar pick = require('pick-by-alias');\n\nvar createRegl = require('regl');\n\nvar createGl = require('gl-util/context');\n\nvar WeakMap = require('es6-weak-map');\n\nvar rgba = require('color-normalize');\n\nvar fontAtlas = require('font-atlas');\n\nvar pool = require('typedarray-pool');\n\nvar parseRect = require('parse-rect');\n\nvar isObj = require('is-plain-obj');\n\nvar parseUnit = require('parse-unit');\n\nvar px = require('to-px');\n\nvar kerning = require('detect-kerning');\n\nvar extend = require('object-assign');\n\nvar metrics = require('font-measure');\n\nvar flatten = require('flatten-vertex-data');\n\nvar ref = require('bit-twiddle');\n\nvar nextPow2 = ref.nextPow2;\nvar shaderCache = new WeakMap(); // Safari does not support font-stretch\n\nvar isStretchSupported = false;\n\nif (document.body) {\n  var el = document.body.appendChild(document.createElement('div'));\n  el.style.font = 'italic small-caps bold condensed 16px/2 cursive';\n\n  if (getComputedStyle(el).fontStretch) {\n    isStretchSupported = true;\n  }\n\n  document.body.removeChild(el);\n}\n\nvar GlText = function GlText(o) {\n  if (isRegl(o)) {\n    o = {\n      regl: o\n    };\n    this.gl = o.regl._gl;\n  } else {\n    this.gl = createGl(o);\n  }\n\n  this.shader = shaderCache.get(this.gl);\n\n  if (!this.shader) {\n    this.regl = o.regl || createRegl({\n      gl: this.gl\n    });\n  } else {\n    this.regl = this.shader.regl;\n  }\n\n  this.charBuffer = this.regl.buffer({\n    type: 'uint8',\n    usage: 'stream'\n  });\n  this.sizeBuffer = this.regl.buffer({\n    type: 'float',\n    usage: 'stream'\n  });\n\n  if (!this.shader) {\n    this.shader = this.createShader();\n    shaderCache.set(this.gl, this.shader);\n  }\n\n  this.batch = []; // multiple options initial state\n\n  this.fontSize = [];\n  this.font = [];\n  this.fontAtlas = [];\n  this.draw = this.shader.draw.bind(this);\n\n  this.render = function () {\n    // FIXME: add Safari regl report here:\n    // charBuffer and width just do not trigger\n    this.regl._refresh();\n\n    this.draw(this.batch);\n  };\n\n  this.canvas = this.gl.canvas;\n  this.update(isObj(o) ? o : {});\n};\n\nGlText.prototype.createShader = function createShader() {\n  var regl = this.regl; // FIXME: store 2 shader versions: with normal viewport and without\n  // draw texture method\n\n  var draw = regl({\n    blend: {\n      enable: true,\n      color: [0, 0, 0, 1],\n      func: {\n        srcRGB: 'src alpha',\n        dstRGB: 'one minus src alpha',\n        srcAlpha: 'one minus dst alpha',\n        dstAlpha: 'one'\n      }\n    },\n    stencil: {\n      enable: false\n    },\n    depth: {\n      enable: false\n    },\n    count: regl.prop('count'),\n    offset: regl.prop('offset'),\n    attributes: {\n      charOffset: {\n        offset: 4,\n        stride: 8,\n        buffer: regl.this('sizeBuffer')\n      },\n      width: {\n        offset: 0,\n        stride: 8,\n        buffer: regl.this('sizeBuffer')\n      },\n      char: regl.this('charBuffer'),\n      position: regl.this('position')\n    },\n    uniforms: {\n      atlasSize: function (c, p) {\n        return [p.atlas.width, p.atlas.height];\n      },\n      atlasDim: function (c, p) {\n        return [p.atlas.cols, p.atlas.rows];\n      },\n      atlas: function (c, p) {\n        return p.atlas.texture;\n      },\n      charStep: function (c, p) {\n        return p.atlas.step;\n      },\n      em: function (c, p) {\n        return p.atlas.em;\n      },\n      color: regl.prop('color'),\n      opacity: regl.prop('opacity'),\n      viewport: regl.this('viewportArray'),\n      scale: regl.this('scale'),\n      align: regl.prop('align'),\n      baseline: regl.prop('baseline'),\n      translate: regl.this('translate'),\n      positionOffset: regl.prop('positionOffset')\n    },\n    primitive: 'points',\n    viewport: regl.this('viewport'),\n    vert: \"\\n\\t\\t\\tprecision highp float;\\n\\t\\t\\tattribute float width, charOffset, char;\\n\\t\\t\\tattribute vec2 position;\\n\\t\\t\\tuniform float fontSize, charStep, em, align, baseline;\\n\\t\\t\\tuniform vec4 viewport;\\n\\t\\t\\tuniform vec4 color;\\n\\t\\t\\tuniform vec2 atlasSize, atlasDim, scale, translate, positionOffset;\\n\\t\\t\\tvarying vec2 charCoord, charId;\\n\\t\\t\\tvarying float charWidth;\\n\\t\\t\\tvarying vec4 fontColor;\\n\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\" + (!GlText.normalViewport ? 'vec2 positionOffset = vec2(positionOffset.x,- positionOffset.y);' : '') + \"\\n\\n\\t\\t\\t\\tvec2 offset = floor(em * (vec2(align + charOffset, baseline)\\n\\t\\t\\t\\t\\t+ positionOffset))\\n\\t\\t\\t\\t\\t/ (viewport.zw * scale.xy);\\n\\n\\t\\t\\t\\tvec2 position = (position + translate) * scale;\\n\\t\\t\\t\\tposition += offset * scale;\\n\\n\\t\\t\\t\\t\" + (GlText.normalViewport ? 'position.y = 1. - position.y;' : '') + \"\\n\\n\\t\\t\\t\\tcharCoord = position * viewport.zw + viewport.xy;\\n\\n\\t\\t\\t\\tgl_Position = vec4(position * 2. - 1., 0, 1);\\n\\n\\t\\t\\t\\tgl_PointSize = charStep;\\n\\n\\t\\t\\t\\tcharId.x = mod(char, atlasDim.x);\\n\\t\\t\\t\\tcharId.y = floor(char / atlasDim.x);\\n\\n\\t\\t\\t\\tcharWidth = width * em;\\n\\n\\t\\t\\t\\tfontColor = color / 255.;\\n\\t\\t\\t}\",\n    frag: \"\\n\\t\\t\\tprecision highp float;\\n\\t\\t\\tuniform sampler2D atlas;\\n\\t\\t\\tuniform float fontSize, charStep, opacity;\\n\\t\\t\\tuniform vec2 atlasSize;\\n\\t\\t\\tuniform vec4 viewport;\\n\\t\\t\\tvarying vec4 fontColor;\\n\\t\\t\\tvarying vec2 charCoord, charId;\\n\\t\\t\\tvarying float charWidth;\\n\\n\\t\\t\\tfloat lightness(vec4 color) {\\n\\t\\t\\t\\treturn color.r * 0.299 + color.g * 0.587 + color.b * 0.114;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid main () {\\n\\t\\t\\t\\tvec2 uv = gl_FragCoord.xy - charCoord + charStep * .5;\\n\\t\\t\\t\\tfloat halfCharStep = floor(charStep * .5 + .5);\\n\\n\\t\\t\\t\\t// invert y and shift by 1px (FF expecially needs that)\\n\\t\\t\\t\\tuv.y = charStep - uv.y;\\n\\n\\t\\t\\t\\t// ignore points outside of character bounding box\\n\\t\\t\\t\\tfloat halfCharWidth = ceil(charWidth * .5);\\n\\t\\t\\t\\tif (floor(uv.x) > halfCharStep + halfCharWidth ||\\n\\t\\t\\t\\t\\tfloor(uv.x) < halfCharStep - halfCharWidth) return;\\n\\n\\t\\t\\t\\tuv += charId * charStep;\\n\\t\\t\\t\\tuv = uv / atlasSize;\\n\\n\\t\\t\\t\\tvec4 color = fontColor;\\n\\t\\t\\t\\tvec4 mask = texture2D(atlas, uv);\\n\\n\\t\\t\\t\\tfloat maskY = lightness(mask);\\n\\t\\t\\t\\t// float colorY = lightness(color);\\n\\t\\t\\t\\tcolor.a *= maskY;\\n\\t\\t\\t\\tcolor.a *= opacity;\\n\\n\\t\\t\\t\\t// color.a += .1;\\n\\n\\t\\t\\t\\t// antialiasing, see yiq color space y-channel formula\\n\\t\\t\\t\\t// color.rgb += (1. - color.rgb) * (1. - mask.rgb);\\n\\n\\t\\t\\t\\tgl_FragColor = color;\\n\\t\\t\\t}\"\n  }); // per font-size atlas\n\n  var atlas = {};\n  return {\n    regl: regl,\n    draw: draw,\n    atlas: atlas\n  };\n};\n\nGlText.prototype.update = function update(o) {\n  var this$1 = this;\n\n  if (typeof o === 'string') {\n    o = {\n      text: o\n    };\n  } else if (!o) {\n    return;\n  } // FIXME: make this a static transform or more general approact\n\n\n  o = pick(o, {\n    position: 'position positions coord coords coordinates',\n    font: 'font fontFace fontface typeface cssFont css-font family fontFamily',\n    fontSize: 'fontSize fontsize size font-size',\n    text: 'text texts chars characters value values symbols',\n    align: 'align alignment textAlign textbaseline',\n    baseline: 'baseline textBaseline textbaseline',\n    direction: 'dir direction textDirection',\n    color: 'color colour fill fill-color fillColor textColor textcolor',\n    kerning: 'kerning kern',\n    range: 'range dataBox',\n    viewport: 'vp viewport viewBox viewbox viewPort',\n    opacity: 'opacity alpha transparency visible visibility opaque',\n    offset: 'offset positionOffset padding shift indent indentation'\n  }, true);\n\n  if (o.opacity != null) {\n    if (Array.isArray(o.opacity)) {\n      this.opacity = o.opacity.map(function (o) {\n        return parseFloat(o);\n      });\n    } else {\n      this.opacity = parseFloat(o.opacity);\n    }\n  }\n\n  if (o.viewport != null) {\n    this.viewport = parseRect(o.viewport);\n\n    if (GlText.normalViewport) {\n      this.viewport.y = this.canvas.height - this.viewport.y - this.viewport.height;\n    }\n\n    this.viewportArray = [this.viewport.x, this.viewport.y, this.viewport.width, this.viewport.height];\n  }\n\n  if (this.viewport == null) {\n    this.viewport = {\n      x: 0,\n      y: 0,\n      width: this.gl.drawingBufferWidth,\n      height: this.gl.drawingBufferHeight\n    };\n    this.viewportArray = [this.viewport.x, this.viewport.y, this.viewport.width, this.viewport.height];\n  }\n\n  if (o.kerning != null) {\n    this.kerning = o.kerning;\n  }\n\n  if (o.offset != null) {\n    if (typeof o.offset === 'number') {\n      o.offset = [o.offset, 0];\n    }\n\n    this.positionOffset = flatten(o.offset);\n  }\n\n  if (o.direction) {\n    this.direction = o.direction;\n  }\n\n  if (o.range) {\n    this.range = o.range;\n    this.scale = [1 / (o.range[2] - o.range[0]), 1 / (o.range[3] - o.range[1])];\n    this.translate = [-o.range[0], -o.range[1]];\n  }\n\n  if (o.scale) {\n    this.scale = o.scale;\n  }\n\n  if (o.translate) {\n    this.translate = o.translate;\n  } // default scale corresponds to viewport\n\n\n  if (!this.scale) {\n    this.scale = [1 / this.viewport.width, 1 / this.viewport.height];\n  }\n\n  if (!this.translate) {\n    this.translate = [0, 0];\n  }\n\n  if (!this.font.length && !o.font) {\n    o.font = GlText.baseFontSize + 'px sans-serif';\n  } // normalize font caching string\n\n\n  var newFont = false,\n      newFontSize = false; // obtain new font data\n\n  if (o.font) {\n    (Array.isArray(o.font) ? o.font : [o.font]).forEach(function (font, i) {\n      // normalize font\n      if (typeof font === 'string') {\n        try {\n          font = Font.parse(font);\n        } catch (e) {\n          font = Font.parse(GlText.baseFontSize + 'px ' + font);\n        }\n      } else {\n        font = Font.parse(Font.stringify(font));\n      }\n\n      var baseString = Font.stringify({\n        size: GlText.baseFontSize,\n        family: font.family,\n        stretch: isStretchSupported ? font.stretch : undefined,\n        variant: font.variant,\n        weight: font.weight,\n        style: font.style\n      });\n      var unit = parseUnit(font.size);\n      var fs = Math.round(unit[0] * px(unit[1]));\n\n      if (fs !== this$1.fontSize[i]) {\n        newFontSize = true;\n        this$1.fontSize[i] = fs;\n      } // calc new font metrics/atlas\n\n\n      if (!this$1.font[i] || baseString != this$1.font[i].baseString) {\n        newFont = true; // obtain font cache or create one\n\n        this$1.font[i] = GlText.fonts[baseString];\n\n        if (!this$1.font[i]) {\n          var family = font.family.join(', ');\n          var style = [font.style];\n\n          if (font.style != font.variant) {\n            style.push(font.variant);\n          }\n\n          if (font.variant != font.weight) {\n            style.push(font.weight);\n          }\n\n          if (isStretchSupported && font.weight != font.stretch) {\n            style.push(font.stretch);\n          }\n\n          this$1.font[i] = {\n            baseString: baseString,\n            // typeface\n            family: family,\n            weight: font.weight,\n            stretch: font.stretch,\n            style: font.style,\n            variant: font.variant,\n            // widths of characters\n            width: {},\n            // kernin pairs offsets\n            kerning: {},\n            metrics: metrics(family, {\n              origin: 'top',\n              fontSize: GlText.baseFontSize,\n              fontStyle: style.join(' ')\n            })\n          };\n          GlText.fonts[baseString] = this$1.font[i];\n        }\n      }\n    });\n  } // FIXME: make independend font-size\n  // if (o.fontSize) {\n  // let unit = parseUnit(o.fontSize)\n  // let fs = Math.round(unit[0] * px(unit[1]))\n  // if (fs != this.fontSize) {\n  // \tnewFontSize = true\n  // \tthis.fontSize = fs\n  // }\n  // }\n\n\n  if (newFont || newFontSize) {\n    this.font.forEach(function (font, i) {\n      var fontString = Font.stringify({\n        size: this$1.fontSize[i],\n        family: font.family,\n        stretch: isStretchSupported ? font.stretch : undefined,\n        variant: font.variant,\n        weight: font.weight,\n        style: font.style\n      }); // calc new font size atlas\n\n      this$1.fontAtlas[i] = this$1.shader.atlas[fontString];\n\n      if (!this$1.fontAtlas[i]) {\n        var metrics = font.metrics;\n        this$1.shader.atlas[fontString] = this$1.fontAtlas[i] = {\n          fontString: fontString,\n          // even step is better for rendered characters\n          step: Math.ceil(this$1.fontSize[i] * metrics.bottom * .5) * 2,\n          em: this$1.fontSize[i],\n          cols: 0,\n          rows: 0,\n          height: 0,\n          width: 0,\n          chars: [],\n          ids: {},\n          texture: this$1.regl.texture()\n        };\n      } // bump atlas characters\n\n\n      if (o.text == null) {\n        o.text = this$1.text;\n      }\n    });\n  } // if multiple positions - duplicate text arguments\n  // FIXME: this possibly can be done better to avoid array spawn\n\n\n  if (typeof o.text === 'string' && o.position && o.position.length > 2) {\n    var textArray = Array(o.position.length * .5);\n\n    for (var i = 0; i < textArray.length; i++) {\n      textArray[i] = o.text;\n    }\n\n    o.text = textArray;\n  } // calculate offsets for the new font/text\n\n\n  var newAtlasChars;\n\n  if (o.text != null || newFont) {\n    // FIXME: ignore spaces\n    // text offsets within the text buffer\n    this.textOffsets = [0];\n\n    if (Array.isArray(o.text)) {\n      this.count = o.text[0].length;\n      this.counts = [this.count];\n\n      for (var i$1 = 1; i$1 < o.text.length; i$1++) {\n        this.textOffsets[i$1] = this.textOffsets[i$1 - 1] + o.text[i$1 - 1].length;\n        this.count += o.text[i$1].length;\n        this.counts.push(o.text[i$1].length);\n      }\n\n      this.text = o.text.join('');\n    } else {\n      this.text = o.text;\n      this.count = this.text.length;\n      this.counts = [this.count];\n    }\n\n    newAtlasChars = []; // detect & measure new characters\n\n    this.font.forEach(function (font, idx) {\n      GlText.atlasContext.font = font.baseString;\n      var atlas = this$1.fontAtlas[idx];\n\n      for (var i = 0; i < this$1.text.length; i++) {\n        var char = this$1.text.charAt(i);\n\n        if (atlas.ids[char] == null) {\n          atlas.ids[char] = atlas.chars.length;\n          atlas.chars.push(char);\n          newAtlasChars.push(char);\n        }\n\n        if (font.width[char] == null) {\n          font.width[char] = GlText.atlasContext.measureText(char).width / GlText.baseFontSize; // measure kerning pairs for the new character\n\n          if (this$1.kerning) {\n            var pairs = [];\n\n            for (var baseChar in font.width) {\n              pairs.push(baseChar + char, char + baseChar);\n            }\n\n            extend(font.kerning, kerning(font.family, {\n              pairs: pairs\n            }));\n          }\n        }\n      }\n    });\n  } // create single position buffer (faster than batch or multiple separate instances)\n\n\n  if (o.position) {\n    if (o.position.length > 2) {\n      var flat = !o.position[0].length;\n      var positionData = pool.mallocFloat(this.count * 2);\n\n      for (var i$2 = 0, ptr = 0; i$2 < this.counts.length; i$2++) {\n        var count = this.counts[i$2];\n\n        if (flat) {\n          for (var j = 0; j < count; j++) {\n            positionData[ptr++] = o.position[i$2 * 2];\n            positionData[ptr++] = o.position[i$2 * 2 + 1];\n          }\n        } else {\n          for (var j$1 = 0; j$1 < count; j$1++) {\n            positionData[ptr++] = o.position[i$2][0];\n            positionData[ptr++] = o.position[i$2][1];\n          }\n        }\n      }\n\n      if (this.position.call) {\n        this.position({\n          type: 'float',\n          data: positionData\n        });\n      } else {\n        this.position = this.regl.buffer({\n          type: 'float',\n          data: positionData\n        });\n      }\n\n      pool.freeFloat(positionData);\n    } else {\n      if (this.position.destroy) {\n        this.position.destroy();\n      }\n\n      this.position = {\n        constant: o.position\n      };\n    }\n  } // populate text/offset buffers if font/text has changed\n  // as [charWidth, offset, charWidth, offset...]\n  // that is in em units since font-size can change often\n\n\n  if (o.text || newFont) {\n    var charIds = pool.mallocUint8(this.count);\n    var sizeData = pool.mallocFloat(this.count * 2);\n    this.textWidth = [];\n\n    for (var i$3 = 0, ptr$1 = 0; i$3 < this.counts.length; i$3++) {\n      var count$1 = this.counts[i$3];\n      var font = this.font[i$3] || this.font[0];\n      var atlas = this.fontAtlas[i$3] || this.fontAtlas[0];\n\n      for (var j$2 = 0; j$2 < count$1; j$2++) {\n        var char = this.text.charAt(ptr$1);\n        var prevChar = this.text.charAt(ptr$1 - 1);\n        charIds[ptr$1] = atlas.ids[char];\n        sizeData[ptr$1 * 2] = font.width[char];\n\n        if (j$2) {\n          var prevWidth = sizeData[ptr$1 * 2 - 2];\n          var currWidth = sizeData[ptr$1 * 2];\n          var prevOffset = sizeData[ptr$1 * 2 - 1];\n          var offset = prevOffset + prevWidth * .5 + currWidth * .5;\n\n          if (this.kerning) {\n            var kerning$1 = font.kerning[prevChar + char];\n\n            if (kerning$1) {\n              offset += kerning$1 * 1e-3;\n            }\n          }\n\n          sizeData[ptr$1 * 2 + 1] = offset;\n        } else {\n          sizeData[ptr$1 * 2 + 1] = sizeData[ptr$1 * 2] * .5;\n        }\n\n        ptr$1++;\n      }\n\n      this.textWidth.push(!sizeData.length ? 0 : // last offset + half last width\n      sizeData[ptr$1 * 2 - 2] * .5 + sizeData[ptr$1 * 2 - 1]);\n    } // bump recalc align offset\n\n\n    if (!o.align) {\n      o.align = this.align;\n    }\n\n    this.charBuffer({\n      data: charIds,\n      type: 'uint8',\n      usage: 'stream'\n    });\n    this.sizeBuffer({\n      data: sizeData,\n      type: 'float',\n      usage: 'stream'\n    });\n    pool.freeUint8(charIds);\n    pool.freeFloat(sizeData); // udpate font atlas and texture\n\n    if (newAtlasChars.length) {\n      this.font.forEach(function (font, i) {\n        var atlas = this$1.fontAtlas[i]; // FIXME: insert metrics-based ratio here\n\n        var step = atlas.step;\n        var maxCols = Math.floor(GlText.maxAtlasSize / step);\n        var cols = Math.min(maxCols, atlas.chars.length);\n        var rows = Math.ceil(atlas.chars.length / cols);\n        var atlasWidth = nextPow2(cols * step); // let atlasHeight = Math.min(rows * step + step * .5, GlText.maxAtlasSize);\n\n        var atlasHeight = nextPow2(rows * step);\n        atlas.width = atlasWidth;\n        atlas.height = atlasHeight;\n        atlas.rows = rows;\n        atlas.cols = cols;\n\n        if (!atlas.em) {\n          return;\n        }\n\n        atlas.texture({\n          data: fontAtlas({\n            canvas: GlText.atlasCanvas,\n            font: atlas.fontString,\n            chars: atlas.chars,\n            shape: [atlasWidth, atlasHeight],\n            step: [step, step]\n          })\n        });\n      });\n    }\n  }\n\n  if (o.align) {\n    this.align = o.align;\n    this.alignOffset = this.textWidth.map(function (textWidth, i) {\n      var align = !Array.isArray(this$1.align) ? this$1.align : this$1.align.length > 1 ? this$1.align[i] : this$1.align[0];\n\n      if (typeof align === 'number') {\n        return align;\n      }\n\n      switch (align) {\n        case 'right':\n        case 'end':\n          return -textWidth;\n\n        case 'center':\n        case 'centre':\n        case 'middle':\n          return -textWidth * .5;\n      }\n\n      return 0;\n    });\n  }\n\n  if (this.baseline == null && o.baseline == null) {\n    o.baseline = 0;\n  }\n\n  if (o.baseline != null) {\n    this.baseline = o.baseline;\n\n    if (!Array.isArray(this.baseline)) {\n      this.baseline = [this.baseline];\n    }\n\n    this.baselineOffset = this.baseline.map(function (baseline, i) {\n      var m = (this$1.font[i] || this$1.font[0]).metrics;\n      var base = 0;\n      base += m.bottom * .5;\n\n      if (typeof baseline === 'number') {\n        base += baseline - m.baseline;\n      } else {\n        base += -m[baseline];\n      }\n\n      if (!GlText.normalViewport) {\n        base *= -1;\n      }\n\n      return base;\n    });\n  } // flatten colors to a single uint8 array\n\n\n  if (o.color != null) {\n    if (!o.color) {\n      o.color = 'transparent';\n    } // single color\n\n\n    if (typeof o.color === 'string' || !isNaN(o.color)) {\n      this.color = rgba(o.color, 'uint8');\n    } // array\n    else {\n        var colorData; // flat array\n\n        if (typeof o.color[0] === 'number' && o.color.length > this.counts.length) {\n          var l = o.color.length;\n          colorData = pool.mallocUint8(l);\n          var sub = (o.color.subarray || o.color.slice).bind(o.color);\n\n          for (var i$4 = 0; i$4 < l; i$4 += 4) {\n            colorData.set(rgba(sub(i$4, i$4 + 4), 'uint8'), i$4);\n          }\n        } // nested array\n        else {\n            var l$1 = o.color.length;\n            colorData = pool.mallocUint8(l$1 * 4);\n\n            for (var i$5 = 0; i$5 < l$1; i$5++) {\n              colorData.set(rgba(o.color[i$5] || 0, 'uint8'), i$5 * 4);\n            }\n          }\n\n        this.color = colorData;\n      }\n  } // update render batch\n\n\n  if (o.position || o.text || o.color || o.baseline || o.align || o.font || o.offset || o.opacity) {\n    var isBatch = this.color.length > 4 || this.baselineOffset.length > 1 || this.align && this.align.length > 1 || this.fontAtlas.length > 1 || this.positionOffset.length > 2;\n\n    if (isBatch) {\n      var length = Math.max(this.position.length * .5 || 0, this.color.length * .25 || 0, this.baselineOffset.length || 0, this.alignOffset.length || 0, this.font.length || 0, this.opacity.length || 0, this.positionOffset.length * .5 || 0);\n      this.batch = Array(length);\n\n      for (var i$6 = 0; i$6 < this.batch.length; i$6++) {\n        this.batch[i$6] = {\n          count: this.counts.length > 1 ? this.counts[i$6] : this.counts[0],\n          offset: this.textOffsets.length > 1 ? this.textOffsets[i$6] : this.textOffsets[0],\n          color: !this.color ? [0, 0, 0, 255] : this.color.length <= 4 ? this.color : this.color.subarray(i$6 * 4, i$6 * 4 + 4),\n          opacity: Array.isArray(this.opacity) ? this.opacity[i$6] : this.opacity,\n          baseline: this.baselineOffset[i$6] != null ? this.baselineOffset[i$6] : this.baselineOffset[0],\n          align: !this.align ? 0 : this.alignOffset[i$6] != null ? this.alignOffset[i$6] : this.alignOffset[0],\n          atlas: this.fontAtlas[i$6] || this.fontAtlas[0],\n          positionOffset: this.positionOffset.length > 2 ? this.positionOffset.subarray(i$6 * 2, i$6 * 2 + 2) : this.positionOffset\n        };\n      }\n    } // single-color, single-baseline, single-align batch is faster to render\n    else {\n        if (this.count) {\n          this.batch = [{\n            count: this.count,\n            offset: 0,\n            color: this.color || [0, 0, 0, 255],\n            opacity: Array.isArray(this.opacity) ? this.opacity[0] : this.opacity,\n            baseline: this.baselineOffset[0],\n            align: this.alignOffset ? this.alignOffset[0] : 0,\n            atlas: this.fontAtlas[0],\n            positionOffset: this.positionOffset\n          }];\n        } else {\n          this.batch = [];\n        }\n      }\n  }\n};\n\nGlText.prototype.destroy = function destroy() {// TODO: count instances of atlases and destroy all on null\n}; // defaults\n\n\nGlText.prototype.kerning = true;\nGlText.prototype.position = {\n  constant: new Float32Array(2)\n};\nGlText.prototype.translate = null;\nGlText.prototype.scale = null;\nGlText.prototype.font = null;\nGlText.prototype.text = '';\nGlText.prototype.positionOffset = [0, 0];\nGlText.prototype.opacity = 1;\nGlText.prototype.color = new Uint8Array([0, 0, 0, 255]);\nGlText.prototype.alignOffset = [0, 0]; // whether viewport should be top↓bottom 2d one (true) or webgl one (false)\n\nGlText.normalViewport = false; // size of an atlas\n\nGlText.maxAtlasSize = 1024; // font atlas canvas is singleton\n\nGlText.atlasCanvas = document.createElement('canvas');\nGlText.atlasContext = GlText.atlasCanvas.getContext('2d', {\n  alpha: false\n}); // font-size used for metrics, atlas step calculation\n\nGlText.baseFontSize = 64; // fonts storage\n\nGlText.fonts = {}; // max number of different font atlases/textures cached\n// FIXME: enable atlas size limitation via LRU\n// GlText.atlasCacheSize = 64\n\nfunction isRegl(o) {\n  return typeof o === 'function' && o._gl && o.prop && o.texture && o.buffer;\n}\n\nmodule.exports = GlText;","map":{"version":3,"sources":["C:/Users/mikke/VSC/fantasy-django-react/fantasy-django/fantasy-react-app/node_modules/gl-text/dist.js"],"names":["Font","require","pick","createRegl","createGl","WeakMap","rgba","fontAtlas","pool","parseRect","isObj","parseUnit","px","kerning","extend","metrics","flatten","ref","nextPow2","shaderCache","isStretchSupported","document","body","el","appendChild","createElement","style","font","getComputedStyle","fontStretch","removeChild","GlText","o","isRegl","regl","gl","_gl","shader","get","charBuffer","buffer","type","usage","sizeBuffer","createShader","set","batch","fontSize","draw","bind","render","_refresh","canvas","update","prototype","blend","enable","color","func","srcRGB","dstRGB","srcAlpha","dstAlpha","stencil","depth","count","prop","offset","attributes","charOffset","stride","this","width","char","position","uniforms","atlasSize","c","p","atlas","height","atlasDim","cols","rows","texture","charStep","step","em","opacity","viewport","scale","align","baseline","translate","positionOffset","primitive","vert","normalViewport","frag","this$1","text","direction","range","Array","isArray","map","parseFloat","y","viewportArray","x","drawingBufferWidth","drawingBufferHeight","length","baseFontSize","newFont","newFontSize","forEach","i","parse","e","stringify","baseString","size","family","stretch","undefined","variant","weight","unit","fs","Math","round","fonts","join","push","origin","fontStyle","fontString","ceil","bottom","chars","ids","textArray","newAtlasChars","textOffsets","counts","i$1","idx","atlasContext","charAt","measureText","pairs","baseChar","flat","positionData","mallocFloat","i$2","ptr","j","j$1","call","data","freeFloat","destroy","constant","charIds","mallocUint8","sizeData","textWidth","i$3","ptr$1","count$1","j$2","prevChar","prevWidth","currWidth","prevOffset","kerning$1","freeUint8","maxCols","floor","maxAtlasSize","min","atlasWidth","atlasHeight","atlasCanvas","shape","alignOffset","baselineOffset","m","base","isNaN","colorData","l","sub","subarray","slice","i$4","l$1","i$5","isBatch","max","i$6","Float32Array","Uint8Array","getContext","alpha","module","exports"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nvar Font = require('css-font')\r\nvar pick = require('pick-by-alias')\r\nvar createRegl = require('regl')\r\nvar createGl = require('gl-util/context')\r\nvar WeakMap = require('es6-weak-map')\r\nvar rgba = require('color-normalize')\r\nvar fontAtlas = require('font-atlas')\r\nvar pool = require('typedarray-pool')\r\nvar parseRect = require('parse-rect')\r\nvar isObj = require('is-plain-obj')\r\nvar parseUnit = require('parse-unit')\r\nvar px = require('to-px')\r\nvar kerning = require('detect-kerning')\r\nvar extend = require('object-assign')\r\nvar metrics = require('font-measure')\r\nvar flatten = require('flatten-vertex-data')\r\nvar ref = require('bit-twiddle');\r\nvar nextPow2 = ref.nextPow2;\r\n\r\nvar shaderCache = new WeakMap\r\n\r\n\r\n// Safari does not support font-stretch\r\nvar isStretchSupported = false\r\nif (document.body) {\r\n    var el = document.body.appendChild(document.createElement('div'))\r\n    el.style.font = 'italic small-caps bold condensed 16px/2 cursive'\r\n    if (getComputedStyle(el).fontStretch) {\r\n        isStretchSupported = true\r\n    }\r\n    document.body.removeChild(el)\r\n}\r\n\r\nvar GlText = function GlText (o) {\r\n\tif (isRegl(o)) {\r\n\t\to = {regl: o}\r\n\t\tthis.gl = o.regl._gl\r\n\t}\r\n\telse {\r\n\t\tthis.gl = createGl(o)\r\n\t}\r\n\r\n\tthis.shader = shaderCache.get(this.gl)\r\n\r\n\tif (!this.shader) {\r\n\t\tthis.regl = o.regl || createRegl({ gl: this.gl })\r\n\t}\r\n\telse {\r\n\t\tthis.regl = this.shader.regl\r\n\t}\r\n\r\n\tthis.charBuffer = this.regl.buffer({ type: 'uint8', usage: 'stream' })\r\n\tthis.sizeBuffer = this.regl.buffer({ type: 'float', usage: 'stream' })\r\n\r\n\tif (!this.shader) {\r\n\t\tthis.shader = this.createShader()\r\n\t\tshaderCache.set(this.gl, this.shader)\r\n\t}\r\n\r\n\tthis.batch = []\r\n\r\n\t// multiple options initial state\r\n\tthis.fontSize = []\r\n\tthis.font = []\r\n\tthis.fontAtlas = []\r\n\r\n\tthis.draw = this.shader.draw.bind(this)\r\n\tthis.render = function () {\r\n\t\t// FIXME: add Safari regl report here:\r\n\t\t// charBuffer and width just do not trigger\r\n\t\tthis.regl._refresh()\r\n\t\tthis.draw(this.batch)\r\n\t}\r\n\tthis.canvas = this.gl.canvas\r\n\r\n\tthis.update(isObj(o) ? o : {})\r\n};\r\n\r\nGlText.prototype.createShader = function createShader () {\r\n\tvar regl = this.regl\r\n\r\n\t// FIXME: store 2 shader versions: with normal viewport and without\r\n\t// draw texture method\r\n\tvar draw = regl({\r\n\t\tblend: {\r\n\t\t\tenable: true,\r\n\t\t\tcolor: [0,0,0,1],\r\n\r\n\t\t\tfunc: {\r\n\t\t\t\tsrcRGB: 'src alpha',\r\n\t\t\t\tdstRGB: 'one minus src alpha',\r\n\t\t\t\tsrcAlpha: 'one minus dst alpha',\r\n\t\t\t\tdstAlpha: 'one'\r\n\t\t\t}\r\n\t\t},\r\n\t\tstencil: {enable: false},\r\n\t\tdepth: {enable: false},\r\n\r\n\t\tcount: regl.prop('count'),\r\n\t\toffset: regl.prop('offset'),\r\n\t\tattributes: {\r\n\t\t\tcharOffset: {\r\n\t\t\t\toffset: 4,\r\n\t\t\t\tstride: 8,\r\n\t\t\t\tbuffer: regl.this('sizeBuffer')\r\n\t\t\t},\r\n\t\t\twidth: {\r\n\t\t\t\toffset: 0,\r\n\t\t\t\tstride: 8,\r\n\t\t\t\tbuffer: regl.this('sizeBuffer')\r\n\t\t\t},\r\n\t\t\tchar: regl.this('charBuffer'),\r\n\t\t\tposition: regl.this('position')\r\n\t\t},\r\n\t\tuniforms: {\r\n\t\t\tatlasSize: function (c, p) { return [p.atlas.width, p.atlas.height]; },\r\n\t\t\tatlasDim: function (c, p) { return [p.atlas.cols, p.atlas.rows]; },\r\n\t\t\tatlas: function (c, p) { return p.atlas.texture; },\r\n\t\t\tcharStep: function (c, p) { return p.atlas.step; },\r\n\t\t\tem: function (c, p) { return p.atlas.em; },\r\n\t\t\tcolor: regl.prop('color'),\r\n\t\t\topacity: regl.prop('opacity'),\r\n\t\t\tviewport: regl.this('viewportArray'),\r\n\t\t\tscale: regl.this('scale'),\r\n\t\t\talign: regl.prop('align'),\r\n\t\t\tbaseline: regl.prop('baseline'),\r\n\t\t\ttranslate: regl.this('translate'),\r\n\t\t\tpositionOffset: regl.prop('positionOffset')\r\n\t\t},\r\n\t\tprimitive: 'points',\r\n\t\tviewport: regl.this('viewport'),\r\n\r\n\t\tvert: (\"\\n\\t\\t\\tprecision highp float;\\n\\t\\t\\tattribute float width, charOffset, char;\\n\\t\\t\\tattribute vec2 position;\\n\\t\\t\\tuniform float fontSize, charStep, em, align, baseline;\\n\\t\\t\\tuniform vec4 viewport;\\n\\t\\t\\tuniform vec4 color;\\n\\t\\t\\tuniform vec2 atlasSize, atlasDim, scale, translate, positionOffset;\\n\\t\\t\\tvarying vec2 charCoord, charId;\\n\\t\\t\\tvarying float charWidth;\\n\\t\\t\\tvarying vec4 fontColor;\\n\\t\\t\\tvoid main () {\\n\\t\\t\\t\\t\" + (!GlText.normalViewport ? 'vec2 positionOffset = vec2(positionOffset.x,- positionOffset.y);' : '') + \"\\n\\n\\t\\t\\t\\tvec2 offset = floor(em * (vec2(align + charOffset, baseline)\\n\\t\\t\\t\\t\\t+ positionOffset))\\n\\t\\t\\t\\t\\t/ (viewport.zw * scale.xy);\\n\\n\\t\\t\\t\\tvec2 position = (position + translate) * scale;\\n\\t\\t\\t\\tposition += offset * scale;\\n\\n\\t\\t\\t\\t\" + (GlText.normalViewport ? 'position.y = 1. - position.y;' : '') + \"\\n\\n\\t\\t\\t\\tcharCoord = position * viewport.zw + viewport.xy;\\n\\n\\t\\t\\t\\tgl_Position = vec4(position * 2. - 1., 0, 1);\\n\\n\\t\\t\\t\\tgl_PointSize = charStep;\\n\\n\\t\\t\\t\\tcharId.x = mod(char, atlasDim.x);\\n\\t\\t\\t\\tcharId.y = floor(char / atlasDim.x);\\n\\n\\t\\t\\t\\tcharWidth = width * em;\\n\\n\\t\\t\\t\\tfontColor = color / 255.;\\n\\t\\t\\t}\"),\r\n\r\n\t\tfrag: \"\\n\\t\\t\\tprecision highp float;\\n\\t\\t\\tuniform sampler2D atlas;\\n\\t\\t\\tuniform float fontSize, charStep, opacity;\\n\\t\\t\\tuniform vec2 atlasSize;\\n\\t\\t\\tuniform vec4 viewport;\\n\\t\\t\\tvarying vec4 fontColor;\\n\\t\\t\\tvarying vec2 charCoord, charId;\\n\\t\\t\\tvarying float charWidth;\\n\\n\\t\\t\\tfloat lightness(vec4 color) {\\n\\t\\t\\t\\treturn color.r * 0.299 + color.g * 0.587 + color.b * 0.114;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvoid main () {\\n\\t\\t\\t\\tvec2 uv = gl_FragCoord.xy - charCoord + charStep * .5;\\n\\t\\t\\t\\tfloat halfCharStep = floor(charStep * .5 + .5);\\n\\n\\t\\t\\t\\t// invert y and shift by 1px (FF expecially needs that)\\n\\t\\t\\t\\tuv.y = charStep - uv.y;\\n\\n\\t\\t\\t\\t// ignore points outside of character bounding box\\n\\t\\t\\t\\tfloat halfCharWidth = ceil(charWidth * .5);\\n\\t\\t\\t\\tif (floor(uv.x) > halfCharStep + halfCharWidth ||\\n\\t\\t\\t\\t\\tfloor(uv.x) < halfCharStep - halfCharWidth) return;\\n\\n\\t\\t\\t\\tuv += charId * charStep;\\n\\t\\t\\t\\tuv = uv / atlasSize;\\n\\n\\t\\t\\t\\tvec4 color = fontColor;\\n\\t\\t\\t\\tvec4 mask = texture2D(atlas, uv);\\n\\n\\t\\t\\t\\tfloat maskY = lightness(mask);\\n\\t\\t\\t\\t// float colorY = lightness(color);\\n\\t\\t\\t\\tcolor.a *= maskY;\\n\\t\\t\\t\\tcolor.a *= opacity;\\n\\n\\t\\t\\t\\t// color.a += .1;\\n\\n\\t\\t\\t\\t// antialiasing, see yiq color space y-channel formula\\n\\t\\t\\t\\t// color.rgb += (1. - color.rgb) * (1. - mask.rgb);\\n\\n\\t\\t\\t\\tgl_FragColor = color;\\n\\t\\t\\t}\"\r\n\t})\r\n\r\n\t// per font-size atlas\r\n\tvar atlas = {}\r\n\r\n\treturn { regl: regl, draw: draw, atlas: atlas }\r\n};\r\n\r\nGlText.prototype.update = function update (o) {\r\n\t\tvar this$1 = this;\r\n\r\n\tif (typeof o === 'string') { o = { text: o } }\r\n\telse if (!o) { return }\r\n\r\n\t// FIXME: make this a static transform or more general approact\r\n\to = pick(o, {\r\n\t\tposition: 'position positions coord coords coordinates',\r\n\t\tfont: 'font fontFace fontface typeface cssFont css-font family fontFamily',\r\n\t\tfontSize: 'fontSize fontsize size font-size',\r\n\t\ttext: 'text texts chars characters value values symbols',\r\n\t\talign: 'align alignment textAlign textbaseline',\r\n\t\tbaseline: 'baseline textBaseline textbaseline',\r\n\t\tdirection: 'dir direction textDirection',\r\n\t\tcolor: 'color colour fill fill-color fillColor textColor textcolor',\r\n\t\tkerning: 'kerning kern',\r\n\t\trange: 'range dataBox',\r\n\t\tviewport: 'vp viewport viewBox viewbox viewPort',\r\n\t\topacity: 'opacity alpha transparency visible visibility opaque',\r\n\t\toffset: 'offset positionOffset padding shift indent indentation'\r\n\t}, true)\r\n\r\n\r\n\tif (o.opacity != null) {\r\n\t\tif (Array.isArray(o.opacity)) {\r\n\t\t\tthis.opacity = o.opacity.map(function (o) { return parseFloat(o); })\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.opacity = parseFloat(o.opacity)\r\n\t\t}\r\n\t}\r\n\r\n\tif (o.viewport != null) {\r\n\t\tthis.viewport = parseRect(o.viewport)\r\n\r\n\t\tif (GlText.normalViewport) {\r\n\t\t\tthis.viewport.y = this.canvas.height - this.viewport.y - this.viewport.height\r\n\t\t}\r\n\r\n\t\tthis.viewportArray = [this.viewport.x, this.viewport.y, this.viewport.width, this.viewport.height]\r\n\r\n\t}\r\n\tif (this.viewport == null) {\r\n\t\tthis.viewport = {\r\n\t\t\tx: 0, y: 0,\r\n\t\t\twidth: this.gl.drawingBufferWidth,\r\n\t\t\theight: this.gl.drawingBufferHeight\r\n\t\t}\r\n\t\tthis.viewportArray = [this.viewport.x, this.viewport.y, this.viewport.width, this.viewport.height]\r\n\t}\r\n\r\n\tif (o.kerning != null) { this.kerning = o.kerning }\r\n\r\n\tif (o.offset != null) {\r\n\t\tif (typeof o.offset === 'number') { o.offset = [o.offset, 0] }\r\n\r\n\t\tthis.positionOffset = flatten(o.offset)\r\n\t}\r\n\r\n\tif (o.direction) { this.direction = o.direction }\r\n\r\n\tif (o.range) {\r\n\t\tthis.range = o.range\r\n\t\tthis.scale = [1 / (o.range[2] - o.range[0]), 1 / (o.range[3] - o.range[1])]\r\n\t\tthis.translate = [-o.range[0], -o.range[1]]\r\n\t}\r\n\tif (o.scale) { this.scale = o.scale }\r\n\tif (o.translate) { this.translate = o.translate }\r\n\r\n\t// default scale corresponds to viewport\r\n\tif (!this.scale) { this.scale = [1 / this.viewport.width, 1 / this.viewport.height] }\r\n\r\n\tif (!this.translate) { this.translate = [0, 0] }\r\n\r\n\tif (!this.font.length && !o.font) { o.font = GlText.baseFontSize + 'px sans-serif' }\r\n\r\n\t// normalize font caching string\r\n\tvar newFont = false, newFontSize = false\r\n\r\n\t// obtain new font data\r\n\tif (o.font) {\r\n\t\t(Array.isArray(o.font) ? o.font : [o.font]).forEach(function (font, i) {\r\n\t\t\t// normalize font\r\n\t\t\tif (typeof font === 'string') {\r\n\t\t\t\ttry {\r\n\t\t\t\t\tfont = Font.parse(font)\r\n\t\t\t\t} catch (e) {\r\n\t\t\t\t\tfont = Font.parse(GlText.baseFontSize + 'px ' + font)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse { font = Font.parse(Font.stringify(font)) }\r\n\r\n\t\t\tvar baseString = Font.stringify({\r\n\t\t\t\tsize: GlText.baseFontSize,\r\n\t\t\t\tfamily: font.family,\r\n\t\t\t\tstretch: isStretchSupported ? font.stretch : undefined,\r\n\t\t\t\tvariant: font.variant,\r\n\t\t\t\tweight: font.weight,\r\n\t\t\t\tstyle: font.style\r\n\t\t\t})\r\n\r\n\t\t\tvar unit = parseUnit(font.size)\r\n\t\t\tvar fs = Math.round(unit[0] * px(unit[1]))\r\n\t\t\tif (fs !== this$1.fontSize[i]) {\r\n\t\t\t\tnewFontSize = true\r\n\t\t\t\tthis$1.fontSize[i] = fs\r\n\t\t\t}\r\n\r\n\t\t\t// calc new font metrics/atlas\r\n\t\t\tif (!this$1.font[i] || baseString != this$1.font[i].baseString) {\r\n\t\t\t\tnewFont = true\r\n\r\n\t\t\t\t// obtain font cache or create one\r\n\t\t\t\tthis$1.font[i] = GlText.fonts[baseString]\r\n\t\t\t\tif (!this$1.font[i]) {\r\n\t\t\t\t\tvar family = font.family.join(', ')\r\n\t\t\t\t\tvar style = [font.style]\r\n\t\t\t\t\tif (font.style != font.variant) { style.push(font.variant) }\r\n\t\t\t\t\tif (font.variant != font.weight) { style.push(font.weight) }\r\n\t\t\t\t\tif (isStretchSupported && font.weight != font.stretch) { style.push(font.stretch) }\r\n\r\n\t\t\t\t\tthis$1.font[i] = {\r\n\t\t\t\t\t\tbaseString: baseString,\r\n\r\n\t\t\t\t\t\t// typeface\r\n\t\t\t\t\t\tfamily: family,\r\n\t\t\t\t\t\tweight: font.weight,\r\n\t\t\t\t\t\tstretch: font.stretch,\r\n\t\t\t\t\t\tstyle: font.style,\r\n\t\t\t\t\t\tvariant: font.variant,\r\n\r\n\t\t\t\t\t\t// widths of characters\r\n\t\t\t\t\t\twidth: {},\r\n\r\n\t\t\t\t\t\t// kernin pairs offsets\r\n\t\t\t\t\t\tkerning: {},\r\n\r\n\t\t\t\t\t\tmetrics: metrics(family, {\r\n\t\t\t\t\t\t\torigin: 'top',\r\n\t\t\t\t\t\t\tfontSize: GlText.baseFontSize,\r\n\t\t\t\t\t\t\tfontStyle: style.join(' ')\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tGlText.fonts[baseString] = this$1.font[i]\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\t// FIXME: make independend font-size\r\n\t// if (o.fontSize) {\r\n\t// let unit = parseUnit(o.fontSize)\r\n\t// let fs = Math.round(unit[0] * px(unit[1]))\r\n\r\n\t// if (fs != this.fontSize) {\r\n\t// \tnewFontSize = true\r\n\t// \tthis.fontSize = fs\r\n\t// }\r\n\t// }\r\n\r\n\tif (newFont || newFontSize) {\r\n\t\tthis.font.forEach(function (font, i) {\r\n\t\t\tvar fontString = Font.stringify({\r\n\t\t\t\tsize: this$1.fontSize[i],\r\n\t\t\t\tfamily: font.family,\r\n\t\t\t\tstretch: isStretchSupported ? font.stretch : undefined,\r\n\t\t\t\tvariant: font.variant,\r\n\t\t\t\tweight: font.weight,\r\n\t\t\t\tstyle: font.style\r\n\t\t\t})\r\n\r\n\t\t\t// calc new font size atlas\r\n\t\t\tthis$1.fontAtlas[i] = this$1.shader.atlas[fontString]\r\n\r\n\t\t\tif (!this$1.fontAtlas[i]) {\r\n\t\t\t\tvar metrics = font.metrics\r\n\r\n\t\t\t\tthis$1.shader.atlas[fontString] =\r\n\t\t\t\tthis$1.fontAtlas[i] = {\r\n\t\t\t\t\tfontString: fontString,\r\n\t\t\t\t\t// even step is better for rendered characters\r\n\t\t\t\t\tstep: Math.ceil(this$1.fontSize[i] * metrics.bottom * .5) * 2,\r\n\t\t\t\t\tem: this$1.fontSize[i],\r\n\t\t\t\t\tcols: 0,\r\n\t\t\t\t\trows: 0,\r\n\t\t\t\t\theight: 0,\r\n\t\t\t\t\twidth: 0,\r\n\t\t\t\t\tchars: [],\r\n\t\t\t\t\tids: {},\r\n\t\t\t\t\ttexture: this$1.regl.texture()\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// bump atlas characters\r\n\t\t\tif (o.text == null) { o.text = this$1.text }\r\n\t\t})\r\n\t}\r\n\r\n\t// if multiple positions - duplicate text arguments\r\n\t// FIXME: this possibly can be done better to avoid array spawn\r\n\tif (typeof o.text === 'string' && o.position && o.position.length > 2) {\r\n\t\tvar textArray = Array(o.position.length * .5)\r\n\t\tfor (var i = 0; i < textArray.length; i++) {\r\n\t\t\ttextArray[i] = o.text\r\n\t\t}\r\n\t\to.text = textArray\r\n\t}\r\n\r\n\t// calculate offsets for the new font/text\r\n\tvar newAtlasChars\r\n\tif (o.text != null || newFont) {\r\n\t\t// FIXME: ignore spaces\r\n\t\t// text offsets within the text buffer\r\n\t\tthis.textOffsets = [0]\r\n\r\n\t\tif (Array.isArray(o.text)) {\r\n\t\t\tthis.count = o.text[0].length\r\n\t\t\tthis.counts = [this.count]\r\n\t\t\tfor (var i$1 = 1; i$1 < o.text.length; i$1++) {\r\n\t\t\t\tthis.textOffsets[i$1] = this.textOffsets[i$1 - 1] + o.text[i$1 - 1].length\r\n\t\t\t\tthis.count += o.text[i$1].length\r\n\t\t\t\tthis.counts.push(o.text[i$1].length)\r\n\t\t\t}\r\n\t\t\tthis.text = o.text.join('')\r\n\t\t}\r\n\t\telse {\r\n\t\t\tthis.text = o.text\r\n\t\t\tthis.count = this.text.length\r\n\t\t\tthis.counts = [this.count]\r\n\t\t}\r\n\r\n\t\tnewAtlasChars = []\r\n\r\n\t\t// detect & measure new characters\r\n\t\tthis.font.forEach(function (font, idx) {\r\n\t\t\tGlText.atlasContext.font = font.baseString\r\n\r\n\t\t\tvar atlas = this$1.fontAtlas[idx]\r\n\r\n\t\t\tfor (var i = 0; i < this$1.text.length; i++) {\r\n\t\t\t\tvar char = this$1.text.charAt(i)\r\n\r\n\t\t\t\tif (atlas.ids[char] == null) {\r\n\t\t\t\t\tatlas.ids[char] = atlas.chars.length\r\n\t\t\t\t\tatlas.chars.push(char)\r\n\t\t\t\t\tnewAtlasChars.push(char)\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (font.width[char] == null) {\r\n\t\t\t\t\tfont.width[char] = GlText.atlasContext.measureText(char).width / GlText.baseFontSize\r\n\r\n\t\t\t\t\t// measure kerning pairs for the new character\r\n\t\t\t\t\tif (this$1.kerning) {\r\n\t\t\t\t\t\tvar pairs = []\r\n\t\t\t\t\t\tfor (var baseChar in font.width) {\r\n\t\t\t\t\t\t\tpairs.push(baseChar + char, char + baseChar)\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\textend(font.kerning, kerning(font.family, {\r\n\t\t\t\t\t\t\tpairs: pairs\r\n\t\t\t\t\t\t}))\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t})\r\n\t}\r\n\r\n\t// create single position buffer (faster than batch or multiple separate instances)\r\n\tif (o.position) {\r\n\t\tif (o.position.length > 2) {\r\n\t\t\tvar flat = !o.position[0].length\r\n\t\t\tvar positionData = pool.mallocFloat(this.count * 2)\r\n\t\t\tfor (var i$2 = 0, ptr = 0; i$2 < this.counts.length; i$2++) {\r\n\t\t\t\tvar count = this.counts[i$2]\r\n\t\t\t\tif (flat) {\r\n\t\t\t\t\tfor (var j = 0; j < count; j++) {\r\n\t\t\t\t\t\tpositionData[ptr++] = o.position[i$2 * 2]\r\n\t\t\t\t\t\tpositionData[ptr++] = o.position[i$2 * 2 + 1]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tfor (var j$1 = 0; j$1 < count; j$1++) {\r\n\t\t\t\t\t\tpositionData[ptr++] = o.position[i$2][0]\r\n\t\t\t\t\t\tpositionData[ptr++] = o.position[i$2][1]\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (this.position.call) {\r\n\t\t\t\tthis.position({\r\n\t\t\t\t\ttype: 'float',\r\n\t\t\t\t\tdata: positionData\r\n\t\t\t\t})\r\n\t\t\t} else {\r\n\t\t\t\tthis.position = this.regl.buffer({\r\n\t\t\t\t\ttype: 'float',\r\n\t\t\t\t\tdata: positionData\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\tpool.freeFloat(positionData)\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (this.position.destroy) { this.position.destroy() }\r\n\t\t\tthis.position = {\r\n\t\t\t\tconstant: o.position\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// populate text/offset buffers if font/text has changed\r\n\t// as [charWidth, offset, charWidth, offset...]\r\n\t// that is in em units since font-size can change often\r\n\tif (o.text || newFont) {\r\n\t\tvar charIds = pool.mallocUint8(this.count)\r\n\t\tvar sizeData = pool.mallocFloat(this.count * 2)\r\n\t\tthis.textWidth = []\r\n\r\n\t\tfor (var i$3 = 0, ptr$1 = 0; i$3 < this.counts.length; i$3++) {\r\n\t\t\tvar count$1 = this.counts[i$3]\r\n\t\t\tvar font = this.font[i$3] || this.font[0]\r\n\t\t\tvar atlas = this.fontAtlas[i$3] || this.fontAtlas[0]\r\n\r\n\t\t\tfor (var j$2 = 0; j$2 < count$1; j$2++) {\r\n\t\t\t\tvar char = this.text.charAt(ptr$1)\r\n\t\t\t\tvar prevChar = this.text.charAt(ptr$1 - 1)\r\n\r\n\t\t\t\tcharIds[ptr$1] = atlas.ids[char]\r\n\t\t\t\tsizeData[ptr$1 * 2] = font.width[char]\r\n\r\n\t\t\t\tif (j$2) {\r\n\t\t\t\t\tvar prevWidth = sizeData[ptr$1 * 2 - 2]\r\n\t\t\t\t\tvar currWidth = sizeData[ptr$1 * 2]\r\n\t\t\t\t\tvar prevOffset = sizeData[ptr$1 * 2 - 1]\r\n\t\t\t\t\tvar offset = prevOffset + prevWidth * .5 + currWidth * .5;\r\n\r\n\t\t\t\t\tif (this.kerning) {\r\n\t\t\t\t\t\tvar kerning$1 = font.kerning[prevChar + char]\r\n\t\t\t\t\t\tif (kerning$1) {\r\n\t\t\t\t\t\t\toffset += kerning$1 * 1e-3\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tsizeData[ptr$1 * 2 + 1] = offset\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tsizeData[ptr$1 * 2 + 1] = sizeData[ptr$1 * 2] * .5\r\n\t\t\t\t}\r\n\r\n\t\t\t\tptr$1++\r\n\t\t\t}\r\n\t\t\tthis.textWidth.push(\r\n\t\t\t\t!sizeData.length ? 0 :\r\n\t\t\t\t// last offset + half last width\r\n\t\t\t\tsizeData[ptr$1 * 2 - 2] * .5 + sizeData[ptr$1 * 2 - 1]\r\n\t\t\t)\r\n\t\t}\r\n\r\n\r\n\t\t// bump recalc align offset\r\n\t\tif (!o.align) { o.align = this.align }\r\n\t\tthis.charBuffer({data: charIds, type: 'uint8', usage: 'stream'})\r\n\t\tthis.sizeBuffer({data: sizeData, type: 'float', usage: 'stream'})\r\n\t\tpool.freeUint8(charIds)\r\n\t\tpool.freeFloat(sizeData)\r\n\r\n\t\t// udpate font atlas and texture\r\n\t\tif (newAtlasChars.length) {\r\n\t\t\tthis.font.forEach(function (font, i) {\r\n\t\t\t\tvar atlas = this$1.fontAtlas[i]\r\n\r\n\t\t\t\t// FIXME: insert metrics-based ratio here\r\n\t\t\t\tvar step = atlas.step\r\n\r\n\t\t\t\tvar maxCols = Math.floor(GlText.maxAtlasSize / step)\r\n\t\t\t\tvar cols = Math.min(maxCols, atlas.chars.length)\r\n\t\t\t\tvar rows = Math.ceil(atlas.chars.length / cols)\r\n\r\n\t\t\t\tvar atlasWidth = nextPow2( cols * step )\r\n\t\t\t\t// let atlasHeight = Math.min(rows * step + step * .5, GlText.maxAtlasSize);\r\n\t\t\t\tvar atlasHeight = nextPow2( rows * step );\r\n\r\n\t\t\t\tatlas.width = atlasWidth\r\n\t\t\t\tatlas.height = atlasHeight;\r\n\t\t\t\tatlas.rows = rows\r\n\t\t\t\tatlas.cols = cols\r\n\r\n\t\t\t\tif (!atlas.em) { return }\r\n\r\n\t\t\t\tatlas.texture({\r\n\t\t\t\t\tdata: fontAtlas({\r\n\t\t\t\t\t\tcanvas: GlText.atlasCanvas,\r\n\t\t\t\t\t\tfont: atlas.fontString,\r\n\t\t\t\t\t\tchars: atlas.chars,\r\n\t\t\t\t\t\tshape: [atlasWidth, atlasHeight],\r\n\t\t\t\t\t\tstep: [step, step]\r\n\t\t\t\t\t})\r\n\t\t\t\t})\r\n\r\n\t\t\t})\r\n\t\t}\r\n\t}\r\n\r\n\tif (o.align) {\r\n\t\tthis.align = o.align\r\n\t\tthis.alignOffset = this.textWidth.map(function (textWidth, i) {\r\n\t\t\tvar align = !Array.isArray(this$1.align) ? this$1.align : this$1.align.length > 1 ? this$1.align[i] : this$1.align[0]\r\n\r\n\t\t\tif (typeof align === 'number') { return align }\r\n\t\t\tswitch (align) {\r\n\t\t\t\tcase 'right':\r\n\t\t\t\tcase 'end':\r\n\t\t\t\t\treturn -textWidth\r\n\t\t\t\tcase 'center':\r\n\t\t\t\tcase 'centre':\r\n\t\t\t\tcase 'middle':\r\n\t\t\t\t\treturn -textWidth * .5\r\n\t\t\t}\r\n\r\n\t\t\treturn 0\r\n\t\t})\r\n\t}\r\n\r\n\tif (this.baseline == null && o.baseline == null) {\r\n\t\to.baseline = 0\r\n\t}\r\n\tif (o.baseline != null) {\r\n\t\tthis.baseline = o.baseline\r\n\t\tif (!Array.isArray(this.baseline)) { this.baseline = [this.baseline] }\r\n\t\tthis.baselineOffset = this.baseline.map(function (baseline, i) {\r\n\t\t\tvar m = (this$1.font[i] || this$1.font[0]).metrics\r\n\t\t\tvar base = 0\r\n\r\n\t\t\tbase += m.bottom * .5\r\n\r\n\t\t\tif (typeof baseline === 'number') {\r\n\t\t\t\tbase += (baseline - m.baseline)\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tbase += -m[baseline]\r\n\t\t\t}\r\n\r\n\t\t\tif (!GlText.normalViewport) { base *= -1 }\r\n\t\t\treturn base\r\n\t\t})\r\n\t}\r\n\r\n\t// flatten colors to a single uint8 array\r\n\tif (o.color != null) {\r\n\t\tif (!o.color) { o.color = 'transparent' }\r\n\r\n\t\t// single color\r\n\t\tif (typeof o.color === 'string' || !isNaN(o.color)) {\r\n\t\t\tthis.color = rgba(o.color, 'uint8')\r\n\t\t}\r\n\t\t// array\r\n\t\telse {\r\n\t\t\tvar colorData\r\n\r\n\t\t\t// flat array\r\n\t\t\tif (typeof o.color[0] === 'number' && o.color.length > this.counts.length) {\r\n\t\t\t\tvar l = o.color.length\r\n\t\t\t\tcolorData = pool.mallocUint8(l)\r\n\t\t\t\tvar sub = (o.color.subarray || o.color.slice).bind(o.color)\r\n\t\t\t\tfor (var i$4 = 0; i$4 < l; i$4 += 4) {\r\n\t\t\t\t\tcolorData.set(rgba(sub(i$4, i$4 + 4), 'uint8'), i$4)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t// nested array\r\n\t\t\telse {\r\n\t\t\t\tvar l$1 = o.color.length\r\n\t\t\t\tcolorData = pool.mallocUint8(l$1 * 4)\r\n\t\t\t\tfor (var i$5 = 0; i$5 < l$1; i$5++) {\r\n\t\t\t\t\tcolorData.set(rgba(o.color[i$5] || 0, 'uint8'), i$5 * 4)\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tthis.color = colorData\r\n\t\t}\r\n\t}\r\n\r\n\t// update render batch\r\n\tif (o.position || o.text || o.color || o.baseline || o.align || o.font || o.offset || o.opacity) {\r\n\t\tvar isBatch = (this.color.length > 4)\r\n\t\t\t|| (this.baselineOffset.length > 1)\r\n\t\t\t|| (this.align && this.align.length > 1)\r\n\t\t\t|| (this.fontAtlas.length > 1)\r\n\t\t\t|| (this.positionOffset.length > 2)\r\n\t\tif (isBatch) {\r\n\t\t\tvar length = Math.max(\r\n\t\t\t\tthis.position.length * .5 || 0,\r\n\t\t\t\tthis.color.length * .25 || 0,\r\n\t\t\t\tthis.baselineOffset.length || 0,\r\n\t\t\t\tthis.alignOffset.length || 0,\r\n\t\t\t\tthis.font.length || 0,\r\n\t\t\t\tthis.opacity.length || 0,\r\n\t\t\t\tthis.positionOffset.length * .5 || 0\r\n\t\t\t)\r\n\t\t\tthis.batch = Array(length)\r\n\t\t\tfor (var i$6 = 0; i$6 < this.batch.length; i$6++) {\r\n\t\t\t\tthis.batch[i$6] = {\r\n\t\t\t\t\tcount: this.counts.length > 1 ? this.counts[i$6] : this.counts[0],\r\n\t\t\t\t\toffset: this.textOffsets.length > 1 ? this.textOffsets[i$6] : this.textOffsets[0],\r\n\t\t\t\t\tcolor: !this.color ? [0,0,0,255] : this.color.length <= 4 ? this.color : this.color.subarray(i$6 * 4, i$6 * 4 + 4),\r\n\t\t\t\t\topacity: Array.isArray(this.opacity) ? this.opacity[i$6] : this.opacity,\r\n\t\t\t\t\tbaseline: this.baselineOffset[i$6] != null ? this.baselineOffset[i$6] : this.baselineOffset[0],\r\n\t\t\t\t\talign: !this.align ? 0 : this.alignOffset[i$6] != null ? this.alignOffset[i$6] : this.alignOffset[0],\r\n\t\t\t\t\tatlas: this.fontAtlas[i$6] || this.fontAtlas[0],\r\n\t\t\t\t\tpositionOffset: this.positionOffset.length > 2 ? this.positionOffset.subarray(i$6 * 2, i$6 * 2 + 2) : this.positionOffset\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// single-color, single-baseline, single-align batch is faster to render\r\n\t\telse {\r\n\t\t\tif (this.count) {\r\n\t\t\t\tthis.batch = [{\r\n\t\t\t\t\tcount: this.count,\r\n\t\t\t\t\toffset: 0,\r\n\t\t\t\t\tcolor: this.color || [0,0,0,255],\r\n\t\t\t\t\topacity: Array.isArray(this.opacity) ? this.opacity[0] : this.opacity,\r\n\t\t\t\t\tbaseline: this.baselineOffset[0],\r\n\t\t\t\t\talign: this.alignOffset ? this.alignOffset[0] : 0,\r\n\t\t\t\t\tatlas: this.fontAtlas[0],\r\n\t\t\t\t\tpositionOffset: this.positionOffset\r\n\t\t\t\t}]\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tthis.batch = []\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n};\r\n\r\nGlText.prototype.destroy = function destroy () {\r\n\t// TODO: count instances of atlases and destroy all on null\r\n};\r\n\r\n\r\n// defaults\r\nGlText.prototype.kerning = true\r\nGlText.prototype.position = { constant: new Float32Array(2) }\r\nGlText.prototype.translate = null\r\nGlText.prototype.scale = null\r\nGlText.prototype.font = null\r\nGlText.prototype.text = ''\r\nGlText.prototype.positionOffset = [0, 0]\r\nGlText.prototype.opacity = 1\r\nGlText.prototype.color = new Uint8Array([0, 0, 0, 255])\r\nGlText.prototype.alignOffset = [0, 0]\r\n\r\n\r\n// whether viewport should be top↓bottom 2d one (true) or webgl one (false)\r\nGlText.normalViewport = false\r\n\r\n// size of an atlas\r\nGlText.maxAtlasSize = 1024\r\n\r\n// font atlas canvas is singleton\r\nGlText.atlasCanvas = document.createElement('canvas')\r\nGlText.atlasContext = GlText.atlasCanvas.getContext('2d', {alpha: false})\r\n\r\n// font-size used for metrics, atlas step calculation\r\nGlText.baseFontSize = 64\r\n\r\n// fonts storage\r\nGlText.fonts = {}\r\n\r\n// max number of different font atlases/textures cached\r\n// FIXME: enable atlas size limitation via LRU\r\n// GlText.atlasCacheSize = 64\r\n\r\nfunction isRegl (o) {\r\n\treturn typeof o === 'function' &&\r\n\to._gl &&\r\n\to.prop &&\r\n\to.texture &&\r\n\to.buffer\r\n}\r\n\r\n\r\nmodule.exports = GlText\r\n\r\n"]},"metadata":{},"sourceType":"script"}